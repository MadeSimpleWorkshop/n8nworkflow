{
  "name": "Archive Version Control",
  "nodes": [
    {
      "id": "92a5516b-cdf3-4dcd-8874-911dfbeb77db",
      "name": "Merge Triggers",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        0,
        0
      ],
      "parameters": {
        "mode": "chooseBranch",
        "output": "all",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "10b2454a",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v3\nüîí Hash: 10b2454a\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UubWVyZ2UiLCJuYW1lIjoiTWVyZ2UgVHJpZ2dlcnMiLCJ0eXBlVmVyc2lvbiI6MywicGFyYW1ldGVyS2V5cyI6WyJtb2RlIiwib3V0cHV0Il0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "e36f693a-e9d1-4006-adbf-476ec302cec2",
      "name": "Parse Configuration",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -112,
        272
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\n// Configuration with defaults\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/data/workflow-backups',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl ||  'http://localhost:5678/api/v1',\n  n8nApiKey: input.n8nApiKey || input.body?.n8nApiKey || '',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null, // null = auto-generate\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nreturn { json: config };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "17dd43cd",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 17dd43cd\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "647b4e6d-087a-41b6-a047-c997c1958953",
      "name": "Fetch Current Workflow",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        64,
        272
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.n8nApiKey }}"
            }
          ]
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "22aea478",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 22aea478\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdyIsInR5cGVWZXJzaW9uIjo0LjIsInBhcmFtZXRlcktleXMiOlsiaGVhZGVyUGFyYW1ldGVycyIsIm9wdGlvbnMiLCJzZW5kSGVhZGVycyIsInVybCJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnsiaGVhZGVyUGFyYW1ldGVycyI6eyJwYXJhbUNvdW50IjoxfX19",
      "notesInFlow": true
    },
    {
      "id": "06846a43-58e7-4bc7-8e46-813bd6e25470",
      "name": "Has Changes?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        432,
        272
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsiY29uZGl0aW9ucyIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "b1a2040c-1035-40e9-bcd6-67aa3ade7d1a",
      "name": "No Changes Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1120,
        656
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'No changes detected', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: data.workflowVersion.current, timestamp: data.timestamp } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3919f890",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3919f890\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "77fd358d-b343-4d12-b1b4-91b851a0331f",
      "name": "Dry Run?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        720,
        256
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj8iLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "131020a0-d7ee-4d83-b308-b9fb67ec0620",
      "name": "Update Workflow with Versions",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        944,
        368
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.config.n8nApiKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2b165197",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 2b165197\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnMiLCJ0eXBlVmVyc2lvbiI6NC4yLCJwYXJhbWV0ZXJLZXlzIjpbImhlYWRlclBhcmFtZXRlcnMiLCJqc29uQm9keSIsIm1ldGhvZCIsIm9wdGlvbnMiLCJzZW5kQm9keSIsInNlbmRIZWFkZXJzIiwic3BlY2lmeUJvZHkiLCJ1cmwiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7ImhlYWRlclBhcmFtZXRlcnMiOnsicGFyYW1Db3VudCI6Mn19fQ==",
      "notesInFlow": true
    },
    {
      "id": "af981066-3f4b-4d68-92b3-3a0ccea43a8b",
      "name": "Dry Run Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        960,
        128
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'Dry run completed - no changes applied', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: { previous: data.workflowVersion.previous, wouldBecome: data.workflowVersion.current }, changes: data.nodeChanges, timestamp: data.timestamp, dryRun: true } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5226f176",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5226f176\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "66df9726-5f21-4bb2-a665-9498104c463a",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        1744,
        352
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2siLCJ0eXBlVmVyc2lvbiI6MS4xLCJwYXJhbWV0ZXJLZXlzIjpbIm9wdGlvbnMiLCJyZXNwb25kV2l0aCIsInJlc3BvbnNlQm9keSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "5162a401-68d4-4479-935a-97f0fc5e4cc8",
      "name": "Process Node Versions4",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        272,
        160
      ],
      "parameters": {
        "jsCode": "const config = $('Parse Configuration').first().json;\nconst workflow = $input.first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction hashNode(node) {\n  const nodeForHash = { ...node };\n  if (nodeForHash.parameters?._versionControl) {\n    const params = { ...nodeForHash.parameters };\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  }\n  delete nodeForHash.notes;\n  return simpleHash(JSON.stringify(nodeForHash));\n}\n\nfunction incrementVersion(version, changeType) {\n  const parts = (version || '1.0.0').split('.').map(Number);\n  if (changeType === 'major') return `${parts[0] + 1}.0.0`;\n  if (changeType === 'minor') return `${parts[0]}.${parts[1] + 1}.0`;\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric', hour: '2-digit', minute: '2-digit' });\n}\n\nfunction buildNodeNotes(vc, typeVer) {\n  const lines = [`üìå Version: ${vc.version}`, `üìÖ Modified: ${formatDate(vc.lastModified)}`, `üîß Node Type: v${typeVer || 'N/A'}`];\n  if (vc.created && vc.created !== vc.lastModified) lines.push(`üÜï Created: ${formatDate(vc.created)}`);\n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { id: node.id, name: node.name, type: node.type, typeVersion: node.typeVersion, position: node.position, parameters: node.parameters };\n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.notes) cleaned.notes = node.notes;\n  if (node.notesInFlow) cleaned.notesInFlow = node.notesInFlow;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const vc = node.parameters?._versionControl || { version: '1.0.0', hash: null, lastModified: null, history: [] };\n  const previousHash = vc.hash;\n  const hasChanged = previousHash && previousHash !== currentHash;\n  const isNew = !previousHash;\n  let newVc = { ...vc };\n\n  if (isNew) {\n    newVc = { nodeTypeVersion: node.typeVersion, contentVersion: '1.0.0', version: '1.0.0', hash: currentHash, created: timestamp, lastModified: timestamp, history: [{ version: '1.0.0', timestamp, action: 'created', hash: currentHash }] };\n    nodeChanges.push({ nodeName: node.name, nodeId: node.id, action: 'created', version: '1.0.0', changes: [] });\n  } else if (hasChanged) {\n    const newVersion = incrementVersion(vc.version, 'patch');\n    newVc = { ...vc, nodeTypeVersion: node.typeVersion, contentVersion: newVersion, version: newVersion, hash: currentHash, lastModified: timestamp, history: [...vc.history.slice(-9), { version: newVersion, timestamp, action: 'modified', previousHash, hash: currentHash }] };\n    nodeChanges.push({ nodeName: node.name, nodeId: node.id, action: 'modified', previousVersion: vc.version, version: newVersion, changes: [] });\n  }\n\n  const updatedNode = cleanNode({ ...node, notes: buildNodeNotes(newVc, node.typeVersion), parameters: { ...node.parameters, _versionControl: newVc } });\n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version from node versions\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => n.parameters?._versionControl?.version || '1.0.0');\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings - only allowed properties, NO custom fields\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\n\nconst updatedWorkflow = { name: workflow.name, nodes: updatedNodes, connections: workflow.connections, settings: cleanSettings };\n\nreturn { json: { config, originalWorkflow: workflow, updatedWorkflow, nodeChanges, hasChanges: nodeChanges.length > 0, workflowVersion: { previous: '1.0.0', current: wfNewVersion }, timestamp } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1dbac19d",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 1dbac19d\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnM0IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "fe5f07dd-8125-4fb3-9541-4c34ad3e139c",
      "name": "Build Success Response1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1152,
        368
      ],
      "parameters": {
        "jsCode": "const processData = $('Dry Run?').first().json;\nconst apiResponse = $input.first().json;\nreturn { json: { success: true, message: `Workflow saved: v${processData.workflowVersion.previous} ‚Üí v${processData.workflowVersion.current}`, workflowId: processData.config.workflowId, workflowName: apiResponse.name || processData.updatedWorkflow.name, version: { previous: processData.workflowVersion.previous, current: processData.workflowVersion.current }, changes: processData.nodeChanges, timestamp: processData.timestamp, dryRun: false } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "6d4cab7d",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 6d4cab7d\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlMSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "917b60f4-cdec-4839-9549-93df4a7f4fd5",
      "name": "When Executed by Another Workflow",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -368,
        -432
      ],
      "parameters": {
        "inputSource": "jsonExample",
        "jsonExample": "{\n  \n  \n\"workflowId\": \n\"Rv-Y2Rw2EHQVspwmX-Kgb\",\n  \n  \n\"gitEnabled\": \nfalse,\n  \n  \n\"localBackupPath\": \n\"/data/workflow-backups/local\",\n  \n  \n\"n8nApiUrl\": \n\"http://localhost:5678/api/v1\",\n  \n  \n\"n8nApiKey\": \n\"N8N_API_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJkNGRhMDcwZi1hMWE1LTRmODktOGIzZS05MTEzNWExYThkMWMiLCJpc3MiOiJuOG4iLCJhdWQiOiJwdWJsaWMtYXBpIiwiaWF0IjoxNzcwMjQzNjc1fQ.eJsCwAv0z6rZ2p6YVuqH6s9lzJXzkMgt7uDl6QIY3ek\",\n  \n  \n\"dryRun\": \nfalse\n  \n}",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "37c0c960",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 37c0c960\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZXhlY3V0ZVdvcmtmbG93VHJpZ2dlciIsIm5hbWUiOiJXaGVuIEV4ZWN1dGVkIGJ5IEFub3RoZXIgV29ya2Zsb3ciLCJ0eXBlVmVyc2lvbiI6MS4xLCJwYXJhbWV0ZXJLZXlzIjpbImlucHV0U291cmNlIiwianNvbkV4YW1wbGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "181681a8-817e-4f1a-9810-66cf9819c893",
      "name": "Parse Configuration1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -144,
        -432
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\n// Configuration with defaults\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/data/workflow-backups',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl ||  'http://localhost:5678/api/v1',\n  n8nApiKey: input.n8nApiKey || input.body?.n8nApiKey || '',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null, // null = auto-generate\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nreturn { json: config };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "17dd43cd",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 17dd43cd\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uMSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "186cb23c-7691-45c7-a9b5-99ed81eb65d2",
      "name": "Fetch Current Workflow1",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        32,
        -432
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.n8nApiKey }}"
            }
          ]
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "22aea478",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 22aea478\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzEiLCJ0eXBlVmVyc2lvbiI6NC4yLCJwYXJhbWV0ZXJLZXlzIjpbImhlYWRlclBhcmFtZXRlcnMiLCJvcHRpb25zIiwic2VuZEhlYWRlcnMiLCJ1cmwiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7ImhlYWRlclBhcmFtZXRlcnMiOnsicGFyYW1Db3VudCI6MX19fQ==",
      "notesInFlow": true
    },
    {
      "id": "b7f9b88e-9ca3-421b-a145-166609ce0697",
      "name": "Has Changes?1",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        400,
        -432
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/MSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "e1516663-9e43-4f71-ae6d-6e117fe9457d",
      "name": "No Changes Response1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1040,
        -96
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'No changes detected', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: data.workflowVersion.current, timestamp: data.timestamp } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3919f890",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3919f890\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlMSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "93d0f9cc-0421-4391-9f0e-5015b949b870",
      "name": "Dry Run?1",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        688,
        -448
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj8xIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsiY29uZGl0aW9ucyIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "531a8b22-7e47-47f8-9aa3-9b83664af9ba",
      "name": "Update Workflow with Versions1",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        912,
        -336
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.config.n8nApiKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2b165197",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 2b165197\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnMxIiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJoZWFkZXJQYXJhbWV0ZXJzIiwianNvbkJvZHkiLCJtZXRob2QiLCJvcHRpb25zIiwic2VuZEJvZHkiLCJzZW5kSGVhZGVycyIsInNwZWNpZnlCb2R5IiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjJ9fX0=",
      "notesInFlow": true
    },
    {
      "id": "7dccc482-2bbc-4aad-9309-96653db7ab44",
      "name": "Dry Run Response1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1056,
        -608
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'Dry run completed - no changes applied', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: { previous: data.workflowVersion.previous, wouldBecome: data.workflowVersion.current }, changes: data.nodeChanges, timestamp: data.timestamp, dryRun: true } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5226f176",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5226f176\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlMSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "b5fde829-5157-4604-8dd1-6edec193f7b7",
      "name": "Respond to Webhook1",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        1712,
        -352
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2sxIiwidHlwZVZlcnNpb24iOjEuMSwicGFyYW1ldGVyS2V5cyI6WyJvcHRpb25zIiwicmVzcG9uZFdpdGgiLCJyZXNwb25zZUJvZHkiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "644a6636-f585-4cbb-8765-bdf1f3845345",
      "name": "Process Node Versions",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        240,
        -544
      ],
      "parameters": {
        "jsCode": "const config = $('Parse Configuration1').first().json;\nconst workflow = $input.first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction hashNode(node) {\n  const nodeForHash = { ...node };\n  if (nodeForHash.parameters?._versionControl) {\n    const params = { ...nodeForHash.parameters };\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  }\n  delete nodeForHash.notes;\n  delete nodeForHash.notesInFlow;\n  return simpleHash(JSON.stringify(nodeForHash));\n}\n\nfunction incrementVersion(version, changeType) {\n  const parts = (version || '1.0.0').split('.').map(Number);\n  if (changeType === 'major') return `${parts[0] + 1}.0.0`;\n  if (changeType === 'minor') return `${parts[0]}.${parts[1] + 1}.0`;\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric', hour: '2-digit', minute: '2-digit' });\n}\n\nfunction buildNodeNotes(vc, typeVer) {\n  const lines = [`üìå Version: ${vc.version}`, `üìÖ Modified: ${formatDate(vc.lastModified)}`, `üîß Node Type: v${typeVer || 'N/A'}`];\n  if (vc.created && vc.created !== vc.lastModified) lines.push(`üÜï Created: ${formatDate(vc.created)}`);\n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { id: node.id, name: node.name, type: node.type, typeVersion: node.typeVersion, position: node.position, parameters: node.parameters };\n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  \n  // ALWAYS include notes and notesInFlow\n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;  // Force all notes to be visible\n  \n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const vc = node.parameters?._versionControl || { version: '1.0.0', hash: null, lastModified: null, history: [] };\n  const previousHash = vc.hash;\n  const hasChanged = previousHash && previousHash !== currentHash;\n  const isNew = !previousHash;\n  let newVc = { ...vc };\n\n  if (isNew) {\n    newVc = { nodeTypeVersion: node.typeVersion, contentVersion: '1.0.0', version: '1.0.0', hash: currentHash, created: timestamp, lastModified: timestamp, history: [{ version: '1.0.0', timestamp, action: 'created', hash: currentHash }] };\n    nodeChanges.push({ nodeName: node.name, nodeId: node.id, action: 'created', version: '1.0.0', changes: [] });\n  } else if (hasChanged) {\n    const newVersion = incrementVersion(vc.version, 'patch');\n    newVc = { ...vc, nodeTypeVersion: node.typeVersion, contentVersion: newVersion, version: newVersion, hash: currentHash, lastModified: timestamp, history: [...vc.history.slice(-9), { version: newVersion, timestamp, action: 'modified', previousHash, hash: currentHash }] };\n    nodeChanges.push({ nodeName: node.name, nodeId: node.id, action: 'modified', previousVersion: vc.version, version: newVersion, changes: [] });\n  }\n\n  const updatedNode = cleanNode({ ...node, notes: buildNodeNotes(newVc, node.typeVersion), parameters: { ...node.parameters, _versionControl: newVc } });\n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version from node versions\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => n.parameters?._versionControl?.version || '1.0.0');\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings - only allowed properties, NO custom fields\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { name: workflow.name, nodes: updatedNodes, connections: workflow.connections, settings: cleanSettings };\n\nreturn { json: { config, originalWorkflow: workflow, updatedWorkflow, nodeChanges, hasChanges: nodeChanges.length > 0, workflowVersion: { previous: '1.0.0', current: wfNewVersion }, timestamp } };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2f9040f1",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2f9040f1\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnMiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "0a5b41ff-07c4-44a4-b054-68e84227eeda",
      "name": "Build Success Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1120,
        -336
      ],
      "parameters": {
        "jsCode": "const processData = $('Dry Run?1').first().json;\nconst apiResponse = $input.first().json;\nreturn { json: { success: true, message: `Workflow saved: v${processData.workflowVersion.previous} ‚Üí v${processData.workflowVersion.current}`, workflowId: processData.config.workflowId, workflowName: apiResponse.name || processData.updatedWorkflow.name, version: { previous: processData.workflowVersion.previous, current: processData.workflowVersion.current }, changes: processData.nodeChanges, timestamp: processData.timestamp, dryRun: false } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "639059f2",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 639059f2\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "3bf8ba0d-5db7-4520-9042-b6b42334c080",
      "name": "Parse Configuration2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -368,
        -1136
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\n// Configuration with defaults\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/data/workflow-backups',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl ||  'http://localhost:5678/api/v1',\n  n8nApiKey: input.n8nApiKey || input.body?.n8nApiKey || '',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null, // null = auto-generate\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nreturn { json: config };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "17dd43cd",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 17dd43cd\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uMiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "1adca495-111d-4291-88fc-b2d2415faed0",
      "name": "Fetch Current Workflow2",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -192,
        -1136
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.n8nApiKey }}"
            }
          ]
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "22aea478",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 22aea478\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzIiLCJ0eXBlVmVyc2lvbiI6NC4yLCJwYXJhbWV0ZXJLZXlzIjpbImhlYWRlclBhcmFtZXRlcnMiLCJvcHRpb25zIiwic2VuZEhlYWRlcnMiLCJ1cmwiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7ImhlYWRlclBhcmFtZXRlcnMiOnsicGFyYW1Db3VudCI6MX19fQ==",
      "notesInFlow": true
    },
    {
      "id": "9b613d1e-ca98-4153-a058-83c5fd7cc5bb",
      "name": "Has Changes?2",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        176,
        -1136
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/MiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "34a271c2-e874-4b6e-b49a-633c0ea58a97",
      "name": "No Changes Response2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        816,
        -800
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'No changes detected', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: data.workflowVersion.current, timestamp: data.timestamp } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3919f890",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3919f890\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlMiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "72932b29-0fe7-4f9d-8b67-f1a2bc411822",
      "name": "Dry Run?2",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        464,
        -1152
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj8yIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsiY29uZGl0aW9ucyIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "083744f6-55a2-4211-bda7-80e53407d8b1",
      "name": "Update Workflow with Versions2",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        688,
        -1040
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.config.n8nApiKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2b165197",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 2b165197\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnMyIiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJoZWFkZXJQYXJhbWV0ZXJzIiwianNvbkJvZHkiLCJtZXRob2QiLCJvcHRpb25zIiwic2VuZEJvZHkiLCJzZW5kSGVhZGVycyIsInNwZWNpZnlCb2R5IiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjJ9fX0=",
      "notesInFlow": true
    },
    {
      "id": "72bd6276-1087-4c52-b9f6-e3e96358991a",
      "name": "Dry Run Response2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        704,
        -1280
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'Dry run completed - no changes applied', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: { previous: data.workflowVersion.previous, wouldBecome: data.workflowVersion.current }, changes: data.nodeChanges, timestamp: data.timestamp, dryRun: true } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5226f176",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5226f176\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlMiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "ec86aea3-75c0-4660-a1b3-0617a10a5fcc",
      "name": "Respond to Webhook2",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        1488,
        -1056
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2syIiwidHlwZVZlcnNpb24iOjEuMSwicGFyYW1ldGVyS2V5cyI6WyJvcHRpb25zIiwicmVzcG9uZFdpdGgiLCJyZXNwb25zZUJvZHkiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "928c9e83-0d9e-4f89-bfe4-1dd470acbd48",
      "name": "Process Node Versions1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        16,
        -1248
      ],
      "parameters": {
        "jsCode": "const config = $('Parse Configuration2').first().json;\nconst workflow = $input.first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\n// Parse existing version info from notes field\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction hashNode(node) {\n  const nodeForHash = { ...node };\n  // Remove fields that shouldn't affect hash\n  delete nodeForHash.notes;\n  delete nodeForHash.notesInFlow;\n  delete nodeForHash.position; // Position changes shouldn't trigger version bump\n  if (nodeForHash.parameters?._versionControl) {\n    const params = { ...nodeForHash.parameters };\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  }\n  return simpleHash(JSON.stringify(nodeForHash));\n}\n\nfunction incrementVersion(version, changeType) {\n  const parts = (version || '1.0.0').split('.').map(Number);\n  if (changeType === 'major') return `${parts[0] + 1}.0.0`;\n  if (changeType === 'minor') return `${parts[0]}.${parts[1] + 1}.0`;\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleDateString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction buildNodeNotes(versionInfo, typeVer) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`  // Store hash in notes!\n  ];\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\n// Extract hash from notes\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  // ALWAYS include notes and notesInFlow\n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  \n  // Try to parse existing version from notes\n  const existingVersion = parseVersionFromNotes(node.notes);\n  const previousHash = getHashFromNotes(node.notes);\n  \n  // Determine if node is new or changed\n  const isNew = !previousHash;\n  const hasChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  let versionInfo;\n  \n  if (isNew) {\n    // New node - initialize version\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0'\n    });\n  } else if (hasChanged) {\n    // Node changed - increment version\n    const newVersion = incrementVersion(existingVersion.version, 'patch');\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion\n    });\n  } else {\n    // No change - keep existing version\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create updated node with version in notes\n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo  // Try to store (may be stripped by n8n)\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config, \n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp \n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "213f0e9a",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 213f0e9a\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnMxIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "c7a6fa5a-a645-4355-b73a-82e718c8ecb9",
      "name": "Build Success Response2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        896,
        -1040
      ],
      "parameters": {
        "jsCode": "const processData = $('Dry Run?2').first().json;\nconst apiResponse = $input.first().json;\nreturn { json: { success: true, message: `Workflow saved: v${processData.workflowVersion.previous} ‚Üí v${processData.workflowVersion.current}`, workflowId: processData.config.workflowId, workflowName: apiResponse.name || processData.updatedWorkflow.name, version: { previous: processData.workflowVersion.previous, current: processData.workflowVersion.current }, changes: processData.nodeChanges, timestamp: processData.timestamp, dryRun: false } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "f8c876f",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: f8c876f\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlMiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "356a6dfb-88e5-42ee-9837-d256a67bd719",
      "name": "Parse Configuration3",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1296,
        -2128
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\n// Configuration with defaults\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/data/workflow-backups',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl ||  'http://localhost:5678/api/v1',\n  n8nApiKey: input.n8nApiKey || input.body?.n8nApiKey || '',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null, // null = auto-generate\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nreturn { json: config };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "17dd43cd",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 17dd43cd\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uMyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "b3f3b39d-ff97-485e-ab11-56d7ca245061",
      "name": "Fetch Current Workflow3",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1120,
        -2128
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.n8nApiKey }}"
            }
          ]
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "22aea478",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 22aea478\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzMiLCJ0eXBlVmVyc2lvbiI6NC4yLCJwYXJhbWV0ZXJLZXlzIjpbImhlYWRlclBhcmFtZXRlcnMiLCJvcHRpb25zIiwic2VuZEhlYWRlcnMiLCJ1cmwiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7ImhlYWRlclBhcmFtZXRlcnMiOnsicGFyYW1Db3VudCI6MX19fQ==",
      "notesInFlow": true
    },
    {
      "id": "c9e189cd-e1ab-4649-bf9f-0a000159abdf",
      "name": "Has Changes?3",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -752,
        -2128
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/MyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "a790c801-c85d-4789-b368-8c27621cd753",
      "name": "No Changes Response3",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -112,
        -1792
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'No changes detected', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: data.workflowVersion.current, timestamp: data.timestamp } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3919f890",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3919f890\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlMyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "663c3cd1-a395-45b0-aa9b-8b8718a2329b",
      "name": "Dry Run?3",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -464,
        -2144
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj8zIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsiY29uZGl0aW9ucyIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "29c00888-b9dc-4d18-9b41-d463af71c527",
      "name": "Dry Run Response3",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -224,
        -2272
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'Dry run completed - no changes applied', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: { previous: data.workflowVersion.previous, wouldBecome: data.workflowVersion.current }, changes: data.nodeChanges, timestamp: data.timestamp, dryRun: true } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5226f176",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5226f176\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlMyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "85c9c6a3-54b2-4d2e-99b6-dc7b16692799",
      "name": "Respond to Webhook3",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        560,
        -2048
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2szIiwidHlwZVZlcnNpb24iOjEuMSwicGFyYW1ldGVyS2V5cyI6WyJvcHRpb25zIiwicmVzcG9uZFdpdGgiLCJyZXNwb25zZUJvZHkiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "7b23e204-f179-49ce-857f-77b69801abcc",
      "name": "Process Node Versions2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -912,
        -2240
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldNode, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldNode) return 'major'; // New node (though we handle this separately)\n  \n  // MAJOR: Node type changed\n  if (oldNode.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldNode.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldNode.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldNode.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Get parameters for comparison\n  const oldParams = oldNode.parameters || {};\n  const newParams = newNode.parameters || {};\n  \n  // Remove _versionControl from comparison\n  const oldParamsCopy = { ...oldParams };\n  const newParamsCopy = { ...newParams };\n  delete oldParamsCopy._versionControl;\n  delete newParamsCopy._versionControl;\n  \n  const oldKeys = Object.keys(oldParamsCopy).sort();\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // MINOR: Parameter type changed\n  for (const key of oldKeys) {\n    const oldType = typeof oldParamsCopy[key];\n    const newType = typeof newParamsCopy[key];\n    \n    if (oldType !== newType) {\n      return { type: 'minor', reason: `Parameter '${key}' type changed from ${oldType} to ${newType}` };\n    }\n    \n    // Check if structure changed (object/array structure)\n    if (oldType === 'object' && newType === 'object') {\n      const oldIsArray = Array.isArray(oldParamsCopy[key]);\n      const newIsArray = Array.isArray(newParamsCopy[key]);\n      \n      if (oldIsArray !== newIsArray) {\n        return { type: 'minor', reason: `Parameter '${key}' structure changed` };\n      }\n      \n      // Check nested keys for objects\n      if (!oldIsArray && !newIsArray && oldParamsCopy[key] && newParamsCopy[key]) {\n        const oldNestedKeys = Object.keys(oldParamsCopy[key]).sort();\n        const newNestedKeys = Object.keys(newParamsCopy[key]).sort();\n        \n        if (JSON.stringify(oldNestedKeys) !== JSON.stringify(newNestedKeys)) {\n          return { type: 'minor', reason: `Parameter '${key}' structure changed` };\n        }\n      }\n    }\n  }\n  \n  // PATCH: Values changed but structure stayed the same\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const parts = (version || '1.0.0').split('.').map(Number);\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  return {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const existingVersion = parseVersionFromNotes(node.notes);\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hasChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: { workflowId: workflow.id }, \n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1e1c109c",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 1e1c109c\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnMyIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "d2d26bed-1e36-4861-a7d9-82de35cd3b6d",
      "name": "Build Success Response3",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -32,
        -2032
      ],
      "parameters": {
        "jsCode": "// CHANGE: Get data specifically from the calculation node\n// We cannot use $input because the HTTP Request node upstream overwrote \n// the data with the API response.\nconst processData = $(\"Process Node Versions2\").first().json;\n\n// Build detailed summary - all data comes from processData\nconst summary = {\n  success: true,\n  message: processData.hasChanges \n    ? `‚úÖ Version control updated: ${processData.nodeChanges.length} node${processData.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId: processData.config?.workflowId || 'unknown',\n  workflowName: processData.updatedWorkflow?.name || processData.originalWorkflow?.name || 'Unknown',\n  hasChanges: processData.hasChanges || false,\n  nodeChanges: processData.nodeChanges || [],\n  originalWorkflow: processData.originalWorkflow,\n  updatedWorkflow: processData.updatedWorkflow,\n  workflowVersion: processData.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp: processData.timestamp || new Date().toISOString(),\n  dryRun: false\n};\n\nreturn { json: summary };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "6cf142dc",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 6cf142dc\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlMyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "d567aa83-e953-48bd-a1ef-df4c2146e41b",
      "name": "Update Workflow with Versions3",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -224,
        -2032
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.config.n8nApiKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2b165197",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 2b165197\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnMzIiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJoZWFkZXJQYXJhbWV0ZXJzIiwianNvbkJvZHkiLCJtZXRob2QiLCJvcHRpb25zIiwic2VuZEJvZHkiLCJzZW5kSGVhZGVycyIsInNwZWNpZnlCb2R5IiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjJ9fX0=",
      "notesInFlow": true
    },
    {
      "id": "71c374a0-bce4-4afe-a183-5c8d74dccaa3",
      "name": "Parse Configuration4",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1072,
        -3328
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\n// Configuration with defaults\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/data/workflow-backups',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl ||  'http://localhost:5678/api/v1',\n  n8nApiKey: input.n8nApiKey || input.body?.n8nApiKey || '',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null, // null = auto-generate\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nreturn { json: config };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "17dd43cd",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 17dd43cd\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uNCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "d30cb556-ef91-44c2-9ccb-716d4fb80b76",
      "name": "Fetch Current Workflow4",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -896,
        -3328
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.n8nApiKey }}"
            }
          ]
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "22aea478",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 22aea478\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzQiLCJ0eXBlVmVyc2lvbiI6NC4yLCJwYXJhbWV0ZXJLZXlzIjpbImhlYWRlclBhcmFtZXRlcnMiLCJvcHRpb25zIiwic2VuZEhlYWRlcnMiLCJ1cmwiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7ImhlYWRlclBhcmFtZXRlcnMiOnsicGFyYW1Db3VudCI6MX19fQ==",
      "notesInFlow": true
    },
    {
      "id": "0b08a4f0-6dea-43d0-bf62-093b93835cb5",
      "name": "Has Changes?4",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -528,
        -3328
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/NCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "3edb165c-2f9e-4f72-80f8-c706ce215943",
      "name": "No Changes Response4",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        112,
        -2992
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'No changes detected', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: data.workflowVersion.current, timestamp: data.timestamp } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3919f890",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3919f890\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlNCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "e85a3046-3393-4be9-80b4-a24b82470366",
      "name": "Dry Run?4",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -240,
        -3344
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj80IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsiY29uZGl0aW9ucyIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "8adfaab3-5961-4fcb-b718-a9c7631cceae",
      "name": "Update Workflow with Versions4",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -16,
        -3232
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.config.n8nApiKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2b165197",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 2b165197\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnM0IiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJoZWFkZXJQYXJhbWV0ZXJzIiwianNvbkJvZHkiLCJtZXRob2QiLCJvcHRpb25zIiwic2VuZEJvZHkiLCJzZW5kSGVhZGVycyIsInNwZWNpZnlCb2R5IiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjJ9fX0=",
      "notesInFlow": true
    },
    {
      "id": "5ac25a17-e3db-41ba-ab3d-6d8e8f2907a1",
      "name": "Dry Run Response4",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        -3472
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'Dry run completed - no changes applied', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: { previous: data.workflowVersion.previous, wouldBecome: data.workflowVersion.current }, changes: data.nodeChanges, timestamp: data.timestamp, dryRun: true } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5226f176",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5226f176\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlNCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "5dd6e8fc-6215-4642-8831-5c800487462b",
      "name": "Respond to Webhook4",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        784,
        -3248
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2s0IiwidHlwZVZlcnNpb24iOjEuMSwicGFyYW1ldGVyS2V5cyI6WyJvcHRpb25zIiwicmVzcG9uZFdpdGgiLCJyZXNwb25zZUJvZHkiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "308438d6-874f-49c0-a066-fec086a06170",
      "name": "Process Node Versions3",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -688,
        -3440
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\nconst config = $(\"Parse Configuration4\").first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldNode, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldNode) return 'major'; // New node (though we handle this separately)\n  \n  // MAJOR: Node type changed\n  if (oldNode.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldNode.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldNode.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldNode.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Get parameters for comparison\n  const oldParams = oldNode.parameters || {};\n  const newParams = newNode.parameters || {};\n  \n  // Remove _versionControl from comparison\n  const oldParamsCopy = { ...oldParams };\n  const newParamsCopy = { ...newParams };\n  delete oldParamsCopy._versionControl;\n  delete newParamsCopy._versionControl;\n  \n  const oldKeys = Object.keys(oldParamsCopy).sort();\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // MINOR: Parameter type changed\n  for (const key of oldKeys) {\n    const oldType = typeof oldParamsCopy[key];\n    const newType = typeof newParamsCopy[key];\n    \n    if (oldType !== newType) {\n      return { type: 'minor', reason: `Parameter '${key}' type changed from ${oldType} to ${newType}` };\n    }\n    \n    // Check if structure changed (object/array structure)\n    if (oldType === 'object' && newType === 'object') {\n      const oldIsArray = Array.isArray(oldParamsCopy[key]);\n      const newIsArray = Array.isArray(newParamsCopy[key]);\n      \n      if (oldIsArray !== newIsArray) {\n        return { type: 'minor', reason: `Parameter '${key}' structure changed` };\n      }\n      \n      // Check nested keys for objects\n      if (!oldIsArray && !newIsArray && oldParamsCopy[key] && newParamsCopy[key]) {\n        const oldNestedKeys = Object.keys(oldParamsCopy[key]).sort();\n        const newNestedKeys = Object.keys(newParamsCopy[key]).sort();\n        \n        if (JSON.stringify(oldNestedKeys) !== JSON.stringify(newNestedKeys)) {\n          return { type: 'minor', reason: `Parameter '${key}' structure changed` };\n        }\n      }\n    }\n  }\n  \n  // PATCH: Values changed but structure stayed the same\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const parts = (version || '1.0.0').split('.').map(Number);\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  return {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const existingVersion = parseVersionFromNotes(node.notes);\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hasChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: config,\n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7be923d8",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 7be923d8\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnMzIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "c7a2dc5f-d5df-4a57-b52c-77c1113990a9",
      "name": "Build Success Response4",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        192,
        -3232
      ],
      "parameters": {
        "jsCode": "// CHANGE: Get data specifically from the calculation node\n// We cannot use $input because the HTTP Request node upstream overwrote \n// the data with the API response.\nconst processData = $(\"Process Node Versions3\").first().json;\n\n// Build detailed summary - all data comes from processData\nconst summary = {\n  success: true,\n  message: processData.hasChanges \n    ? `‚úÖ Version control updated: ${processData.nodeChanges.length} node${processData.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId: processData.config?.workflowId || 'unknown',\n  workflowName: processData.updatedWorkflow?.name || processData.originalWorkflow?.name || 'Unknown',\n  hasChanges: processData.hasChanges || false,\n  nodeChanges: processData.nodeChanges || [],\n  originalWorkflow: processData.originalWorkflow,\n  updatedWorkflow: processData.updatedWorkflow,\n  workflowVersion: processData.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp: processData.timestamp || new Date().toISOString(),\n  dryRun: false\n};\n\nreturn { json: summary };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "714c09a5",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 714c09a5\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlNCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "0393a49e-042a-4a5c-8863-181db95ec446",
      "name": "Parse Configuration5",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1680,
        -4400
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\n// Configuration with defaults\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/data/workflow-backups',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl ||  'http://localhost:5678/api/v1',\n  n8nApiKey: input.n8nApiKey || input.body?.n8nApiKey || '',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null, // null = auto-generate\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nreturn { json: config };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "17dd43cd",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 17dd43cd\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uNSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "8dc9341e-1288-49aa-b1b6-694da27fb631",
      "name": "Fetch Current Workflow5",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1504,
        -4400
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.n8nApiKey }}"
            }
          ]
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "22aea478",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 22aea478\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzUiLCJ0eXBlVmVyc2lvbiI6NC4yLCJwYXJhbWV0ZXJLZXlzIjpbImhlYWRlclBhcmFtZXRlcnMiLCJvcHRpb25zIiwic2VuZEhlYWRlcnMiLCJ1cmwiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7ImhlYWRlclBhcmFtZXRlcnMiOnsicGFyYW1Db3VudCI6MX19fQ==",
      "notesInFlow": true
    },
    {
      "id": "9ee6420e-be8b-40d5-bc37-24cab8aa2779",
      "name": "Has Changes?5",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1136,
        -4400
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/NSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "fd7d9dfe-224c-42e8-9e4b-98432a301fe5",
      "name": "No Changes Response5",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -496,
        -4064
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'No changes detected', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: data.workflowVersion.current, timestamp: data.timestamp } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3919f890",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3919f890\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlNSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "71cd4d5d-2e42-4728-9c91-0e3d76c0233e",
      "name": "Dry Run?5",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -848,
        -4416
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj81IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsiY29uZGl0aW9ucyIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "a67c7622-29ab-44c5-9276-9c062d63acbc",
      "name": "Update Workflow with Versions5",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -624,
        -4304
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.config.n8nApiKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2b165197",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 2b165197\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnM1IiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJoZWFkZXJQYXJhbWV0ZXJzIiwianNvbkJvZHkiLCJtZXRob2QiLCJvcHRpb25zIiwic2VuZEJvZHkiLCJzZW5kSGVhZGVycyIsInNwZWNpZnlCb2R5IiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjJ9fX0=",
      "notesInFlow": true
    },
    {
      "id": "45209a0a-079f-46ed-993e-92bd0f23f390",
      "name": "Dry Run Response5",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -608,
        -4544
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'Dry run completed - no changes applied', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: { previous: data.workflowVersion.previous, wouldBecome: data.workflowVersion.current }, changes: data.nodeChanges, timestamp: data.timestamp, dryRun: true } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5226f176",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5226f176\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlNSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "1119fcca-99ab-4e34-92f1-a2642b81c116",
      "name": "Respond to Webhook5",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        176,
        -4320
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2s1IiwidHlwZVZlcnNpb24iOjEuMSwicGFyYW1ldGVyS2V5cyI6WyJvcHRpb25zIiwicmVzcG9uZFdpdGgiLCJyZXNwb25zZUJvZHkiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "fa390dce-97f3-4f3b-9fbf-44fd4e25c71e",
      "name": "Process Node Versions5",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1296,
        -4512
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\nconst config = $(\"Parse Configuration5\").first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldSnapshot, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldSnapshot) return { type: 'major', reason: 'New node' };\n  \n  // MAJOR: Node type changed\n  if (oldSnapshot.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldSnapshot.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldSnapshot.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldSnapshot.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Compare parameter keys (what we have in snapshot)\n  const oldKeys = (oldSnapshot.parameterKeys || []).sort();\n  const newParams = newNode.parameters || {};\n  const newParamsCopy = { ...newParams };\n  delete newParamsCopy._versionControl;\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // If keys are the same, it's a PATCH (value change)\n  // We can't detect structure changes without full parameter history\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const parts = (version || '1.0.0').split('.').map(Number);\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  return {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const existingVersion = parseVersionFromNotes(node.notes);\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hasChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: config,\n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1cdd0bb5",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 1cdd0bb5\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnM1IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "3a1a6c40-e770-44ff-8f9b-6ea00ec8970f",
      "name": "Build Success Response5",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -416,
        -4304
      ],
      "parameters": {
        "jsCode": "// CHANGE: Get data specifically from the calculation node\n// We cannot use $input because the HTTP Request node upstream overwrote \n// the data with the API response.\nconst processData = $(\"Process Node Versions5\").first().json;\n\n// Build detailed summary - all data comes from processData\nconst summary = {\n  success: true,\n  message: processData.hasChanges \n    ? `‚úÖ Version control updated: ${processData.nodeChanges.length} node${processData.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId: processData.config?.workflowId || 'unknown',\n  workflowName: processData.updatedWorkflow?.name || processData.originalWorkflow?.name || 'Unknown',\n  hasChanges: processData.hasChanges || false,\n  nodeChanges: processData.nodeChanges || [],\n  originalWorkflow: processData.originalWorkflow,\n  updatedWorkflow: processData.updatedWorkflow,\n  workflowVersion: processData.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp: processData.timestamp || new Date().toISOString(),\n  dryRun: false\n};\n\nreturn { json: summary };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2dc6a2a7",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2dc6a2a7\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlNSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "7186a7a3-29d6-4d97-9256-4d5caac68a1d",
      "name": "Parse Configuration6",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1440,
        -5456
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\n// Configuration with defaults\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/data/workflow-backups',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl ||  'http://localhost:5678/api/v1',\n  n8nApiKey: input.n8nApiKey || input.body?.n8nApiKey || '',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null, // null = auto-generate\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nreturn { json: config };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "17dd43cd",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 17dd43cd\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uNiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "c5018725-a141-4b4e-9e09-eae843092030",
      "name": "Fetch Current Workflow6",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1264,
        -5456
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.n8nApiKey }}"
            }
          ]
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "22aea478",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 22aea478\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzYiLCJ0eXBlVmVyc2lvbiI6NC4yLCJwYXJhbWV0ZXJLZXlzIjpbImhlYWRlclBhcmFtZXRlcnMiLCJvcHRpb25zIiwic2VuZEhlYWRlcnMiLCJ1cmwiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7ImhlYWRlclBhcmFtZXRlcnMiOnsicGFyYW1Db3VudCI6MX19fQ==",
      "notesInFlow": true
    },
    {
      "id": "7d9ff9ed-f281-4599-82d0-93d5d1a08dc7",
      "name": "Has Changes?6",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -896,
        -5456
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/NiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "8c5577f2-2b94-46bb-9835-b85fa2412902",
      "name": "No Changes Response6",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -256,
        -5120
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'No changes detected', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: data.workflowVersion.current, timestamp: data.timestamp } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3919f890",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3919f890\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlNiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "7f04fba0-2c41-49e5-90ce-25ff3c9fbb9d",
      "name": "Dry Run?6",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -608,
        -5472
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj82IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsiY29uZGl0aW9ucyIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "5369382a-9e56-4744-bc52-15ad2e43ae61",
      "name": "Update Workflow with Versions6",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -384,
        -5360
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.config.n8nApiKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2b165197",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 2b165197\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnM2IiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJoZWFkZXJQYXJhbWV0ZXJzIiwianNvbkJvZHkiLCJtZXRob2QiLCJvcHRpb25zIiwic2VuZEJvZHkiLCJzZW5kSGVhZGVycyIsInNwZWNpZnlCb2R5IiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjJ9fX0=",
      "notesInFlow": true
    },
    {
      "id": "fcdae7c8-8298-4986-b599-cd6a0dab4d08",
      "name": "Dry Run Response6",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -368,
        -5600
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'Dry run completed - no changes applied', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: { previous: data.workflowVersion.previous, wouldBecome: data.workflowVersion.current }, changes: data.nodeChanges, timestamp: data.timestamp, dryRun: true } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5226f176",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5226f176\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlNiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "88fce050-514f-4f29-9c4f-0f78fa874752",
      "name": "Respond to Webhook6",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        416,
        -5376
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2s2IiwidHlwZVZlcnNpb24iOjEuMSwicGFyYW1ldGVyS2V5cyI6WyJvcHRpb25zIiwicmVzcG9uZFdpdGgiLCJyZXNwb25zZUJvZHkiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "a6797617-0119-4149-ab37-da263de3228c",
      "name": "Process Node Versions6",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1056,
        -5568
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\nconst config = $(\"Parse Configuration6\").first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldSnapshot, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldSnapshot) return { type: 'major', reason: 'New node' };\n  \n  // MAJOR: Node type changed\n  if (oldSnapshot.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldSnapshot.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldSnapshot.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldSnapshot.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Compare parameter keys (what we have in snapshot)\n  const oldKeys = (oldSnapshot.parameterKeys || []).sort();\n  const newParams = newNode.parameters || {};\n  const newParamsCopy = { ...newParams };\n  delete newParamsCopy._versionControl;\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // MINOR: Check parameter structure changes (array lengths, etc.)\n  if (oldSnapshot.parameterStructure && newParams) {\n    for (const key in oldSnapshot.parameterStructure) {\n      const oldStruct = oldSnapshot.parameterStructure[key];\n      const newParam = newParams[key];\n      \n      if (!newParam) continue; // Parameter was removed (caught above)\n      \n      // Check assignment count changes\n      if (oldStruct.assignmentCount !== undefined) {\n        const newCount = newParam.assignments?.length || 0;\n        if (oldStruct.assignmentCount !== newCount) {\n          const change = newCount > oldStruct.assignmentCount ? 'Added' : 'Removed';\n          const diff = Math.abs(newCount - oldStruct.assignmentCount);\n          return { \n            type: 'minor', \n            reason: `${change} ${diff} assignment${diff > 1 ? 's' : ''} in '${key}'`\n          };\n        }\n      }\n      \n      // Check array length changes\n      if (oldStruct.arrayLength !== undefined) {\n        const newLength = Array.isArray(newParam) ? newParam.length : 0;\n        if (oldStruct.arrayLength !== newLength) {\n          return { \n            type: 'minor', \n            reason: `Array '${key}' size changed: ${oldStruct.arrayLength} ‚Üí ${newLength}`\n          };\n        }\n      }\n      \n      // Check parameter count changes (like HTTP headers)\n      if (oldStruct.paramCount !== undefined) {\n        const newCount = newParam.parameters?.length || 0;\n        if (oldStruct.paramCount !== newCount) {\n          return { \n            type: 'minor', \n            reason: `Parameter count in '${key}' changed: ${oldStruct.paramCount} ‚Üí ${newCount}`\n          };\n        }\n      }\n    }\n  }\n  \n  // If keys are the same and structure unchanged, it's a PATCH (value change)\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const parts = (version || '1.0.0').split('.').map(Number);\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  const snapshot = {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n  \n  // Store array lengths for parameters that are arrays or contain arrays\n  // This helps detect adding/removing items (MINOR change)\n  if (node.parameters) {\n    snapshot.parameterStructure = {};\n    \n    for (const key of snapshot.parameterKeys) {\n      const param = node.parameters[key];\n      \n      if (param && typeof param === 'object') {\n        // Check for common n8n patterns\n        if (param.assignments && Array.isArray(param.assignments)) {\n          // Set/Edit Fields node with assignments\n          snapshot.parameterStructure[key] = {\n            assignmentCount: param.assignments.length\n          };\n        } else if (Array.isArray(param)) {\n          // Direct array parameter\n          snapshot.parameterStructure[key] = {\n            arrayLength: param.length\n          };\n        } else if (param.parameters && Array.isArray(param.parameters)) {\n          // HTTP Request headers/parameters\n          snapshot.parameterStructure[key] = {\n            paramCount: param.parameters.length\n          };\n        }\n      }\n    }\n  }\n  \n  return snapshot;\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const existingVersion = parseVersionFromNotes(node.notes);\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hasChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: config,\n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1fc1e2df",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 1fc1e2df\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnM2IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "3ec6db74-1056-48dc-b204-f9831b1cd0fc",
      "name": "Build Success Response6",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -176,
        -5360
      ],
      "parameters": {
        "jsCode": "// CHANGE: Get data specifically from the calculation node\n// We cannot use $input because the HTTP Request node upstream overwrote \n// the data with the API response.\nconst processData = $(\"Process Node Versions6\").first().json;\n\n// Build detailed summary - all data comes from processData\nconst summary = {\n  success: true,\n  message: processData.hasChanges \n    ? `‚úÖ Version control updated: ${processData.nodeChanges.length} node${processData.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId: processData.config?.workflowId || 'unknown',\n  workflowName: processData.updatedWorkflow?.name || processData.originalWorkflow?.name || 'Unknown',\n  hasChanges: processData.hasChanges || false,\n  nodeChanges: processData.nodeChanges || [],\n  originalWorkflow: processData.originalWorkflow,\n  updatedWorkflow: processData.updatedWorkflow,\n  workflowVersion: processData.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp: processData.timestamp || new Date().toISOString(),\n  dryRun: false\n};\n\nreturn { json: summary };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "c03ef28",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: c03ef28\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlNiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "f84525f7-13fc-414c-89ce-707d38465660",
      "name": "Parse Configuration7",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1680,
        -6480
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\n// Configuration with defaults\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/data/workflow-backups',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl ||  'http://localhost:5678/api/v1',\n  n8nApiKey: input.n8nApiKey || input.body?.n8nApiKey || '',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null, // null = auto-generate\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nreturn { json: config };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "17dd43cd",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 17dd43cd\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uNyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "4bdf95b1-557f-46db-9c3b-6d1d8a504306",
      "name": "Fetch Current Workflow7",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1504,
        -6480
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.n8nApiKey }}"
            }
          ]
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "22aea478",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 22aea478\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzciLCJ0eXBlVmVyc2lvbiI6NC4yLCJwYXJhbWV0ZXJLZXlzIjpbImhlYWRlclBhcmFtZXRlcnMiLCJvcHRpb25zIiwic2VuZEhlYWRlcnMiLCJ1cmwiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7ImhlYWRlclBhcmFtZXRlcnMiOnsicGFyYW1Db3VudCI6MX19fQ==",
      "notesInFlow": true
    },
    {
      "id": "86eb8e9c-6623-4001-8563-a2c0698aa93a",
      "name": "Has Changes?7",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1136,
        -6480
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/NyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "7be5355b-0b2d-4ccf-b745-1f230f143890",
      "name": "No Changes Response7",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -496,
        -6144
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'No changes detected', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: data.workflowVersion.current, timestamp: data.timestamp } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3919f890",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3919f890\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlNyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "6fcd5432-551d-4c09-8185-c570195674b5",
      "name": "Dry Run?7",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -848,
        -6496
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj83IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsiY29uZGl0aW9ucyIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "dd4e7b31-374a-495f-a496-90f731868658",
      "name": "Update Workflow with Versions7",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -624,
        -6384
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.config.n8nApiKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2b165197",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 2b165197\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnM3IiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJoZWFkZXJQYXJhbWV0ZXJzIiwianNvbkJvZHkiLCJtZXRob2QiLCJvcHRpb25zIiwic2VuZEJvZHkiLCJzZW5kSGVhZGVycyIsInNwZWNpZnlCb2R5IiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjJ9fX0=",
      "notesInFlow": true
    },
    {
      "id": "c2690461-eb07-4de0-815d-5bea900eb49b",
      "name": "Dry Run Response7",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -608,
        -6624
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'Dry run completed - no changes applied', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: { previous: data.workflowVersion.previous, wouldBecome: data.workflowVersion.current }, changes: data.nodeChanges, timestamp: data.timestamp, dryRun: true } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5226f176",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5226f176\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlNyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "f1d1e024-375e-4d40-baf9-f75c21d1b559",
      "name": "Respond to Webhook7",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        176,
        -6400
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2s3IiwidHlwZVZlcnNpb24iOjEuMSwicGFyYW1ldGVyS2V5cyI6WyJvcHRpb25zIiwicmVzcG9uZFdpdGgiLCJyZXNwb25zZUJvZHkiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "4580942b-b350-409b-a5d6-4a4febb24862",
      "name": "Process Node Versions7",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1296,
        -6592
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\nconst config = $(\"Parse Configuration7\").first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldSnapshot, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldSnapshot) return { type: 'major', reason: 'New node' };\n  \n  // MAJOR: Node type changed\n  if (oldSnapshot.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldSnapshot.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldSnapshot.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldSnapshot.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Compare parameter keys (what we have in snapshot)\n  const oldKeys = (oldSnapshot.parameterKeys || []).sort();\n  const newParams = newNode.parameters || {};\n  const newParamsCopy = { ...newParams };\n  delete newParamsCopy._versionControl;\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // MINOR: Check parameter structure changes (array lengths, etc.)\n  if (oldSnapshot.parameterStructure && newParams) {\n    for (const key in oldSnapshot.parameterStructure) {\n      const oldStruct = oldSnapshot.parameterStructure[key];\n      const newParam = newParams[key];\n      \n      if (!newParam) continue; // Parameter was removed (caught above)\n      \n      // Check assignment count changes\n      if (oldStruct.assignmentCount !== undefined) {\n        const newCount = newParam.assignments?.length || 0;\n        if (oldStruct.assignmentCount !== newCount) {\n          const change = newCount > oldStruct.assignmentCount ? 'Added' : 'Removed';\n          const diff = Math.abs(newCount - oldStruct.assignmentCount);\n          return { \n            type: 'minor', \n            reason: `${change} ${diff} assignment${diff > 1 ? 's' : ''} in '${key}'`\n          };\n        }\n      }\n      \n      // Check array length changes\n      if (oldStruct.arrayLength !== undefined) {\n        const newLength = Array.isArray(newParam) ? newParam.length : 0;\n        if (oldStruct.arrayLength !== newLength) {\n          return { \n            type: 'minor', \n            reason: `Array '${key}' size changed: ${oldStruct.arrayLength} ‚Üí ${newLength}`\n          };\n        }\n      }\n      \n      // Check parameter count changes (like HTTP headers)\n      if (oldStruct.paramCount !== undefined) {\n        const newCount = newParam.parameters?.length || 0;\n        if (oldStruct.paramCount !== newCount) {\n          return { \n            type: 'minor', \n            reason: `Parameter count in '${key}' changed: ${oldStruct.paramCount} ‚Üí ${newCount}`\n          };\n        }\n      }\n    }\n  }\n  \n  // If keys are the same and structure unchanged, it's a PATCH (value change)\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const parts = (version || '1.0.0').split('.').map(Number);\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  const snapshot = {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n  \n  // Store array lengths for parameters that are arrays or contain arrays\n  // This helps detect adding/removing items (MINOR change)\n  if (node.parameters) {\n    snapshot.parameterStructure = {};\n    \n    for (const key of snapshot.parameterKeys) {\n      const param = node.parameters[key];\n      \n      if (param && typeof param === 'object') {\n        // Check for common n8n patterns\n        if (param.assignments && Array.isArray(param.assignments)) {\n          // Set/Edit Fields node with assignments\n          snapshot.parameterStructure[key] = {\n            assignmentCount: param.assignments.length\n          };\n        } else if (Array.isArray(param)) {\n          // Direct array parameter\n          snapshot.parameterStructure[key] = {\n            arrayLength: param.length\n          };\n        } else if (param.parameters && Array.isArray(param.parameters)) {\n          // HTTP Request headers/parameters\n          snapshot.parameterStructure[key] = {\n            paramCount: param.parameters.length\n          };\n        }\n      }\n    }\n  }\n  \n  return snapshot;\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const existingVersion = parseVersionFromNotes(node.notes);\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hashChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  // Check for name changes (MAJOR change that doesn't affect hash)\n  const nameChanged = storedSnapshot && storedSnapshot.name !== node.name;\n  \n  // Node has changed if hash OR name changed\n  const hasChanged = hashChanged || nameChanged;\n  const hasChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: config,\n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "62eafc4e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 62eafc4e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnM3IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "138b306e-c4cc-4169-a77f-811f1eaa0489",
      "name": "Build Success Response7",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -416,
        -6384
      ],
      "parameters": {
        "jsCode": "// CHANGE: Get data specifically from the calculation node\n// We cannot use $input because the HTTP Request node upstream overwrote \n// the data with the API response.\nconst processData = $(\"Process Node Versions7\").first().json;\n\n// Build detailed summary - all data comes from processData\nconst summary = {\n  success: true,\n  message: processData.hasChanges \n    ? `‚úÖ Version control updated: ${processData.nodeChanges.length} node${processData.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId: processData.config?.workflowId || 'unknown',\n  workflowName: processData.updatedWorkflow?.name || processData.originalWorkflow?.name || 'Unknown',\n  hasChanges: processData.hasChanges || false,\n  nodeChanges: processData.nodeChanges || [],\n  originalWorkflow: processData.originalWorkflow,\n  updatedWorkflow: processData.updatedWorkflow,\n  workflowVersion: processData.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp: processData.timestamp || new Date().toISOString(),\n  dryRun: false\n};\n\nreturn { json: summary };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "15bec457",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 15bec457\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlNyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "67d8689b-4ce6-42ce-b428-9570a58e7d4f",
      "name": "Parse Configuration8",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1536,
        -7440
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\n// Configuration with defaults\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/data/workflow-backups',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl ||  'http://localhost:5678/api/v1',\n  n8nApiKey: input.n8nApiKey || input.body?.n8nApiKey || '',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null, // null = auto-generate\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nreturn { json: config };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "17dd43cd",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 17dd43cd\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uOCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "13be2636-f877-4f34-81e7-59484ada8cd1",
      "name": "Fetch Current Workflow8",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1360,
        -7440
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.n8nApiKey }}"
            }
          ]
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "22aea478",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 22aea478\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzgiLCJ0eXBlVmVyc2lvbiI6NC4yLCJwYXJhbWV0ZXJLZXlzIjpbImhlYWRlclBhcmFtZXRlcnMiLCJvcHRpb25zIiwic2VuZEhlYWRlcnMiLCJ1cmwiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7ImhlYWRlclBhcmFtZXRlcnMiOnsicGFyYW1Db3VudCI6MX19fQ==",
      "notesInFlow": true
    },
    {
      "id": "da98c7e9-32a6-4b34-a25f-468dd543f6cf",
      "name": "Has Changes?8",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -992,
        -7440
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/OCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "b7e2b00c-5a52-4288-aff1-5bb11382b022",
      "name": "No Changes Response8",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -352,
        -7104
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'No changes detected', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: data.workflowVersion.current, timestamp: data.timestamp } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3919f890",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3919f890\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlOCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "281b0e83-a9cb-4264-a4f6-eb811615ba18",
      "name": "Dry Run?8",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -704,
        -7456
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj84IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsiY29uZGl0aW9ucyIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "8f1070ef-a0b3-4968-b9d3-70983cc75ca3",
      "name": "Update Workflow with Versions8",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -480,
        -7344
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.config.n8nApiKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2b165197",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 2b165197\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnM4IiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJoZWFkZXJQYXJhbWV0ZXJzIiwianNvbkJvZHkiLCJtZXRob2QiLCJvcHRpb25zIiwic2VuZEJvZHkiLCJzZW5kSGVhZGVycyIsInNwZWNpZnlCb2R5IiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjJ9fX0=",
      "notesInFlow": true
    },
    {
      "id": "e11e1f59-253f-4b18-a872-5a03761469d6",
      "name": "Dry Run Response8",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -464,
        -7584
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'Dry run completed - no changes applied', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: { previous: data.workflowVersion.previous, wouldBecome: data.workflowVersion.current }, changes: data.nodeChanges, timestamp: data.timestamp, dryRun: true } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5226f176",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5226f176\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlOCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "ab44c992-c518-422d-8102-cbf65290c82b",
      "name": "Respond to Webhook8",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        320,
        -7360
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2s4IiwidHlwZVZlcnNpb24iOjEuMSwicGFyYW1ldGVyS2V5cyI6WyJvcHRpb25zIiwicmVzcG9uZFdpdGgiLCJyZXNwb25zZUJvZHkiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "df582118-fafd-417c-bb41-fbf990de0442",
      "name": "Process Node Versions8",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1152,
        -7552
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\nconst config = $(\"Parse Configuration8\").first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldSnapshot, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldSnapshot) return { type: 'major', reason: 'New node' };\n  \n  // MAJOR: Node type changed\n  if (oldSnapshot.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldSnapshot.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldSnapshot.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldSnapshot.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Compare parameter keys (what we have in snapshot)\n  const oldKeys = (oldSnapshot.parameterKeys || []).sort();\n  const newParams = newNode.parameters || {};\n  const newParamsCopy = { ...newParams };\n  delete newParamsCopy._versionControl;\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // MINOR: Check parameter structure changes (array lengths, etc.)\n  if (oldSnapshot.parameterStructure && newParams) {\n    for (const key in oldSnapshot.parameterStructure) {\n      const oldStruct = oldSnapshot.parameterStructure[key];\n      const newParam = newParams[key];\n      \n      if (!newParam) continue; // Parameter was removed (caught above)\n      \n      // Check assignment count changes\n      if (oldStruct.assignmentCount !== undefined) {\n        const newCount = newParam.assignments?.length || 0;\n        if (oldStruct.assignmentCount !== newCount) {\n          const change = newCount > oldStruct.assignmentCount ? 'Added' : 'Removed';\n          const diff = Math.abs(newCount - oldStruct.assignmentCount);\n          return { \n            type: 'minor', \n            reason: `${change} ${diff} assignment${diff > 1 ? 's' : ''} in '${key}'`\n          };\n        }\n      }\n      \n      // Check array length changes\n      if (oldStruct.arrayLength !== undefined) {\n        const newLength = Array.isArray(newParam) ? newParam.length : 0;\n        if (oldStruct.arrayLength !== newLength) {\n          return { \n            type: 'minor', \n            reason: `Array '${key}' size changed: ${oldStruct.arrayLength} ‚Üí ${newLength}`\n          };\n        }\n      }\n      \n      // Check parameter count changes (like HTTP headers)\n      if (oldStruct.paramCount !== undefined) {\n        const newCount = newParam.parameters?.length || 0;\n        if (oldStruct.paramCount !== newCount) {\n          return { \n            type: 'minor', \n            reason: `Parameter count in '${key}' changed: ${oldStruct.paramCount} ‚Üí ${newCount}`\n          };\n        }\n      }\n    }\n  }\n  \n  // If keys are the same and structure unchanged, it's a PATCH (value change)\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const parts = (version || '1.0.0').split('.').map(Number);\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  const snapshot = {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n  \n  // Store array lengths for parameters that are arrays or contain arrays\n  // This helps detect adding/removing items (MINOR change)\n  if (node.parameters) {\n    snapshot.parameterStructure = {};\n    \n    for (const key of snapshot.parameterKeys) {\n      const param = node.parameters[key];\n      \n      if (param && typeof param === 'object') {\n        // Check for common n8n patterns\n        if (param.assignments && Array.isArray(param.assignments)) {\n          // Set/Edit Fields node with assignments\n          snapshot.parameterStructure[key] = {\n            assignmentCount: param.assignments.length\n          };\n        } else if (Array.isArray(param)) {\n          // Direct array parameter\n          snapshot.parameterStructure[key] = {\n            arrayLength: param.length\n          };\n        } else if (param.parameters && Array.isArray(param.parameters)) {\n          // HTTP Request headers/parameters\n          snapshot.parameterStructure[key] = {\n            paramCount: param.parameters.length\n          };\n        }\n      }\n    }\n  }\n  \n  return snapshot;\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const existingVersion = parseVersionFromNotes(node.notes);\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hashChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  // Check for name changes (MAJOR change that doesn't affect hash)\n  const nameChanged = storedSnapshot && storedSnapshot.name !== node.name;\n  \n  // Node has changed if hash OR name changed\n  const hasChanged = hashChanged || nameChanged;\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: config,\n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7f8a4a44",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 7f8a4a44\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnM4IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "173f07d7-e1fb-477f-899c-755a9be61c85",
      "name": "Build Success Response8",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -272,
        -7344
      ],
      "parameters": {
        "jsCode": "// CHANGE: Get data specifically from the calculation node\n// We cannot use $input because the HTTP Request node upstream overwrote \n// the data with the API response.\nconst processData = $(\"Process Node Versions8\").first().json;\n\n// Build detailed summary - all data comes from processData\nconst summary = {\n  success: true,\n  message: processData.hasChanges \n    ? `‚úÖ Version control updated: ${processData.nodeChanges.length} node${processData.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId: processData.config?.workflowId || 'unknown',\n  workflowName: processData.updatedWorkflow?.name || processData.originalWorkflow?.name || 'Unknown',\n  hasChanges: processData.hasChanges || false,\n  nodeChanges: processData.nodeChanges || [],\n  originalWorkflow: processData.originalWorkflow,\n  updatedWorkflow: processData.updatedWorkflow,\n  workflowVersion: processData.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp: processData.timestamp || new Date().toISOString(),\n  dryRun: false\n};\n\nreturn { json: summary };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "378177d6",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 378177d6\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlOCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "9522ee00-e577-40d5-998c-b4906d507abb",
      "name": "Local Backup Enabled?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        16,
        -8304
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "local-backup-enabled",
              "leftValue": "={{ $json.config.localBackupEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "277dced1",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 277dced1\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiTG9jYWwgQmFja3VwIEVuYWJsZWQ/IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsiY29uZGl0aW9ucyIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "7b02ee23-b222-4e1d-b0bf-17d635c19390",
      "name": "Save Local Backup",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        240,
        -8464
      ],
      "parameters": {
        "jsCode": "// Save Local Backup Node - with home directory expansion\n\nconst data = $input.first().json;\nconst workflow = data.updatedWorkflow;\nconst version = data.workflowVersion.current;\nconst config = data.config;\n\nconst fs = require('fs');\nconst path = require('path');\nconst os = require('os');\n\n// Expand ~ to home directory\nlet backupPath = config.localBackupPath;\nif (backupPath.startsWith('~/')) {\n  backupPath = path.join(os.homedir(), backupPath.slice(2));\n} else if (backupPath === '~') {\n  backupPath = os.homedir();\n}\n\n// Sanitize workflow name\nconst safeName = workflow.name\n  .replace(/\\s+/g, '_')\n  .replace(/[^a-zA-Z0-9_-]/g, '')\n  .substring(0, 50);\n\n// Generate human-readable timestamp\nconst now = new Date();\nconst year = now.getFullYear();\nconst month = String(now.getMonth() + 1).padStart(2, '0');\nconst day = String(now.getDate()).padStart(2, '0');\nconst hours = String(now.getHours()).padStart(2, '0');\nconst minutes = String(now.getMinutes()).padStart(2, '0');\nconst seconds = String(now.getSeconds()).padStart(2, '0');\n\nconst timestamp = `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;\n\n// Generate filename: workflow-v1.0.0-2026-02-07-06-39-00.json\nconst filename = `${safeName}-v${version}-${timestamp}.json`;\nconst filepath = path.join(backupPath, filename);\n\ntry {\n  // Ensure directory exists\n  if (!fs.existsSync(backupPath)) {\n    fs.mkdirSync(backupPath, { recursive: true });\n  }\n\n  // Save workflow\n  fs.writeFileSync(filepath, JSON.stringify(workflow, null, 2));\n\n  return {\n    json: {\n      ...data,\n      backupSaved: true,\n      backupFilename: filename,\n      backupPath: filepath,\n      backupTimestamp: now.toISOString()\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...data,\n      backupSaved: false,\n      backupError: error.message\n    }\n  };\n}\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7f04f408",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 7f04f408\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJTYXZlIExvY2FsIEJhY2t1cCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "2926f102-a462-4a80-93b1-e2f0b6773a82",
      "name": "Cleanup Old Versions",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        464,
        -8464
      ],
      "parameters": {
        "jsCode": "// Cleanup Old Versions Node - with home directory expansion\n\nconst data = $input.first().json;\nconst config = data.config;\n\nconst fs = require('fs');\nconst path = require('path');\nconst os = require('os');\n\n// Skip if unlimited\nif (config.localBackupMaxVersions === -1) {\n  return { \n    json: {\n      ...data,\n      cleanupPerformed: false,\n      reason: 'Unlimited versions enabled'\n    }\n  };\n}\n\ntry {\n  // Expand ~ to home directory\n  let backupPath = config.localBackupPath;\n  if (backupPath.startsWith('~/')) {\n    backupPath = path.join(os.homedir(), backupPath.slice(2));\n  } else if (backupPath === '~') {\n    backupPath = os.homedir();\n  }\n\n  // Sanitize workflow name to match saved files\n  const safeName = data.updatedWorkflow.name\n    .replace(/\\s+/g, '_')\n    .replace(/[^a-zA-Z0-9_-]/g, '')\n    .substring(0, 50);\n\n  // Find all backups for this workflow\n  const pattern = new RegExp(`^${safeName}-v.*-.*\\\\.json$`);\n  const allFiles = fs.readdirSync(backupPath);\n  const workflowFiles = allFiles\n    .filter(f => pattern.test(f))\n    .map(f => ({\n      name: f,\n      path: path.join(backupPath, f)\n    }));\n\n  // Sort by filename (chronologically - timestamp is sortable)\n  workflowFiles.sort((a, b) => a.name.localeCompare(b.name));\n\n  // Delete oldest if over limit\n  if (workflowFiles.length > config.localBackupMaxVersions) {\n    const toDelete = workflowFiles.slice(\n      0, \n      workflowFiles.length - config.localBackupMaxVersions\n    );\n    \n    const deletedFiles = [];\n    toDelete.forEach(file => {\n      fs.unlinkSync(file.path);\n      deletedFiles.push(file.name);\n    });\n    \n    return {\n      json: {\n        ...data,\n        cleanupPerformed: true,\n        deletedBackups: deletedFiles.length,\n        deletedFiles: deletedFiles,\n        remainingBackups: config.localBackupMaxVersions\n      }\n    };\n  }\n\n  return { \n    json: {\n      ...data,\n      cleanupPerformed: false,\n      reason: `Only ${workflowFiles.length} backups (limit: ${config.localBackupMaxVersions})`\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...data,\n      cleanupPerformed: false,\n      cleanupError: error.message\n    }\n  };\n}\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5bb70dc0",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5bb70dc0\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDbGVhbnVwIE9sZCBWZXJzaW9ucyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "67a891e1-9675-4b91-9301-7e8014cf7e6a",
      "name": "Parse Configuration9",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1248,
        -8400
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\n// Configuration with defaults\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/data/workflow-backups',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl ||  'http://localhost:5678/api/v1',\n  n8nApiKey: input.n8nApiKey || input.body?.n8nApiKey || '',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null, // null = auto-generate\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nreturn { json: config };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "17dd43cd",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 17dd43cd\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uOSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "5ca89ca4-5412-47a6-88da-ef00599411dd",
      "name": "Fetch Current Workflow9",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1072,
        -8400
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.n8nApiKey }}"
            }
          ]
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "22aea478",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 22aea478\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzkiLCJ0eXBlVmVyc2lvbiI6NC4yLCJwYXJhbWV0ZXJLZXlzIjpbImhlYWRlclBhcmFtZXRlcnMiLCJvcHRpb25zIiwic2VuZEhlYWRlcnMiLCJ1cmwiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7ImhlYWRlclBhcmFtZXRlcnMiOnsicGFyYW1Db3VudCI6MX19fQ==",
      "notesInFlow": true
    },
    {
      "id": "ef8eafe6-8fca-4f91-9396-f6ca9c1ed88a",
      "name": "Has Changes?9",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -704,
        -8400
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/OSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "55941256-9991-4df8-bb4d-3685a47b9c0b",
      "name": "No Changes Response9",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -64,
        -8064
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'No changes detected', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: data.workflowVersion.current, timestamp: data.timestamp } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3919f890",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3919f890\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlOSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "f38ceeab-b915-41a3-98b3-15399c0161a6",
      "name": "Dry Run?9",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -416,
        -8416
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj85IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsiY29uZGl0aW9ucyIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "4756fb06-c8bf-42df-abc7-5da10d62af18",
      "name": "Update Workflow with Versions9",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -192,
        -8304
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.config.n8nApiKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2b165197",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 2b165197\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnM5IiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJoZWFkZXJQYXJhbWV0ZXJzIiwianNvbkJvZHkiLCJtZXRob2QiLCJvcHRpb25zIiwic2VuZEJvZHkiLCJzZW5kSGVhZGVycyIsInNwZWNpZnlCb2R5IiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjJ9fX0=",
      "notesInFlow": true
    },
    {
      "id": "2bd08b8b-6b9a-4ccd-8de2-dd137038aa27",
      "name": "Dry Run Response9",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -176,
        -8544
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'Dry run completed - no changes applied', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: { previous: data.workflowVersion.previous, wouldBecome: data.workflowVersion.current }, changes: data.nodeChanges, timestamp: data.timestamp, dryRun: true } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5226f176",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5226f176\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlOSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "94005a8b-c519-49d3-8fd2-7fa5283755f3",
      "name": "Respond to Webhook9",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        608,
        -8320
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2s5IiwidHlwZVZlcnNpb24iOjEuMSwicGFyYW1ldGVyS2V5cyI6WyJvcHRpb25zIiwicmVzcG9uZFdpdGgiLCJyZXNwb25zZUJvZHkiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "575b33e1-28b4-4471-b65b-3ac9d7a4ff98",
      "name": "Process Node Versions9",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -864,
        -8512
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\nconst config = $(\"Parse Configuration9\").first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldSnapshot, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldSnapshot) return { type: 'major', reason: 'New node' };\n  \n  // MAJOR: Node type changed\n  if (oldSnapshot.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldSnapshot.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldSnapshot.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldSnapshot.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Compare parameter keys (what we have in snapshot)\n  const oldKeys = (oldSnapshot.parameterKeys || []).sort();\n  const newParams = newNode.parameters || {};\n  const newParamsCopy = { ...newParams };\n  delete newParamsCopy._versionControl;\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // MINOR: Check parameter structure changes (array lengths, etc.)\n  if (oldSnapshot.parameterStructure && newParams) {\n    for (const key in oldSnapshot.parameterStructure) {\n      const oldStruct = oldSnapshot.parameterStructure[key];\n      const newParam = newParams[key];\n      \n      if (!newParam) continue; // Parameter was removed (caught above)\n      \n      // Check assignment count changes\n      if (oldStruct.assignmentCount !== undefined) {\n        const newCount = newParam.assignments?.length || 0;\n        if (oldStruct.assignmentCount !== newCount) {\n          const change = newCount > oldStruct.assignmentCount ? 'Added' : 'Removed';\n          const diff = Math.abs(newCount - oldStruct.assignmentCount);\n          return { \n            type: 'minor', \n            reason: `${change} ${diff} assignment${diff > 1 ? 's' : ''} in '${key}'`\n          };\n        }\n      }\n      \n      // Check array length changes\n      if (oldStruct.arrayLength !== undefined) {\n        const newLength = Array.isArray(newParam) ? newParam.length : 0;\n        if (oldStruct.arrayLength !== newLength) {\n          return { \n            type: 'minor', \n            reason: `Array '${key}' size changed: ${oldStruct.arrayLength} ‚Üí ${newLength}`\n          };\n        }\n      }\n      \n      // Check parameter count changes (like HTTP headers)\n      if (oldStruct.paramCount !== undefined) {\n        const newCount = newParam.parameters?.length || 0;\n        if (oldStruct.paramCount !== newCount) {\n          return { \n            type: 'minor', \n            reason: `Parameter count in '${key}' changed: ${oldStruct.paramCount} ‚Üí ${newCount}`\n          };\n        }\n      }\n    }\n  }\n  \n  // If keys are the same and structure unchanged, it's a PATCH (value change)\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const parts = (version || '1.0.0').split('.').map(Number);\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  const snapshot = {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n  \n  // Store array lengths for parameters that are arrays or contain arrays\n  // This helps detect adding/removing items (MINOR change)\n  if (node.parameters) {\n    snapshot.parameterStructure = {};\n    \n    for (const key of snapshot.parameterKeys) {\n      const param = node.parameters[key];\n      \n      if (param && typeof param === 'object') {\n        // Check for common n8n patterns\n        if (param.assignments && Array.isArray(param.assignments)) {\n          // Set/Edit Fields node with assignments\n          snapshot.parameterStructure[key] = {\n            assignmentCount: param.assignments.length\n          };\n        } else if (Array.isArray(param)) {\n          // Direct array parameter\n          snapshot.parameterStructure[key] = {\n            arrayLength: param.length\n          };\n        } else if (param.parameters && Array.isArray(param.parameters)) {\n          // HTTP Request headers/parameters\n          snapshot.parameterStructure[key] = {\n            paramCount: param.parameters.length\n          };\n        }\n      }\n    }\n  }\n  \n  return snapshot;\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const existingVersion = parseVersionFromNotes(node.notes);\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hashChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  // Check for name changes (MAJOR change that doesn't affect hash)\n  const nameChanged = storedSnapshot && storedSnapshot.name !== node.name;\n  \n  // Node has changed if hash OR name changed\n  const hasChanged = hashChanged || nameChanged;\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: config,\n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7f5c9edd",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 7f5c9edd\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnM5IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "17c92a53-1639-4607-9fd8-9789d48a0a99",
      "name": "Build Success Response9",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        16,
        -8304
      ],
      "parameters": {
        "jsCode": "// CHANGE: Get data specifically from the calculation node\n// We cannot use $input because the HTTP Request node upstream overwrote \n// the data with the API response.\nconst processData = $(\"Process Node Versions9\").first().json;\n\n// Build detailed summary - all data comes from processData\nconst summary = {\n  success: true,\n  message: processData.hasChanges \n    ? `‚úÖ Version control updated: ${processData.nodeChanges.length} node${processData.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId: processData.config?.workflowId || 'unknown',\n  workflowName: processData.updatedWorkflow?.name || processData.originalWorkflow?.name || 'Unknown',\n  hasChanges: processData.hasChanges || false,\n  nodeChanges: processData.nodeChanges || [],\n  originalWorkflow: processData.originalWorkflow,\n  updatedWorkflow: processData.updatedWorkflow,\n  workflowVersion: processData.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp: processData.timestamp || new Date().toISOString(),\n  dryRun: false\n};\n\n// Add backup info if available\n  if (processData.backupSaved !== undefined) {\n    summary.backup = {\n      saved: processData.backupSaved,\n      filename: processData.backupFilename || null,\n      path: processData.backupPath || null,\n      error: processData.backupError || null,\n      cleanup: {\n        performed: processData.cleanupPerformed || false,\n        deleted: processData.deletedBackups || 0,\n        files: processData.deletedFiles || []\n      }\n    };\n  }\n\nreturn { json: summary };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "28332ca0",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 28332ca0\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlOSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "fedef09b-cd72-4e83-baf3-9c54033c2645",
      "name": "Restore Data After Update",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1136,
        -9360
      ],
      "parameters": {
        "jsCode": "// Restore Data After HTTP Request\n\n// Get the original data from Process Node Versions\nconst processData = $(\"Process Node Versions10\").first().json;\n\n// Get the HTTP response (current input)\nconst httpResponse = $input.first().json;\n\n// Merge them - keep all original data, add HTTP response\nreturn {\n  json: {\n    ...processData,\n    httpResponse: httpResponse,\n    workflowUpdated: true\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "30d63fa7",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 30d63fa7\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJSZXN0b3JlIERhdGEgQWZ0ZXIgVXBkYXRlIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "8583ba84-a811-42cb-81af-785f31d45d07",
      "name": "Parse Configuration10",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2464,
        -9456
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\n// Configuration with defaults\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/data/workflow-backups',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl ||  'http://localhost:5678/api/v1',\n  n8nApiKey: input.n8nApiKey || input.body?.n8nApiKey || '',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null, // null = auto-generate\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nreturn { json: config };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "17dd43cd",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 17dd43cd\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uMTAiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "595018a8-4034-4ed4-98ba-0c44360d3670",
      "name": "Fetch Current Workflow10",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -2288,
        -9456
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.n8nApiKey }}"
            }
          ]
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "22aea478",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 22aea478\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzEwIiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJoZWFkZXJQYXJhbWV0ZXJzIiwib3B0aW9ucyIsInNlbmRIZWFkZXJzIiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjF9fX0=",
      "notesInFlow": true
    },
    {
      "id": "552a3dfe-a321-43a9-a160-fac0b53bb1d9",
      "name": "Has Changes?10",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1920,
        -9456
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/MTAiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "aff23a15-8123-4852-8c90-66e79afe3e60",
      "name": "No Changes Response10",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1280,
        -9120
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'No changes detected', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: data.workflowVersion.current, timestamp: data.timestamp } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3919f890",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3919f890\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlMTAiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "f502fddf-7f93-450d-80bb-5eb3290436bd",
      "name": "Dry Run?10",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1632,
        -9472
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj8xMCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "4238ce3c-4016-4d9b-9d7d-d2fbd02a698e",
      "name": "Update Workflow with Versions10",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1408,
        -9360
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.config.n8nApiKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2b165197",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 2b165197\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnMxMCIsInR5cGVWZXJzaW9uIjo0LjIsInBhcmFtZXRlcktleXMiOlsiaGVhZGVyUGFyYW1ldGVycyIsImpzb25Cb2R5IiwibWV0aG9kIiwib3B0aW9ucyIsInNlbmRCb2R5Iiwic2VuZEhlYWRlcnMiLCJzcGVjaWZ5Qm9keSIsInVybCJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnsiaGVhZGVyUGFyYW1ldGVycyI6eyJwYXJhbUNvdW50IjoyfX19",
      "notesInFlow": true
    },
    {
      "id": "bd650ba0-c927-4d66-a5b0-ffbc074e6dd5",
      "name": "Dry Run Response10",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1392,
        -9600
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'Dry run completed - no changes applied', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: { previous: data.workflowVersion.previous, wouldBecome: data.workflowVersion.current }, changes: data.nodeChanges, timestamp: data.timestamp, dryRun: true } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5226f176",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5226f176\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlMTAiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "2d679f1e-2c66-4fc4-96dd-236d0e89e9c5",
      "name": "Respond to Webhook10",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        -608,
        -9776
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2sxMCIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsib3B0aW9ucyIsInJlc3BvbmRXaXRoIiwicmVzcG9uc2VCb2R5Il0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "046ee33b-8379-42ff-a826-e56e3c9a7185",
      "name": "Process Node Versions10",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2080,
        -9568
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\nconst config = $(\"Parse Configuration10\").first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldSnapshot, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldSnapshot) return { type: 'major', reason: 'New node' };\n  \n  // MAJOR: Node type changed\n  if (oldSnapshot.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldSnapshot.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldSnapshot.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldSnapshot.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Compare parameter keys (what we have in snapshot)\n  const oldKeys = (oldSnapshot.parameterKeys || []).sort();\n  const newParams = newNode.parameters || {};\n  const newParamsCopy = { ...newParams };\n  delete newParamsCopy._versionControl;\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // MINOR: Check parameter structure changes (array lengths, etc.)\n  if (oldSnapshot.parameterStructure && newParams) {\n    for (const key in oldSnapshot.parameterStructure) {\n      const oldStruct = oldSnapshot.parameterStructure[key];\n      const newParam = newParams[key];\n      \n      if (!newParam) continue; // Parameter was removed (caught above)\n      \n      // Check assignment count changes\n      if (oldStruct.assignmentCount !== undefined) {\n        const newCount = newParam.assignments?.length || 0;\n        if (oldStruct.assignmentCount !== newCount) {\n          const change = newCount > oldStruct.assignmentCount ? 'Added' : 'Removed';\n          const diff = Math.abs(newCount - oldStruct.assignmentCount);\n          return { \n            type: 'minor', \n            reason: `${change} ${diff} assignment${diff > 1 ? 's' : ''} in '${key}'`\n          };\n        }\n      }\n      \n      // Check array length changes\n      if (oldStruct.arrayLength !== undefined) {\n        const newLength = Array.isArray(newParam) ? newParam.length : 0;\n        if (oldStruct.arrayLength !== newLength) {\n          return { \n            type: 'minor', \n            reason: `Array '${key}' size changed: ${oldStruct.arrayLength} ‚Üí ${newLength}`\n          };\n        }\n      }\n      \n      // Check parameter count changes (like HTTP headers)\n      if (oldStruct.paramCount !== undefined) {\n        const newCount = newParam.parameters?.length || 0;\n        if (oldStruct.paramCount !== newCount) {\n          return { \n            type: 'minor', \n            reason: `Parameter count in '${key}' changed: ${oldStruct.paramCount} ‚Üí ${newCount}`\n          };\n        }\n      }\n    }\n  }\n  \n  // If keys are the same and structure unchanged, it's a PATCH (value change)\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const parts = (version || '1.0.0').split('.').map(Number);\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  const snapshot = {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n  \n  // Store array lengths for parameters that are arrays or contain arrays\n  // This helps detect adding/removing items (MINOR change)\n  if (node.parameters) {\n    snapshot.parameterStructure = {};\n    \n    for (const key of snapshot.parameterKeys) {\n      const param = node.parameters[key];\n      \n      if (param && typeof param === 'object') {\n        // Check for common n8n patterns\n        if (param.assignments && Array.isArray(param.assignments)) {\n          // Set/Edit Fields node with assignments\n          snapshot.parameterStructure[key] = {\n            assignmentCount: param.assignments.length\n          };\n        } else if (Array.isArray(param)) {\n          // Direct array parameter\n          snapshot.parameterStructure[key] = {\n            arrayLength: param.length\n          };\n        } else if (param.parameters && Array.isArray(param.parameters)) {\n          // HTTP Request headers/parameters\n          snapshot.parameterStructure[key] = {\n            paramCount: param.parameters.length\n          };\n        }\n      }\n    }\n  }\n  \n  return snapshot;\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const existingVersion = parseVersionFromNotes(node.notes);\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hashChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  // Check for name changes (MAJOR change that doesn't affect hash)\n  const nameChanged = storedSnapshot && storedSnapshot.name !== node.name;\n  \n  // Node has changed if hash OR name changed\n  const hasChanged = hashChanged || nameChanged;\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: config,\n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2cf10e3b",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2cf10e3b\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnMxMCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "7a7cd745-68bb-4735-8df5-1dd418d0af66",
      "name": "Build Success Response10",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -608,
        -9152
      ],
      "parameters": {
        "jsCode": "// CHANGE: Get data specifically from the calculation node\n// We cannot use $input because the HTTP Request node upstream overwrote \n// the data with the API response.\nconst processData = $(\"Process Node Versions10\").first().json;\n\n// Build detailed summary - all data comes from processData\nconst summary = {\n  success: true,\n  message: processData.hasChanges \n    ? `‚úÖ Version control updated: ${processData.nodeChanges.length} node${processData.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId: processData.config?.workflowId || 'unknown',\n  workflowName: processData.updatedWorkflow?.name || processData.originalWorkflow?.name || 'Unknown',\n  hasChanges: processData.hasChanges || false,\n  nodeChanges: processData.nodeChanges || [],\n  originalWorkflow: processData.originalWorkflow,\n  updatedWorkflow: processData.updatedWorkflow,\n  workflowVersion: processData.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp: processData.timestamp || new Date().toISOString(),\n  dryRun: false\n};\n\n// Add backup info if available\n  if (processData.backupSaved !== undefined) {\n    summary.backup = {\n      saved: processData.backupSaved,\n      filename: processData.backupFilename || null,\n      path: processData.backupPath || null,\n      error: processData.backupError || null,\n      cleanup: {\n        performed: processData.cleanupPerformed || false,\n        deleted: processData.deletedBackups || 0,\n        files: processData.deletedFiles || []\n      }\n    };\n  }\n\nreturn { json: summary };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1abe2008",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 1abe2008\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlMTAiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "94a137ac-19bd-404a-bee3-2db75fd9fcc7",
      "name": "Local Backup Enabled?1",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -832,
        -9168
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "local-backup-enabled",
              "leftValue": "={{ $json.config.localBackupPath }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            },
            {
              "id": "eac3d6bd-e51c-43ba-92f4-e9c8455506cb",
              "leftValue": "={{ $json.updatedWorkflow.nodes[4].parameters.assignments.assignments[6].name }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            },
            {
              "id": "5fc1adc0-cb2c-4428-a91c-362d0bf749f5",
              "leftValue": "={{ $json.config.local }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "18e32b7d",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 18e32b7d\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiTG9jYWwgQmFja3VwIEVuYWJsZWQ/MSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "90d1b5db-15cc-4dd4-ba8f-b2118fb16218",
      "name": "Save Local Backup1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -992,
        -8784
      ],
      "parameters": {
        "jsCode": "// Save Local Backup Node - with home directory expansion\n\nconst data = $input.first().json;\nconst workflow = data.updatedWorkflow;\nconst version = data.workflowVersion.current;\nconst config = data.config;\n\nconst fs = require('fs');\nconst path = require('path');\nconst os = require('os');\n\n// Expand ~ to home directory\nlet backupPath = config.localBackupPath;\nif (backupPath.startsWith('~/')) {\n  backupPath = path.join(os.homedir(), backupPath.slice(2));\n} else if (backupPath === '~') {\n  backupPath = os.homedir();\n}\n\n// Sanitize workflow name\nconst safeName = workflow.name\n  .replace(/\\s+/g, '_')\n  .replace(/[^a-zA-Z0-9_-]/g, '')\n  .substring(0, 50);\n\n// Generate human-readable timestamp\nconst now = new Date();\nconst year = now.getFullYear();\nconst month = String(now.getMonth() + 1).padStart(2, '0');\nconst day = String(now.getDate()).padStart(2, '0');\nconst hours = String(now.getHours()).padStart(2, '0');\nconst minutes = String(now.getMinutes()).padStart(2, '0');\nconst seconds = String(now.getSeconds()).padStart(2, '0');\n\nconst timestamp = `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;\n\n// Generate filename: workflow-v1.0.0-2026-02-07-06-39-00.json\nconst filename = `${safeName}-v${version}-${timestamp}.json`;\nconst filepath = path.join(backupPath, filename);\n\ntry {\n  // Ensure directory exists\n  if (!fs.existsSync(backupPath)) {\n    fs.mkdirSync(backupPath, { recursive: true });\n  }\n\n  // Save workflow\n  fs.writeFileSync(filepath, JSON.stringify(workflow, null, 2));\n\n  return {\n    json: {\n      ...data,\n      backupSaved: true,\n      backupFilename: filename,\n      backupPath: filepath,\n      backupTimestamp: now.toISOString()\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...data,\n      backupSaved: false,\n      backupError: error.message\n    }\n  };\n}\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7f04f408",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 7f04f408\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJTYXZlIExvY2FsIEJhY2t1cDEiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "ecaf1021-556c-41a6-aee8-88e7b5e408f6",
      "name": "Cleanup Old Versions1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -736,
        -8784
      ],
      "parameters": {
        "jsCode": "// Cleanup Old Versions Node - with home directory expansion\n\nconst data = $input.first().json;\nconst config = data.config;\n\nconst fs = require('fs');\nconst path = require('path');\nconst os = require('os');\n\n// Skip if unlimited\nif (config.localBackupMaxVersions === -1) {\n  return { \n    json: {\n      ...data,\n      cleanupPerformed: false,\n      reason: 'Unlimited versions enabled'\n    }\n  };\n}\n\ntry {\n  // Expand ~ to home directory\n  let backupPath = config.localBackupPath;\n  if (backupPath.startsWith('~/')) {\n    backupPath = path.join(os.homedir(), backupPath.slice(2));\n  } else if (backupPath === '~') {\n    backupPath = os.homedir();\n  }\n\n  // Sanitize workflow name to match saved files\n  const safeName = data.updatedWorkflow.name\n    .replace(/\\s+/g, '_')\n    .replace(/[^a-zA-Z0-9_-]/g, '')\n    .substring(0, 50);\n\n  // Find all backups for this workflow\n  const pattern = new RegExp(`^${safeName}-v.*-.*\\\\.json$`);\n  const allFiles = fs.readdirSync(backupPath);\n  const workflowFiles = allFiles\n    .filter(f => pattern.test(f))\n    .map(f => ({\n      name: f,\n      path: path.join(backupPath, f)\n    }));\n\n  // Sort by filename (chronologically - timestamp is sortable)\n  workflowFiles.sort((a, b) => a.name.localeCompare(b.name));\n\n  // Delete oldest if over limit\n  if (workflowFiles.length > config.localBackupMaxVersions) {\n    const toDelete = workflowFiles.slice(\n      0, \n      workflowFiles.length - config.localBackupMaxVersions\n    );\n    \n    const deletedFiles = [];\n    toDelete.forEach(file => {\n      fs.unlinkSync(file.path);\n      deletedFiles.push(file.name);\n    });\n    \n    return {\n      json: {\n        ...data,\n        cleanupPerformed: true,\n        deletedBackups: deletedFiles.length,\n        deletedFiles: deletedFiles,\n        remainingBackups: config.localBackupMaxVersions\n      }\n    };\n  }\n\n  return { \n    json: {\n      ...data,\n      cleanupPerformed: false,\n      reason: `Only ${workflowFiles.length} backups (limit: ${config.localBackupMaxVersions})`\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...data,\n      cleanupPerformed: false,\n      cleanupError: error.message\n    }\n  };\n}\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5bb70dc0",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5bb70dc0\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDbGVhbnVwIE9sZCBWZXJzaW9uczEiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "a639f88d-b84d-4fb6-a781-063503e192a8",
      "name": "Parse Configuration11",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1824,
        -10464
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\n// Configuration with defaults\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/data/workflow-backups',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupEnabled: input.localBackupEnabled ?? input.body?.localBackupEnabled ?? false,\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  localBackupMaxVersions: input.localBackupMaxVersions ?? input.body?.localBackupMaxVersions ?? 20,\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl ||  'http://localhost:5678/api/v1',\n  n8nApiKey: input.n8nApiKey || input.body?.n8nApiKey || '',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null, // null = auto-generate\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nreturn { json: config };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "41d6c534",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 41d6c534\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uMTEiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "f927d822-e381-4626-86b3-f10ac2ddbd1d",
      "name": "Fetch Current Workflow11",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1616,
        -10464
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.n8nApiKey }}"
            }
          ]
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "22aea478",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 22aea478\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzExIiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJoZWFkZXJQYXJhbWV0ZXJzIiwib3B0aW9ucyIsInNlbmRIZWFkZXJzIiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjF9fX0=",
      "notesInFlow": true
    },
    {
      "id": "46f3e874-a487-4eb2-b147-49a738db5d3b",
      "name": "Has Changes?11",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1248,
        -10464
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/MTEiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "4be185d2-a012-4149-9ca4-a79063e7aaf8",
      "name": "No Changes Response11",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1024,
        -10096
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'No changes detected', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: data.workflowVersion.current, timestamp: data.timestamp } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3919f890",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3919f890\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlMTEiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "5fd08b57-c3cc-4ea8-98d8-8a38c4b04cbb",
      "name": "Dry Run?11",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -960,
        -10480
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj8xMSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "3dbd9dfc-cddf-4b8b-9c56-5916efa57cf1",
      "name": "Update Workflow with Versions11",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -832,
        -10368
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.config.n8nApiKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2b165197",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 2b165197\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnMxMSIsInR5cGVWZXJzaW9uIjo0LjIsInBhcmFtZXRlcktleXMiOlsiaGVhZGVyUGFyYW1ldGVycyIsImpzb25Cb2R5IiwibWV0aG9kIiwib3B0aW9ucyIsInNlbmRCb2R5Iiwic2VuZEhlYWRlcnMiLCJzcGVjaWZ5Qm9keSIsInVybCJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnsiaGVhZGVyUGFyYW1ldGVycyI6eyJwYXJhbUNvdW50IjoyfX19",
      "notesInFlow": true
    },
    {
      "id": "1f353ccd-d892-4984-a35f-5c7af814238f",
      "name": "Dry Run Response11",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -304,
        -10992
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'Dry run completed - no changes applied', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: { previous: data.workflowVersion.previous, wouldBecome: data.workflowVersion.current }, changes: data.nodeChanges, timestamp: data.timestamp, dryRun: true } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5226f176",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5226f176\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlMTEiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "6c39cd56-56b4-494e-aef3-2f8147b3be1c",
      "name": "Respond to Webhook11",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        64,
        -10384
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2sxMSIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsib3B0aW9ucyIsInJlc3BvbmRXaXRoIiwicmVzcG9uc2VCb2R5Il0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "2d0dec6e-9c4c-456e-a707-d9c5207b2c34",
      "name": "Process Node Versions11",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1408,
        -10576
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\nconst config = $(\"Parse Configuration11\").first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldSnapshot, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldSnapshot) return { type: 'major', reason: 'New node' };\n  \n  // MAJOR: Node type changed\n  if (oldSnapshot.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldSnapshot.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldSnapshot.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldSnapshot.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Compare parameter keys (what we have in snapshot)\n  const oldKeys = (oldSnapshot.parameterKeys || []).sort();\n  const newParams = newNode.parameters || {};\n  const newParamsCopy = { ...newParams };\n  delete newParamsCopy._versionControl;\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // MINOR: Check parameter structure changes (array lengths, etc.)\n  if (oldSnapshot.parameterStructure && newParams) {\n    for (const key in oldSnapshot.parameterStructure) {\n      const oldStruct = oldSnapshot.parameterStructure[key];\n      const newParam = newParams[key];\n      \n      if (!newParam) continue; // Parameter was removed (caught above)\n      \n      // Check assignment count changes\n      if (oldStruct.assignmentCount !== undefined) {\n        const newCount = newParam.assignments?.length || 0;\n        if (oldStruct.assignmentCount !== newCount) {\n          const change = newCount > oldStruct.assignmentCount ? 'Added' : 'Removed';\n          const diff = Math.abs(newCount - oldStruct.assignmentCount);\n          return { \n            type: 'minor', \n            reason: `${change} ${diff} assignment${diff > 1 ? 's' : ''} in '${key}'`\n          };\n        }\n      }\n      \n      // Check array length changes\n      if (oldStruct.arrayLength !== undefined) {\n        const newLength = Array.isArray(newParam) ? newParam.length : 0;\n        if (oldStruct.arrayLength !== newLength) {\n          return { \n            type: 'minor', \n            reason: `Array '${key}' size changed: ${oldStruct.arrayLength} ‚Üí ${newLength}`\n          };\n        }\n      }\n      \n      // Check parameter count changes (like HTTP headers)\n      if (oldStruct.paramCount !== undefined) {\n        const newCount = newParam.parameters?.length || 0;\n        if (oldStruct.paramCount !== newCount) {\n          return { \n            type: 'minor', \n            reason: `Parameter count in '${key}' changed: ${oldStruct.paramCount} ‚Üí ${newCount}`\n          };\n        }\n      }\n    }\n  }\n  \n  // If keys are the same and structure unchanged, it's a PATCH (value change)\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const parts = (version || '1.0.0').split('.').map(Number);\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  const snapshot = {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n  \n  // Store array lengths for parameters that are arrays or contain arrays\n  // This helps detect adding/removing items (MINOR change)\n  if (node.parameters) {\n    snapshot.parameterStructure = {};\n    \n    for (const key of snapshot.parameterKeys) {\n      const param = node.parameters[key];\n      \n      if (param && typeof param === 'object') {\n        // Check for common n8n patterns\n        if (param.assignments && Array.isArray(param.assignments)) {\n          // Set/Edit Fields node with assignments\n          snapshot.parameterStructure[key] = {\n            assignmentCount: param.assignments.length\n          };\n        } else if (Array.isArray(param)) {\n          // Direct array parameter\n          snapshot.parameterStructure[key] = {\n            arrayLength: param.length\n          };\n        } else if (param.parameters && Array.isArray(param.parameters)) {\n          // HTTP Request headers/parameters\n          snapshot.parameterStructure[key] = {\n            paramCount: param.parameters.length\n          };\n        }\n      }\n    }\n  }\n  \n  return snapshot;\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const existingVersion = parseVersionFromNotes(node.notes);\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hashChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  // Check for name changes (MAJOR change that doesn't affect hash)\n  const nameChanged = storedSnapshot && storedSnapshot.name !== node.name;\n  \n  // Node has changed if hash OR name changed\n  const hasChanged = hashChanged || nameChanged;\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: config,\n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2e0a251a",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2e0a251a\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnMxMSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "11a07bb9-9dee-444a-b6a0-45896ce06767",
      "name": "Build Success Response11",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -336,
        -10112
      ],
      "parameters": {
        "jsCode": "// CHANGE: Get data specifically from the calculation node\n// We cannot use $input because the HTTP Request node upstream overwrote \n// the data with the API response.\nconst processData = $(\"Process Node Versions11\").first().json;\n\n// Build detailed summary - all data comes from processData\nconst summary = {\n  success: true,\n  message: processData.hasChanges \n    ? `‚úÖ Version control updated: ${processData.nodeChanges.length} node${processData.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId: processData.config?.workflowId || 'unknown',\n  workflowName: processData.updatedWorkflow?.name || processData.originalWorkflow?.name || 'Unknown',\n  hasChanges: processData.hasChanges || false,\n  nodeChanges: processData.nodeChanges || [],\n  originalWorkflow: processData.originalWorkflow,\n  updatedWorkflow: processData.updatedWorkflow,\n  workflowVersion: processData.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp: processData.timestamp || new Date().toISOString(),\n  dryRun: false\n};\n\n// Add backup info if available\n  if (processData.backupSaved !== undefined) {\n    summary.backup = {\n      saved: processData.backupSaved,\n      filename: processData.backupFilename || null,\n      path: processData.backupPath || null,\n      error: processData.backupError || null,\n      cleanup: {\n        performed: processData.cleanupPerformed || false,\n        deleted: processData.deletedBackups || 0,\n        files: processData.deletedFiles || []\n      }\n    };\n  }\n\nreturn { json: summary };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1b252677",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 1b252677\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlMTEiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "c1820413-d3f4-4341-b56c-76611a20f8c2",
      "name": "Local Backup Enabled?2",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -448,
        -10368
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "local-backup-enabled",
              "leftValue": "={{ $json.config.localBackupEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "277dced1",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 277dced1\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiTG9jYWwgQmFja3VwIEVuYWJsZWQ/MiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "6c4281e1-132c-4644-971f-89ed6e254084",
      "name": "Save Local Backup2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -208,
        -10384
      ],
      "parameters": {
        "jsCode": "// Save Local Backup Node - with home directory expansion\n\nconst data = $input.first().json;\nconst workflow = data.updatedWorkflow;\nconst version = data.workflowVersion.current;\nconst config = data.config;\n\nconst fs = require('fs');\nconst path = require('path');\nconst os = require('os');\n\n// Expand ~ to home directory\nlet backupPath = config.localBackupPath;\nif (backupPath.startsWith('~/')) {\n  backupPath = path.join(os.homedir(), backupPath.slice(2));\n} else if (backupPath === '~') {\n  backupPath = os.homedir();\n}\n\n// Sanitize workflow name\nconst safeName = workflow.name\n  .replace(/\\s+/g, '_')\n  .replace(/[^a-zA-Z0-9_-]/g, '')\n  .substring(0, 50);\n\n// Generate human-readable timestamp\nconst now = new Date();\nconst year = now.getFullYear();\nconst month = String(now.getMonth() + 1).padStart(2, '0');\nconst day = String(now.getDate()).padStart(2, '0');\nconst hours = String(now.getHours()).padStart(2, '0');\nconst minutes = String(now.getMinutes()).padStart(2, '0');\nconst seconds = String(now.getSeconds()).padStart(2, '0');\n\nconst timestamp = `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;\n\n// Generate filename: workflow-v1.0.0-2026-02-07-06-39-00.json\nconst filename = `${safeName}-v${version}-${timestamp}.json`;\nconst filepath = path.join(backupPath, filename);\n\ntry {\n  // Ensure directory exists\n  if (!fs.existsSync(backupPath)) {\n    fs.mkdirSync(backupPath, { recursive: true });\n  }\n\n  // Save workflow\n  fs.writeFileSync(filepath, JSON.stringify(workflow, null, 2));\n\n  return {\n    json: {\n      ...data,\n      backupSaved: true,\n      backupFilename: filename,\n      backupPath: filepath,\n      backupTimestamp: now.toISOString()\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...data,\n      backupSaved: false,\n      backupError: error.message\n    }\n  };\n}\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7f04f408",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 7f04f408\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJTYXZlIExvY2FsIEJhY2t1cDIiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "c92983e6-1415-4312-8c84-79d729727419",
      "name": "Cleanup Old Versions2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -80,
        -10112
      ],
      "parameters": {
        "jsCode": "// Cleanup Old Versions Node - with home directory expansion\n\nconst data = $input.first().json;\nconst config = data.config;\n\nconst fs = require('fs');\nconst path = require('path');\nconst os = require('os');\n\n// Skip if unlimited\nif (config.localBackupMaxVersions === -1) {\n  return { \n    json: {\n      ...data,\n      cleanupPerformed: false,\n      reason: 'Unlimited versions enabled'\n    }\n  };\n}\n\ntry {\n  // Expand ~ to home directory\n  let backupPath = config.localBackupPath;\n  if (backupPath.startsWith('~/')) {\n    backupPath = path.join(os.homedir(), backupPath.slice(2));\n  } else if (backupPath === '~') {\n    backupPath = os.homedir();\n  }\n\n  // Sanitize workflow name to match saved files\n  const safeName = data.updatedWorkflow.name\n    .replace(/\\s+/g, '_')\n    .replace(/[^a-zA-Z0-9_-]/g, '')\n    .substring(0, 50);\n\n  // Find all backups for this workflow\n  const pattern = new RegExp(`^${safeName}-v.*-.*\\\\.json$`);\n  const allFiles = fs.readdirSync(backupPath);\n  const workflowFiles = allFiles\n    .filter(f => pattern.test(f))\n    .map(f => ({\n      name: f,\n      path: path.join(backupPath, f)\n    }));\n\n  // Sort by filename (chronologically - timestamp is sortable)\n  workflowFiles.sort((a, b) => a.name.localeCompare(b.name));\n\n  // Delete oldest if over limit\n  if (workflowFiles.length > config.localBackupMaxVersions) {\n    const toDelete = workflowFiles.slice(\n      0, \n      workflowFiles.length - config.localBackupMaxVersions\n    );\n    \n    const deletedFiles = [];\n    toDelete.forEach(file => {\n      fs.unlinkSync(file.path);\n      deletedFiles.push(file.name);\n    });\n    \n    return {\n      json: {\n        ...data,\n        cleanupPerformed: true,\n        deletedBackups: deletedFiles.length,\n        deletedFiles: deletedFiles,\n        remainingBackups: config.localBackupMaxVersions\n      }\n    };\n  }\n\n  return { \n    json: {\n      ...data,\n      cleanupPerformed: false,\n      reason: `Only ${workflowFiles.length} backups (limit: ${config.localBackupMaxVersions})`\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...data,\n      cleanupPerformed: false,\n      cleanupError: error.message\n    }\n  };\n}\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5bb70dc0",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5bb70dc0\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDbGVhbnVwIE9sZCBWZXJzaW9uczIiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "39bc8d71-a0e1-4f86-a4be-42a5214314de",
      "name": "Restore Data After Update1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -624,
        -10368
      ],
      "parameters": {
        "jsCode": "// Restore Data After HTTP Request\n\n// Get the original data from Process Node Versions\nconst processData = $(\"Process Node Versions11\").first().json;\n\n// Get the HTTP response (current input)\nconst httpResponse = $input.first().json;\n\n// Merge them - keep all original data, add HTTP response\nreturn {\n  json: {\n    ...processData,\n    httpResponse: httpResponse,\n    workflowUpdated: true\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "42bfa51a",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 42bfa51a\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJSZXN0b3JlIERhdGEgQWZ0ZXIgVXBkYXRlMSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "7c4e2e98-72f4-4aef-9682-5c7d2de0d273",
      "name": "Prepare Backup Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -320,
        -12064
      ],
      "parameters": {
        "jsCode": "// Prepare Backup Data - Create filename and data\n\nconst data = $input.first().json;\nconst workflow = data.updatedWorkflow;\nconst version = data.workflowVersion.current;\nconst config = data.config;\n\n// Sanitize workflow name\nconst safeName = workflow.name\n  .replace(/\\s+/g, '_')\n  .replace(/[^a-zA-Z0-9_-]/g, '')\n  .substring(0, 50);\n\n// Generate human-readable timestamp\nconst now = new Date();\nconst year = now.getFullYear();\nconst month = String(now.getMonth() + 1).padStart(2, '0');\nconst day = String(now.getDate()).padStart(2, '0');\nconst hours = String(now.getHours()).padStart(2, '0');\nconst minutes = String(now.getMinutes()).padStart(2, '0');\nconst seconds = String(now.getSeconds()).padStart(2, '0');\n\nconst timestamp = `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;\n\n// Generate filename\nconst filename = `${safeName}-v${version}-${timestamp}.json`;\n\n// Expand ~ to home directory for display\nlet displayPath = config.localBackupPath;\nif (displayPath.startsWith('~/')) {\n  displayPath = displayPath.replace('~', '/Users/stevenmiller');\n}\n\nreturn {\n  json: {\n    ...data,\n    backupFilename: filename,\n    backupDisplayPath: displayPath,\n    backupFullPath: `${displayPath}/${filename}`,\n    workflowJson: JSON.stringify(workflow, null, 2)\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3658510c",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3658510c\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcmVwYXJlIEJhY2t1cCBEYXRhIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "f43131ec-61ce-4465-bb20-390b7e7a8e75",
      "name": "Convert to Binary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -96,
        -12064
      ],
      "parameters": {
        "jsCode": "// Convert to Binary Data\n\nconst data = $input.first().json;\n\n// Convert JSON string to binary data\nconst binaryData = Buffer.from(data.workflowJson, 'utf-8');\n\nreturn {\n  json: data,\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'application/json',\n      fileName: data.backupFilename,\n      fileExtension: 'json'\n    }\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "792aa334",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 792aa334\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDb252ZXJ0IHRvIEJpbmFyeSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "eab1fa75-378e-4907-af1f-ca7eb54f25fe",
      "name": "Write Backup File",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        112,
        -12064
      ],
      "parameters": {
        "fileName": "={{ $json.backupFullPath }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "20c20b9a",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1\nüîí Hash: 20c20b9a\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uud3JpdGVCaW5hcnlGaWxlIiwibmFtZSI6IldyaXRlIEJhY2t1cCBGaWxlIiwidHlwZVZlcnNpb24iOjEsInBhcmFtZXRlcktleXMiOlsiZmlsZU5hbWUiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "161fb9c6-a144-4005-80c8-6b3e9abd114c",
      "name": "Mark Backup Complete",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        336,
        -12064
      ],
      "parameters": {
        "jsCode": "// Mark Backup Complete\n\nconst data = $input.first().json;\n\nreturn {\n  json: {\n    ...data,\n    backupSaved: true,\n    backupTimestamp: new Date().toISOString()\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7b6206e1",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 7b6206e1\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJNYXJrIEJhY2t1cCBDb21wbGV0ZSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "ef91e200-96d8-4848-94e3-c04913bb412f",
      "name": "Parse Configuration12",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1744,
        -12000
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\n// Configuration with defaults\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/data/workflow-backups',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupEnabled: input.localBackupEnabled ?? input.body?.localBackupEnabled ?? false,\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  localBackupMaxVersions: input.localBackupMaxVersions ?? input.body?.localBackupMaxVersions ?? 20,\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl ||  'http://localhost:5678/api/v1',\n  n8nApiKey: input.n8nApiKey || input.body?.n8nApiKey || '',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null, // null = auto-generate\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nreturn { json: config };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "41d6c534",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 41d6c534\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uMTIiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "09f2a5cc-81e7-4ae5-b6ae-f51002965f54",
      "name": "Fetch Current Workflow12",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1568,
        -12000
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.n8nApiKey }}"
            }
          ]
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "22aea478",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 22aea478\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzEyIiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJoZWFkZXJQYXJhbWV0ZXJzIiwib3B0aW9ucyIsInNlbmRIZWFkZXJzIiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjF9fX0=",
      "notesInFlow": true
    },
    {
      "id": "b48e4a9c-150b-4f81-b3bb-794f7d61c955",
      "name": "Has Changes?12",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1200,
        -12000
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/MTIiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "c3a38943-ada7-4768-b53b-44db8750e0ae",
      "name": "No Changes Response12",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -560,
        -11664
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'No changes detected', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: data.workflowVersion.current, timestamp: data.timestamp } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3919f890",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3919f890\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlMTIiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "29e05db5-f61b-4649-919a-a35a1c707b03",
      "name": "Dry Run?12",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -912,
        -12016
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj8xMiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "84494d89-f78b-4e47-9549-f69ab07f8606",
      "name": "Update Workflow with Versions12",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -688,
        -11904
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.config.n8nApiKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2b165197",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 2b165197\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnMxMiIsInR5cGVWZXJzaW9uIjo0LjIsInBhcmFtZXRlcktleXMiOlsiaGVhZGVyUGFyYW1ldGVycyIsImpzb25Cb2R5IiwibWV0aG9kIiwib3B0aW9ucyIsInNlbmRCb2R5Iiwic2VuZEhlYWRlcnMiLCJzcGVjaWZ5Qm9keSIsInVybCJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnsiaGVhZGVyUGFyYW1ldGVycyI6eyJwYXJhbUNvdW50IjoyfX19",
      "notesInFlow": true
    },
    {
      "id": "2a41ed1f-e784-4ad9-8fb8-07ad7ea2b2e6",
      "name": "Dry Run Response12",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -672,
        -12144
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'Dry run completed - no changes applied', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: { previous: data.workflowVersion.previous, wouldBecome: data.workflowVersion.current }, changes: data.nodeChanges, timestamp: data.timestamp, dryRun: true } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5226f176",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5226f176\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlMTIiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "12126c66-65a6-48d8-943d-b0f229656c72",
      "name": "Respond to Webhook12",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        112,
        -11920
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2sxMiIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsib3B0aW9ucyIsInJlc3BvbmRXaXRoIiwicmVzcG9uc2VCb2R5Il0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "efad4b5c-54c1-448c-9f45-1e684ecb0650",
      "name": "Process Node Versions12",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1360,
        -12112
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\nconst config = $(\"Parse Configuration12\").first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldSnapshot, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldSnapshot) return { type: 'major', reason: 'New node' };\n  \n  // MAJOR: Node type changed\n  if (oldSnapshot.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldSnapshot.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldSnapshot.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldSnapshot.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Compare parameter keys (what we have in snapshot)\n  const oldKeys = (oldSnapshot.parameterKeys || []).sort();\n  const newParams = newNode.parameters || {};\n  const newParamsCopy = { ...newParams };\n  delete newParamsCopy._versionControl;\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // MINOR: Check parameter structure changes (array lengths, etc.)\n  if (oldSnapshot.parameterStructure && newParams) {\n    for (const key in oldSnapshot.parameterStructure) {\n      const oldStruct = oldSnapshot.parameterStructure[key];\n      const newParam = newParams[key];\n      \n      if (!newParam) continue; // Parameter was removed (caught above)\n      \n      // Check assignment count changes\n      if (oldStruct.assignmentCount !== undefined) {\n        const newCount = newParam.assignments?.length || 0;\n        if (oldStruct.assignmentCount !== newCount) {\n          const change = newCount > oldStruct.assignmentCount ? 'Added' : 'Removed';\n          const diff = Math.abs(newCount - oldStruct.assignmentCount);\n          return { \n            type: 'minor', \n            reason: `${change} ${diff} assignment${diff > 1 ? 's' : ''} in '${key}'`\n          };\n        }\n      }\n      \n      // Check array length changes\n      if (oldStruct.arrayLength !== undefined) {\n        const newLength = Array.isArray(newParam) ? newParam.length : 0;\n        if (oldStruct.arrayLength !== newLength) {\n          return { \n            type: 'minor', \n            reason: `Array '${key}' size changed: ${oldStruct.arrayLength} ‚Üí ${newLength}`\n          };\n        }\n      }\n      \n      // Check parameter count changes (like HTTP headers)\n      if (oldStruct.paramCount !== undefined) {\n        const newCount = newParam.parameters?.length || 0;\n        if (oldStruct.paramCount !== newCount) {\n          return { \n            type: 'minor', \n            reason: `Parameter count in '${key}' changed: ${oldStruct.paramCount} ‚Üí ${newCount}`\n          };\n        }\n      }\n    }\n  }\n  \n  // If keys are the same and structure unchanged, it's a PATCH (value change)\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const parts = (version || '1.0.0').split('.').map(Number);\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  const snapshot = {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n  \n  // Store array lengths for parameters that are arrays or contain arrays\n  // This helps detect adding/removing items (MINOR change)\n  if (node.parameters) {\n    snapshot.parameterStructure = {};\n    \n    for (const key of snapshot.parameterKeys) {\n      const param = node.parameters[key];\n      \n      if (param && typeof param === 'object') {\n        // Check for common n8n patterns\n        if (param.assignments && Array.isArray(param.assignments)) {\n          // Set/Edit Fields node with assignments\n          snapshot.parameterStructure[key] = {\n            assignmentCount: param.assignments.length\n          };\n        } else if (Array.isArray(param)) {\n          // Direct array parameter\n          snapshot.parameterStructure[key] = {\n            arrayLength: param.length\n          };\n        } else if (param.parameters && Array.isArray(param.parameters)) {\n          // HTTP Request headers/parameters\n          snapshot.parameterStructure[key] = {\n            paramCount: param.parameters.length\n          };\n        }\n      }\n    }\n  }\n  \n  return snapshot;\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const existingVersion = parseVersionFromNotes(node.notes);\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hashChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  // Check for name changes (MAJOR change that doesn't affect hash)\n  const nameChanged = storedSnapshot && storedSnapshot.name !== node.name;\n  \n  // Node has changed if hash OR name changed\n  const hasChanged = hashChanged || nameChanged;\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: config,\n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2f233bf9",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2f233bf9\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnMxMiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "70856482-0aaf-4541-9a7d-7f0b87fe1fc5",
      "name": "Build Success Response12",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -480,
        -11904
      ],
      "parameters": {
        "jsCode": "// CHANGE: Get data specifically from the calculation node\n// We cannot use $input because the HTTP Request node upstream overwrote \n// the data with the API response.\nconst processData = $(\"Process Node Versions12\").first().json;\n\n// Build detailed summary - all data comes from processData\nconst summary = {\n  success: true,\n  message: processData.hasChanges \n    ? `‚úÖ Version control updated: ${processData.nodeChanges.length} node${processData.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId: processData.config?.workflowId || 'unknown',\n  workflowName: processData.updatedWorkflow?.name || processData.originalWorkflow?.name || 'Unknown',\n  hasChanges: processData.hasChanges || false,\n  nodeChanges: processData.nodeChanges || [],\n  originalWorkflow: processData.originalWorkflow,\n  updatedWorkflow: processData.updatedWorkflow,\n  workflowVersion: processData.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp: processData.timestamp || new Date().toISOString(),\n  dryRun: false\n};\n\n// Add backup info if available\n  if (processData.backupSaved !== undefined) {\n    summary.backup = {\n      saved: processData.backupSaved,\n      filename: processData.backupFilename || null,\n      path: processData.backupPath || null,\n      error: processData.backupError || null,\n      cleanup: {\n        performed: processData.cleanupPerformed || false,\n        deleted: processData.deletedBackups || 0,\n        files: processData.deletedFiles || []\n      }\n    };\n  }\n\nreturn { json: summary };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "51086cf6",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 51086cf6\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlMTIiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "d99e6361-5ef5-4ca7-89b9-d0a8929c9eb4",
      "name": "Local Backup Enabled?3",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -96,
        -11760
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "local-backup-enabled",
              "leftValue": "={{ $json.config.localBackupEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "277dced1",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 277dced1\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiTG9jYWwgQmFja3VwIEVuYWJsZWQ/MyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "99b0dc68-ed55-441d-aa22-fe493376e1b4",
      "name": "Restore Data After Update2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -544,
        -12064
      ],
      "parameters": {
        "jsCode": "// Restore Data After HTTP Request\n\n// Get the original data from Process Node Versions\nconst processData = $(\"Process Node Versions12\").first().json;\n\n// Get the HTTP response (current input)\nconst httpResponse = $input.first().json;\n\n// Merge them - keep all original data, add HTTP response\nreturn {\n  json: {\n    ...processData,\n    httpResponse: httpResponse,\n    workflowUpdated: true\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "49aa7625",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 49aa7625\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJSZXN0b3JlIERhdGEgQWZ0ZXIgVXBkYXRlMiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "87f6d722-30af-4b8a-8a18-453c7b676925",
      "name": "Mark Backup Complete1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        144,
        -13328
      ],
      "parameters": {
        "jsCode": "// Mark Backup Complete\n\nconst data = $input.first().json;\n\nreturn {\n  json: {\n    ...data,\n    backupSaved: true,\n    backupTimestamp: new Date().toISOString()\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7b6206e1",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 7b6206e1\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJNYXJrIEJhY2t1cCBDb21wbGV0ZTEiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "1313e2d1-f870-455a-812c-c438f64a8334",
      "name": "Write Backup File1",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        -80,
        -13328
      ],
      "parameters": {
        "fileName": "={{ $json.backupFullPath }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "20c20b9a",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1\nüîí Hash: 20c20b9a\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uud3JpdGVCaW5hcnlGaWxlIiwibmFtZSI6IldyaXRlIEJhY2t1cCBGaWxlMSIsInR5cGVWZXJzaW9uIjoxLCJwYXJhbWV0ZXJLZXlzIjpbImZpbGVOYW1lIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "691f836e-f271-42da-8992-49aeb294d9b3",
      "name": "Convert to Binary1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -288,
        -13328
      ],
      "parameters": {
        "jsCode": "// Convert to Binary Data\n\nconst data = $input.first().json;\n\n// Convert JSON string to binary data\nconst binaryData = Buffer.from(data.workflowJson, 'utf-8');\n\nreturn {\n  json: data,\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'application/json',\n      fileName: data.backupFilename,\n      fileExtension: 'json'\n    }\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "792aa334",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 792aa334\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDb252ZXJ0IHRvIEJpbmFyeTEiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "9faeee90-7387-46fb-892c-78a56150c1a3",
      "name": "Prepare Backup Data1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -512,
        -13328
      ],
      "parameters": {
        "jsCode": "// Prepare Backup Data - Create filename and data\n\nconst data = $input.first().json;\nconst workflow = data.updatedWorkflow;\nconst version = data.workflowVersion.current;\nconst config = data.config;\n\n// Sanitize workflow name\nconst safeName = workflow.name\n  .replace(/\\s+/g, '_')\n  .replace(/[^a-zA-Z0-9_-]/g, '')\n  .substring(0, 50);\n\n// Generate human-readable timestamp\nconst now = new Date();\nconst year = now.getFullYear();\nconst month = String(now.getMonth() + 1).padStart(2, '0');\nconst day = String(now.getDate()).padStart(2, '0');\nconst hours = String(now.getHours()).padStart(2, '0');\nconst minutes = String(now.getMinutes()).padStart(2, '0');\nconst seconds = String(now.getSeconds()).padStart(2, '0');\n\nconst timestamp = `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;\n\n// Generate filename\nconst filename = `${safeName}-v${version}-${timestamp}.json`;\n\n// Expand ~ to home directory for display\nlet displayPath = config.localBackupPath;\nif (displayPath.startsWith('~/')) {\n  displayPath = displayPath.replace('~', '/Users/stevenmiller');\n}\n\nreturn {\n  json: {\n    ...data,\n    backupFilename: filename,\n    backupDisplayPath: displayPath,\n    backupFullPath: `${displayPath}/${filename}`,\n    workflowJson: JSON.stringify(workflow, null, 2)\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3658510c",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3658510c\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcmVwYXJlIEJhY2t1cCBEYXRhMSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "9f591073-ed47-4d62-92ef-8fdd38e5c805",
      "name": "Restore Data After Update3",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -736,
        -13328
      ],
      "parameters": {
        "jsCode": "// Restore Data After HTTP Request\n\n// Get the original data from Process Node Versions\nconst processData = $(\"Process Node Versions13\").first().json;\n\n// Get the HTTP response (current input)\nconst httpResponse = $input.first().json;\n\n// Merge them - keep all original data, add HTTP response\nreturn {\n  json: {\n    ...processData,\n    httpResponse: httpResponse,\n    workflowUpdated: true\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "29eb6e9c",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 29eb6e9c\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJSZXN0b3JlIERhdGEgQWZ0ZXIgVXBkYXRlMyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "3caf2663-7c71-4224-a5e3-7a9c3da15d37",
      "name": "Local Backup Enabled?4",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -288,
        -13024
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "local-backup-enabled",
              "leftValue": "={{ $json.config.localBackupEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "277dced1",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 277dced1\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiTG9jYWwgQmFja3VwIEVuYWJsZWQ/NCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "d6a7471a-f89d-4b83-a9fb-98f37658f5da",
      "name": "Build Success Response13",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -672,
        -13168
      ],
      "parameters": {
        "jsCode": "// CHANGE: Get data specifically from the calculation node\n// We cannot use $input because the HTTP Request node upstream overwrote \n// the data with the API response.\nconst processData = $(\"Process Node Versions13\").first().json;\n\n// Build detailed summary - all data comes from processData\nconst summary = {\n  success: true,\n  message: processData.hasChanges \n    ? `‚úÖ Version control updated: ${processData.nodeChanges.length} node${processData.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId: processData.config?.workflowId || 'unknown',\n  workflowName: processData.updatedWorkflow?.name || processData.originalWorkflow?.name || 'Unknown',\n  hasChanges: processData.hasChanges || false,\n  nodeChanges: processData.nodeChanges || [],\n  originalWorkflow: processData.originalWorkflow,\n  updatedWorkflow: processData.updatedWorkflow,\n  workflowVersion: processData.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp: processData.timestamp || new Date().toISOString(),\n  dryRun: false\n};\n\n// Add backup info if available\n  if (processData.backupSaved !== undefined) {\n    summary.backup = {\n      saved: processData.backupSaved,\n      filename: processData.backupFilename || null,\n      path: processData.backupPath || null,\n      error: processData.backupError || null,\n      cleanup: {\n        performed: processData.cleanupPerformed || false,\n        deleted: processData.deletedBackups || 0,\n        files: processData.deletedFiles || []\n      }\n    };\n  }\n\nreturn { json: summary };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "79144c8b",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 79144c8b\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlMTMiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "a1ba4e0f-606e-4929-af83-0ca7bbc7c524",
      "name": "Process Node Versions13",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1552,
        -13376
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\nconst config = $(\"Parse Configuration13\").first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldSnapshot, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldSnapshot) return { type: 'major', reason: 'New node' };\n  \n  // MAJOR: Node type changed\n  if (oldSnapshot.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldSnapshot.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldSnapshot.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldSnapshot.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Compare parameter keys (what we have in snapshot)\n  const oldKeys = (oldSnapshot.parameterKeys || []).sort();\n  const newParams = newNode.parameters || {};\n  const newParamsCopy = { ...newParams };\n  delete newParamsCopy._versionControl;\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // MINOR: Check parameter structure changes (array lengths, etc.)\n  if (oldSnapshot.parameterStructure && newParams) {\n    for (const key in oldSnapshot.parameterStructure) {\n      const oldStruct = oldSnapshot.parameterStructure[key];\n      const newParam = newParams[key];\n      \n      if (!newParam) continue; // Parameter was removed (caught above)\n      \n      // Check assignment count changes\n      if (oldStruct.assignmentCount !== undefined) {\n        const newCount = newParam.assignments?.length || 0;\n        if (oldStruct.assignmentCount !== newCount) {\n          const change = newCount > oldStruct.assignmentCount ? 'Added' : 'Removed';\n          const diff = Math.abs(newCount - oldStruct.assignmentCount);\n          return { \n            type: 'minor', \n            reason: `${change} ${diff} assignment${diff > 1 ? 's' : ''} in '${key}'`\n          };\n        }\n      }\n      \n      // Check array length changes\n      if (oldStruct.arrayLength !== undefined) {\n        const newLength = Array.isArray(newParam) ? newParam.length : 0;\n        if (oldStruct.arrayLength !== newLength) {\n          return { \n            type: 'minor', \n            reason: `Array '${key}' size changed: ${oldStruct.arrayLength} ‚Üí ${newLength}`\n          };\n        }\n      }\n      \n      // Check parameter count changes (like HTTP headers)\n      if (oldStruct.paramCount !== undefined) {\n        const newCount = newParam.parameters?.length || 0;\n        if (oldStruct.paramCount !== newCount) {\n          return { \n            type: 'minor', \n            reason: `Parameter count in '${key}' changed: ${oldStruct.paramCount} ‚Üí ${newCount}`\n          };\n        }\n      }\n    }\n  }\n  \n  // If keys are the same and structure unchanged, it's a PATCH (value change)\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const parts = (version || '1.0.0').split('.').map(Number);\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  const snapshot = {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n  \n  // Store array lengths for parameters that are arrays or contain arrays\n  // This helps detect adding/removing items (MINOR change)\n  if (node.parameters) {\n    snapshot.parameterStructure = {};\n    \n    for (const key of snapshot.parameterKeys) {\n      const param = node.parameters[key];\n      \n      if (param && typeof param === 'object') {\n        // Check for common n8n patterns\n        if (param.assignments && Array.isArray(param.assignments)) {\n          // Set/Edit Fields node with assignments\n          snapshot.parameterStructure[key] = {\n            assignmentCount: param.assignments.length\n          };\n        } else if (Array.isArray(param)) {\n          // Direct array parameter\n          snapshot.parameterStructure[key] = {\n            arrayLength: param.length\n          };\n        } else if (param.parameters && Array.isArray(param.parameters)) {\n          // HTTP Request headers/parameters\n          snapshot.parameterStructure[key] = {\n            paramCount: param.parameters.length\n          };\n        }\n      }\n    }\n  }\n  \n  return snapshot;\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const existingVersion = parseVersionFromNotes(node.notes);\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hashChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  // Check for name changes (MAJOR change that doesn't affect hash)\n  const nameChanged = storedSnapshot && storedSnapshot.name !== node.name;\n  \n  // Node has changed if hash OR name changed\n  const hasChanged = hashChanged || nameChanged;\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: config,\n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "303c52d8",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 303c52d8\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnMxMyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "29581a5f-6a8b-43e6-bd5c-0beb65d2cd9c",
      "name": "Respond to Webhook13",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        -80,
        -13184
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2sxMyIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsib3B0aW9ucyIsInJlc3BvbmRXaXRoIiwicmVzcG9uc2VCb2R5Il0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "fdc227ef-3024-4d48-bc1a-c419b7a0a65f",
      "name": "Dry Run Response13",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -864,
        -13408
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'Dry run completed - no changes applied', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: { previous: data.workflowVersion.previous, wouldBecome: data.workflowVersion.current }, changes: data.nodeChanges, timestamp: data.timestamp, dryRun: true } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5226f176",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5226f176\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlMTMiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "34a0cfdd-1b70-41ec-97ea-e15ca1fc671a",
      "name": "Update Workflow with Versions13",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -880,
        -13168
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.config.n8nApiKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2b165197",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 2b165197\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnMxMyIsInR5cGVWZXJzaW9uIjo0LjIsInBhcmFtZXRlcktleXMiOlsiaGVhZGVyUGFyYW1ldGVycyIsImpzb25Cb2R5IiwibWV0aG9kIiwib3B0aW9ucyIsInNlbmRCb2R5Iiwic2VuZEhlYWRlcnMiLCJzcGVjaWZ5Qm9keSIsInVybCJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnsiaGVhZGVyUGFyYW1ldGVycyI6eyJwYXJhbUNvdW50IjoyfX19",
      "notesInFlow": true
    },
    {
      "id": "3c0d5430-96da-4516-a570-f5e2c3d97905",
      "name": "Dry Run?13",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1104,
        -13280
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj8xMyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "7ba46765-f56e-44a5-bcec-a8969b2b8215",
      "name": "No Changes Response13",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -752,
        -12928
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'No changes detected', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: data.workflowVersion.current, timestamp: data.timestamp } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3919f890",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3919f890\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlMTMiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "259f3958-152f-48d3-a81a-17e319160d03",
      "name": "Has Changes?13",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1392,
        -13264
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/MTMiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "31fdd9ef-6689-48ac-adf5-75cf31da8577",
      "name": "Fetch Current Workflow13",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1760,
        -13264
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.n8nApiKey }}"
            }
          ]
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "22aea478",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 22aea478\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzEzIiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJoZWFkZXJQYXJhbWV0ZXJzIiwib3B0aW9ucyIsInNlbmRIZWFkZXJzIiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjF9fX0=",
      "notesInFlow": true
    },
    {
      "id": "65371a0e-8aec-47f0-a450-6d6a6f029715",
      "name": "Parse Configuration13",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1936,
        -13264
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\n// Configuration with defaults\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/data/workflow-backups',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupEnabled: input.localBackupEnabled ?? input.body?.localBackupEnabled ?? false,\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  localBackupMaxVersions: input.localBackupMaxVersions ?? input.body?.localBackupMaxVersions ?? 20,\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl ||  'http://localhost:5678/api/v1',\n  n8nApiKey: input.n8nApiKey || input.body?.n8nApiKey || '',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null, // null = auto-generate\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nreturn { json: config };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "41d6c534",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 41d6c534\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uMTMiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "aafa74b9-73d4-4afb-9a86-9e9876613eaf",
      "name": "Cleanup Old Backups",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        960,
        -14272
      ],
      "parameters": {
        "jsCode": "// Cleanup Old Backups\n// Keep only newest N backups for the current workflow prefix.\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst data = $input.first().json;\nconst config = data.config || {};\n\nconst backupDir = (data.backupDisplayPath || path.dirname(data.backupFullPath || '')).replace(/\\/+$/, '');\nconst currentFile = data.backupFilename || path.basename(data.backupFullPath || '');\nconst backupPrefix = data.backupPrefix || null;\n\nconst maxRaw = Number(config.localBackupMaxVersions ?? 20);\nconst maxVersions = Number.isFinite(maxRaw) ? Math.floor(maxRaw) : 20;\n\nfunction escapeRegex(value) {\n  return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction prefixFromFile(filename) {\n  const semverIndex = filename.indexOf('-v');\n  if (semverIndex > 0) return `${filename.slice(0, semverIndex)}-v`;\n  return null;\n}\n\nfunction getSortEpochMs(filename, fallbackMs) {\n  const match = filename.match(/-(\\d{4})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})\\.json$/);\n  if (!match) return fallbackMs;\n\n  const [, y, mo, d, h, mi, s] = match;\n  const dt = Date.UTC(Number(y), Number(mo) - 1, Number(d), Number(h), Number(mi), Number(s));\n  return Number.isFinite(dt) ? dt : fallbackMs;\n}\n\ntry {\n  if (!backupDir) {\n    return {\n      json: {\n        ...data,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Backup directory is missing.',\n      }\n    };\n  }\n\n  // Preserve the newest backup by default even if max is misconfigured.\n  const effectiveMax = maxVersions < 1 ? 1 : maxVersions;\n\n  const workflowPrefix = backupPrefix || prefixFromFile(currentFile);\n  if (!workflowPrefix) {\n    return {\n      json: {\n        ...data,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Unable to determine workflow backup prefix.',\n      }\n    };\n  }\n\n  const filePattern = new RegExp(\n    `^${escapeRegex(workflowPrefix)}\\\\d+\\\\.\\\\d+\\\\.\\\\d+-\\\\d{4}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}\\\\.json$`\n  );\n\n  const matchingFiles = fs\n    .readdirSync(backupDir, { withFileTypes: true })\n    .filter((entry) => entry.isFile())\n    .map((entry) => entry.name)\n    .filter((name) => filePattern.test(name))\n    .map((name) => {\n      const fullPath = path.join(backupDir, name);\n      const stats = fs.statSync(fullPath);\n      return {\n        name,\n        fullPath,\n        mtimeMs: stats.mtimeMs,\n        sortEpochMs: getSortEpochMs(name, stats.mtimeMs),\n      };\n    })\n    .sort((a, b) => {\n      if (a.sortEpochMs !== b.sortEpochMs) return a.sortEpochMs - b.sortEpochMs;\n      return a.mtimeMs - b.mtimeMs;\n    });\n\n  const deleteCount = Math.max(0, matchingFiles.length - effectiveMax);\n  const toDelete = matchingFiles.slice(0, deleteCount);\n\n  for (const file of toDelete) {\n    fs.unlinkSync(file.fullPath);\n  }\n\n  return {\n    json: {\n      ...data,\n      cleanupPerformed: true,\n      cleanupPrefix: workflowPrefix,\n      cleanupMaxVersions: effectiveMax,\n      matchedBackups: matchingFiles.length,\n      deletedBackups: toDelete.length,\n      deletedFiles: toDelete.map((file) => file.name),\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...data,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n      backupCleanupError: error?.message || String(error),\n    }\n  };\n}\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "ba33bb4",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: ba33bb4\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDbGVhbnVwIE9sZCBCYWNrdXBzIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "6569e0c9-40dc-408c-9dce-9360352f5ddb",
      "name": "Mark Backup Complete2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        752,
        -14272
      ],
      "parameters": {
        "jsCode": "// Mark Backup Complete\n\nconst data = $input.first().json;\n\nreturn {\n  json: {\n    ...data,\n    backupSaved: true,\n    backupTimestamp: new Date().toISOString(),\n    backupPath: data.backupFullPath || null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "84b988f",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 84b988f\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJNYXJrIEJhY2t1cCBDb21wbGV0ZTIiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "ec01a7f1-a035-4e64-a9d0-8a47e1f2dc8f",
      "name": "Write Backup File2",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        528,
        -14272
      ],
      "parameters": {
        "fileName": "={{ $json.backupFullPath }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "20c20b9a",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1\nüîí Hash: 20c20b9a\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uud3JpdGVCaW5hcnlGaWxlIiwibmFtZSI6IldyaXRlIEJhY2t1cCBGaWxlMiIsInR5cGVWZXJzaW9uIjoxLCJwYXJhbWV0ZXJLZXlzIjpbImZpbGVOYW1lIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "c64de6d2-6f1f-4884-8cdb-600c6f26b644",
      "name": "Convert to Binary2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        320,
        -14272
      ],
      "parameters": {
        "jsCode": "// Convert to Binary Data\n\nconst data = $input.first().json;\n\n// Convert JSON string to binary data\nconst binaryData = Buffer.from(data.workflowJson, 'utf-8');\n\nreturn {\n  json: data,\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'application/json',\n      fileName: data.backupFilename,\n      fileExtension: 'json'\n    }\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "792aa334",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 792aa334\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDb252ZXJ0IHRvIEJpbmFyeTIiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "c63d086b-21c8-42cd-b317-e2510ad6c0fe",
      "name": "Prepare Backup Data2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        96,
        -14272
      ],
      "parameters": {
        "jsCode": "// Prepare Backup Data - Create filename and data\n\nconst data = $input.first().json;\nconst workflow = data.updatedWorkflow;\nconst version = data.workflowVersion.current;\nconst config = data.config;\n\n// Sanitize workflow name\nconst safeName = workflow.name\n  .replace(/\\s+/g, '_')\n  .replace(/[^a-zA-Z0-9_-]/g, '')\n  .substring(0, 50);\n\n// Generate human-readable timestamp\nconst now = new Date();\nconst year = now.getFullYear();\nconst month = String(now.getMonth() + 1).padStart(2, '0');\nconst day = String(now.getDate()).padStart(2, '0');\nconst hours = String(now.getHours()).padStart(2, '0');\nconst minutes = String(now.getMinutes()).padStart(2, '0');\nconst seconds = String(now.getSeconds()).padStart(2, '0');\n\nconst timestamp = `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;\n\nconst backupPrefix = `${safeName}-v`;\nconst filename = `${backupPrefix}${version}-${timestamp}.json`;\n\nlet backupDir = config.localBackupPath || '/tmp';\nif (backupDir.startsWith('~/')) {\n  const homeDir =\n    (typeof process !== 'undefined' && process.env && process.env.HOME)\n      ? process.env.HOME\n      : '/home/node';\n  backupDir = backupDir.replace(/^~(?=\\/)/, homeDir);\n}\n\nbackupDir = backupDir.replace(/\\/+$/, '') || '/tmp';\n\nreturn {\n  json: {\n    ...data,\n    backupPrefix,\n    backupFilename: filename,\n    backupDisplayPath: backupDir,\n    backupFullPath: `${backupDir}/${filename}`,\n    workflowJson: JSON.stringify(workflow, null, 2),\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "52eca43b",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 52eca43b\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcmVwYXJlIEJhY2t1cCBEYXRhMiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "ddfd7544-a365-46ae-aa24-3c653b4f842a",
      "name": "Restore Data After Update4",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -128,
        -14272
      ],
      "parameters": {
        "jsCode": "// Restore Data After HTTP Request\n\n// Get the original data from Process Node Versions\nconst processData = $(\"Process Node Versions14\").first().json;\n\n// Get the HTTP response (current input)\nconst httpResponse = $input.first().json;\n\n// Merge them - keep all original data, add HTTP response\nreturn {\n  json: {\n    ...processData,\n    httpResponse: httpResponse,\n    workflowUpdated: true\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "627eaca3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 627eaca3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJSZXN0b3JlIERhdGEgQWZ0ZXIgVXBkYXRlNCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "e24c9877-af39-4205-ac31-7cabca731074",
      "name": "Local Backup Enabled?5",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        320,
        -13968
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "local-backup-enabled",
              "leftValue": "={{ $json.config.localBackupEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "277dced1",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 277dced1\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiTG9jYWwgQmFja3VwIEVuYWJsZWQ/NSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "f3466536-4433-4b83-b8ac-7857847b0961",
      "name": "Build Success Response14",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -64,
        -14112
      ],
      "parameters": {
        "jsCode": "// Build Success Response\n// Merge original process data with latest branch data so backup/cleanup fields are preserved.\n\nconst processData = $(\"Process Node Versions14\").first().json;\nconst latestData = $input.first().json;\nconst data = {\n  ...processData,\n  ...latestData,\n};\n\nconst summary = {\n  success: true,\n  message: data.hasChanges\n    ? `‚úÖ Version control updated: ${data.nodeChanges.length} node${data.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId: data.config?.workflowId || 'unknown',\n  workflowName: data.updatedWorkflow?.name || data.originalWorkflow?.name || 'Unknown',\n  hasChanges: data.hasChanges || false,\n  nodeChanges: data.nodeChanges || [],\n  originalWorkflow: data.originalWorkflow,\n  updatedWorkflow: data.updatedWorkflow,\n  workflowVersion: data.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp: data.timestamp || new Date().toISOString(),\n  dryRun: false,\n};\n\nif (data.backupSaved !== undefined) {\n  summary.backup = {\n    saved: data.backupSaved,\n    filename: data.backupFilename || null,\n    path: data.backupPath || null,\n    error: data.backupError || data.backupCleanupError || null,\n    cleanup: {\n      performed: data.cleanupPerformed || false,\n      deleted: data.deletedBackups || 0,\n      files: data.deletedFiles || [],\n      prefix: data.cleanupPrefix || null,\n      matchedBackups: data.matchedBackups || 0,\n      maxVersions: data.cleanupMaxVersions ?? null,\n    },\n  };\n}\n\nreturn { json: summary };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "57104f1d",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 57104f1d\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlMTQiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "261a914b-4eb6-40be-a3d0-fb1027411733",
      "name": "Process Node Versions14",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -944,
        -14320
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\nconst config = $(\"Parse Configuration14\").first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldSnapshot, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldSnapshot) return { type: 'major', reason: 'New node' };\n  \n  // MAJOR: Node type changed\n  if (oldSnapshot.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldSnapshot.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldSnapshot.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldSnapshot.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Compare parameter keys (what we have in snapshot)\n  const oldKeys = (oldSnapshot.parameterKeys || []).sort();\n  const newParams = newNode.parameters || {};\n  const newParamsCopy = { ...newParams };\n  delete newParamsCopy._versionControl;\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // MINOR: Check parameter structure changes (array lengths, etc.)\n  if (oldSnapshot.parameterStructure && newParams) {\n    for (const key in oldSnapshot.parameterStructure) {\n      const oldStruct = oldSnapshot.parameterStructure[key];\n      const newParam = newParams[key];\n      \n      if (!newParam) continue; // Parameter was removed (caught above)\n      \n      // Check assignment count changes\n      if (oldStruct.assignmentCount !== undefined) {\n        const newCount = newParam.assignments?.length || 0;\n        if (oldStruct.assignmentCount !== newCount) {\n          const change = newCount > oldStruct.assignmentCount ? 'Added' : 'Removed';\n          const diff = Math.abs(newCount - oldStruct.assignmentCount);\n          return { \n            type: 'minor', \n            reason: `${change} ${diff} assignment${diff > 1 ? 's' : ''} in '${key}'`\n          };\n        }\n      }\n      \n      // Check array length changes\n      if (oldStruct.arrayLength !== undefined) {\n        const newLength = Array.isArray(newParam) ? newParam.length : 0;\n        if (oldStruct.arrayLength !== newLength) {\n          return { \n            type: 'minor', \n            reason: `Array '${key}' size changed: ${oldStruct.arrayLength} ‚Üí ${newLength}`\n          };\n        }\n      }\n      \n      // Check parameter count changes (like HTTP headers)\n      if (oldStruct.paramCount !== undefined) {\n        const newCount = newParam.parameters?.length || 0;\n        if (oldStruct.paramCount !== newCount) {\n          return { \n            type: 'minor', \n            reason: `Parameter count in '${key}' changed: ${oldStruct.paramCount} ‚Üí ${newCount}`\n          };\n        }\n      }\n    }\n  }\n  \n  // If keys are the same and structure unchanged, it's a PATCH (value change)\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const parts = (version || '1.0.0').split('.').map(Number);\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  const snapshot = {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n  \n  // Store array lengths for parameters that are arrays or contain arrays\n  // This helps detect adding/removing items (MINOR change)\n  if (node.parameters) {\n    snapshot.parameterStructure = {};\n    \n    for (const key of snapshot.parameterKeys) {\n      const param = node.parameters[key];\n      \n      if (param && typeof param === 'object') {\n        // Check for common n8n patterns\n        if (param.assignments && Array.isArray(param.assignments)) {\n          // Set/Edit Fields node with assignments\n          snapshot.parameterStructure[key] = {\n            assignmentCount: param.assignments.length\n          };\n        } else if (Array.isArray(param)) {\n          // Direct array parameter\n          snapshot.parameterStructure[key] = {\n            arrayLength: param.length\n          };\n        } else if (param.parameters && Array.isArray(param.parameters)) {\n          // HTTP Request headers/parameters\n          snapshot.parameterStructure[key] = {\n            paramCount: param.parameters.length\n          };\n        }\n      }\n    }\n  }\n  \n  return snapshot;\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const existingVersion = parseVersionFromNotes(node.notes);\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hashChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  // Check for name changes (MAJOR change that doesn't affect hash)\n  const nameChanged = storedSnapshot && storedSnapshot.name !== node.name;\n  \n  // Node has changed if hash OR name changed\n  const hasChanged = hashChanged || nameChanged;\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: config,\n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "315569b7",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 315569b7\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnMxNCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "8a5be9f8-b841-46c5-8dbf-aa0de95a686a",
      "name": "Respond to Webhook14",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        528,
        -14128
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2sxNCIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsib3B0aW9ucyIsInJlc3BvbmRXaXRoIiwicmVzcG9uc2VCb2R5Il0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "6cc21ea3-1b28-40be-9ad1-193fa610acb2",
      "name": "Dry Run Response14",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -256,
        -14352
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'Dry run completed - no changes applied', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: { previous: data.workflowVersion.previous, wouldBecome: data.workflowVersion.current }, changes: data.nodeChanges, timestamp: data.timestamp, dryRun: true } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5226f176",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5226f176\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlMTQiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "99851c8a-feaa-4302-8a5b-cf87dc389114",
      "name": "Update Workflow with Versions14",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -272,
        -14112
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.config.n8nApiKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2b165197",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 2b165197\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnMxNCIsInR5cGVWZXJzaW9uIjo0LjIsInBhcmFtZXRlcktleXMiOlsiaGVhZGVyUGFyYW1ldGVycyIsImpzb25Cb2R5IiwibWV0aG9kIiwib3B0aW9ucyIsInNlbmRCb2R5Iiwic2VuZEhlYWRlcnMiLCJzcGVjaWZ5Qm9keSIsInVybCJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnsiaGVhZGVyUGFyYW1ldGVycyI6eyJwYXJhbUNvdW50IjoyfX19",
      "notesInFlow": true
    },
    {
      "id": "49112511-1eaf-471b-ac59-3f47851cb583",
      "name": "Dry Run?14",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -496,
        -14224
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj8xNCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "b904db38-12af-4302-a587-c362de00b1d3",
      "name": "No Changes Response14",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -144,
        -13872
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'No changes detected', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: data.workflowVersion.current, timestamp: data.timestamp } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3919f890",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3919f890\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlMTQiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "6adbbdd0-b5e2-4d52-9ab1-0dde8fefafac",
      "name": "Has Changes?14",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -784,
        -14208
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/MTQiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "e474d5d0-7a45-4b6d-9451-af23dcbe659d",
      "name": "Fetch Current Workflow14",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1152,
        -14208
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.n8nApiKey }}"
            }
          ]
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "22aea478",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 22aea478\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzE0IiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJoZWFkZXJQYXJhbWV0ZXJzIiwib3B0aW9ucyIsInNlbmRIZWFkZXJzIiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjF9fX0=",
      "notesInFlow": true
    },
    {
      "id": "08b10cab-85f4-4bd3-bd5e-642b59e3e16b",
      "name": "Parse Configuration14",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1328,
        -14208
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\n// Configuration with defaults\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/data/workflow-backups',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupEnabled: input.localBackupEnabled ?? input.body?.localBackupEnabled ?? false,\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  localBackupMaxVersions: input.localBackupMaxVersions ?? input.body?.localBackupMaxVersions ?? 20,\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl ||  'http://localhost:5678/api/v1',\n  n8nApiKey: input.n8nApiKey || input.body?.n8nApiKey || '',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null, // null = auto-generate\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nreturn { json: config };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "41d6c534",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 41d6c534\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uMTQiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "3c24c8bf-63d0-49b3-8e60-969223af1249",
      "name": "Delete Old Backups Enabled?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        528,
        -15264
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "cleanup-old-backups-enabled",
              "leftValue": "={{ $json.config.cleanupOldBackupsEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "47bddea4",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 47bddea4\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRGVsZXRlIE9sZCBCYWNrdXBzIEVuYWJsZWQ/IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsiY29uZGl0aW9ucyIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "83b33b52-9ab5-4c9a-9bfc-43696f5ac0e9",
      "name": "Mark Backup Complete3",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        368,
        -15264
      ],
      "parameters": {
        "jsCode": "// Mark Backup Complete\n\nconst data = $input.first().json;\n\nreturn {\n  json: {\n    ...data,\n    backupSaved: true,\n    backupTimestamp: new Date().toISOString(),\n    backupPath: data.backupFullPath || null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "84b988f",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 84b988f\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJNYXJrIEJhY2t1cCBDb21wbGV0ZTMiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "94573bfa-dd75-4f87-9e54-8bfdb152b192",
      "name": "Write Backup File3",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        192,
        -15264
      ],
      "parameters": {
        "fileName": "={{ $json.backupFullPath }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "20c20b9a",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1\nüîí Hash: 20c20b9a\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uud3JpdGVCaW5hcnlGaWxlIiwibmFtZSI6IldyaXRlIEJhY2t1cCBGaWxlMyIsInR5cGVWZXJzaW9uIjoxLCJwYXJhbWV0ZXJLZXlzIjpbImZpbGVOYW1lIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "f98ddc48-3512-49ab-99cc-7290a1477dc7",
      "name": "Convert to Binary3",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        16,
        -15264
      ],
      "parameters": {
        "jsCode": "// Convert to Binary Data\n\nconst data = $input.first().json;\n\n// Convert JSON string to binary data\nconst binaryData = Buffer.from(data.workflowJson, 'utf-8');\n\nreturn {\n  json: data,\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'application/json',\n      fileName: data.backupFilename,\n      fileExtension: 'json'\n    }\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "792aa334",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 792aa334\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDb252ZXJ0IHRvIEJpbmFyeTMiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "e61c49bb-fff2-4be8-a68e-a424c55c2ddd",
      "name": "Prepare Backup Data3",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -176,
        -15264
      ],
      "parameters": {
        "jsCode": "// Prepare Backup Data - Create filename and data\n\nconst data = $input.first().json;\nconst workflow = data.updatedWorkflow;\nconst version = data.workflowVersion.current;\nconst config = data.config;\n\n// Sanitize workflow name\nconst safeName = workflow.name\n  .replace(/\\s+/g, '_')\n  .replace(/[^a-zA-Z0-9_-]/g, '')\n  .substring(0, 50);\n\n// Generate human-readable timestamp\nconst now = new Date();\nconst year = now.getFullYear();\nconst month = String(now.getMonth() + 1).padStart(2, '0');\nconst day = String(now.getDate()).padStart(2, '0');\nconst hours = String(now.getHours()).padStart(2, '0');\nconst minutes = String(now.getMinutes()).padStart(2, '0');\nconst seconds = String(now.getSeconds()).padStart(2, '0');\n\nconst timestamp = `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;\n\nconst backupPrefix = `${safeName}-v`;\nconst filename = `${backupPrefix}${version}-${timestamp}.json`;\n\nlet backupDir = config.localBackupPath || '/tmp';\nif (backupDir.startsWith('~/')) {\n  const homeDir =\n    (typeof process !== 'undefined' && process.env && process.env.HOME)\n      ? process.env.HOME\n      : '/home/node';\n  backupDir = backupDir.replace(/^~(?=\\/)/, homeDir);\n}\n\nbackupDir = backupDir.replace(/\\/+$/, '') || '/tmp';\n\nreturn {\n  json: {\n    ...data,\n    backupPrefix,\n    backupFilename: filename,\n    backupDisplayPath: backupDir,\n    backupFullPath: `${backupDir}/${filename}`,\n    workflowJson: JSON.stringify(workflow, null, 2),\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "52eca43b",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 52eca43b\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcmVwYXJlIEJhY2t1cCBEYXRhMyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "a2ec20ab-7dc4-4a13-9ada-d31c95e0ade1",
      "name": "Restore Data After Update5",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -368,
        -15568
      ],
      "parameters": {
        "jsCode": "// Restore Data After HTTP Request\n\n// Get the original data from Process Node Versions\nconst processData = $(\"Process Node Versions15\").first().json;\n\n// Get the HTTP response (current input)\nconst httpResponse = $input.first().json;\n\n// Merge them - keep all original data, add HTTP response\nreturn {\n  json: {\n    ...processData,\n    httpResponse: httpResponse,\n    workflowUpdated: true\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1117381e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 1117381e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJSZXN0b3JlIERhdGEgQWZ0ZXIgVXBkYXRlNSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "5ec45653-8e80-4646-8d59-a22819faef33",
      "name": "Local Backup Enabled?6",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -144,
        -15568
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "local-backup-enabled",
              "leftValue": "={{ $json.config.localBackupEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "277dced1",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 277dced1\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiTG9jYWwgQmFja3VwIEVuYWJsZWQ/NiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "53cf49c7-6556-42b2-9219-aaffb2d03b49",
      "name": "Build Success Response15",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1056,
        -15568
      ],
      "parameters": {
        "jsCode": "// Build Success Response\n// Merge original process data with latest branch data so backup/cleanup fields are preserved.\n\nconst processData = $(\"Process Node Versions15\").first().json;\nconst latestData = $input.first().json;\nconst data = {\n  ...processData,\n  ...latestData,\n};\n\nconst cleanupEnabled = data.cleanupEnabled ?? (data.config?.cleanupOldBackupsEnabled ?? false);\n\nconst summary = {\n  success: true,\n  message: data.hasChanges\n    ? `‚úÖ Version control updated: ${data.nodeChanges.length} node${data.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId: data.config?.workflowId || 'unknown',\n  workflowName: data.updatedWorkflow?.name || data.originalWorkflow?.name || 'Unknown',\n  hasChanges: data.hasChanges || false,\n  nodeChanges: data.nodeChanges || [],\n  originalWorkflow: data.originalWorkflow,\n  updatedWorkflow: data.updatedWorkflow,\n  workflowVersion: data.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp: data.timestamp || new Date().toISOString(),\n  dryRun: false,\n};\n\nif (data.backupSaved !== undefined) {\n  summary.backup = {\n    saved: data.backupSaved,\n    filename: data.backupFilename || null,\n    path: data.backupPath || null,\n    error: data.backupError || data.backupCleanupError || null,\n    cleanup: {\n      enabled: cleanupEnabled,\n      performed: data.cleanupPerformed || false,\n      skipped: data.cleanupSkipped || false,\n      deleted: data.deletedBackups || 0,\n      files: data.deletedFiles || [],\n      prefix: data.cleanupPrefix || null,\n      matchedBackups: data.matchedBackups || 0,\n      maxVersions: data.cleanupMaxVersions ?? null,\n    },\n  };\n}\n\nreturn { json: summary };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1317716e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 1317716e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlMTUiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "7e89b23b-44a9-4b56-a291-e561dc41cdce",
      "name": "Process Node Versions15",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1216,
        -15152
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\nconst config = $(\"Parse Configuration15\").first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldSnapshot, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldSnapshot) return { type: 'major', reason: 'New node' };\n  \n  // MAJOR: Node type changed\n  if (oldSnapshot.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldSnapshot.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldSnapshot.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldSnapshot.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Compare parameter keys (what we have in snapshot)\n  const oldKeys = (oldSnapshot.parameterKeys || []).sort();\n  const newParams = newNode.parameters || {};\n  const newParamsCopy = { ...newParams };\n  delete newParamsCopy._versionControl;\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // MINOR: Check parameter structure changes (array lengths, etc.)\n  if (oldSnapshot.parameterStructure && newParams) {\n    for (const key in oldSnapshot.parameterStructure) {\n      const oldStruct = oldSnapshot.parameterStructure[key];\n      const newParam = newParams[key];\n      \n      if (!newParam) continue; // Parameter was removed (caught above)\n      \n      // Check assignment count changes\n      if (oldStruct.assignmentCount !== undefined) {\n        const newCount = newParam.assignments?.length || 0;\n        if (oldStruct.assignmentCount !== newCount) {\n          const change = newCount > oldStruct.assignmentCount ? 'Added' : 'Removed';\n          const diff = Math.abs(newCount - oldStruct.assignmentCount);\n          return { \n            type: 'minor', \n            reason: `${change} ${diff} assignment${diff > 1 ? 's' : ''} in '${key}'`\n          };\n        }\n      }\n      \n      // Check array length changes\n      if (oldStruct.arrayLength !== undefined) {\n        const newLength = Array.isArray(newParam) ? newParam.length : 0;\n        if (oldStruct.arrayLength !== newLength) {\n          return { \n            type: 'minor', \n            reason: `Array '${key}' size changed: ${oldStruct.arrayLength} ‚Üí ${newLength}`\n          };\n        }\n      }\n      \n      // Check parameter count changes (like HTTP headers)\n      if (oldStruct.paramCount !== undefined) {\n        const newCount = newParam.parameters?.length || 0;\n        if (oldStruct.paramCount !== newCount) {\n          return { \n            type: 'minor', \n            reason: `Parameter count in '${key}' changed: ${oldStruct.paramCount} ‚Üí ${newCount}`\n          };\n        }\n      }\n    }\n  }\n  \n  // If keys are the same and structure unchanged, it's a PATCH (value change)\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const parts = (version || '1.0.0').split('.').map(Number);\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  const snapshot = {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n  \n  // Store array lengths for parameters that are arrays or contain arrays\n  // This helps detect adding/removing items (MINOR change)\n  if (node.parameters) {\n    snapshot.parameterStructure = {};\n    \n    for (const key of snapshot.parameterKeys) {\n      const param = node.parameters[key];\n      \n      if (param && typeof param === 'object') {\n        // Check for common n8n patterns\n        if (param.assignments && Array.isArray(param.assignments)) {\n          // Set/Edit Fields node with assignments\n          snapshot.parameterStructure[key] = {\n            assignmentCount: param.assignments.length\n          };\n        } else if (Array.isArray(param)) {\n          // Direct array parameter\n          snapshot.parameterStructure[key] = {\n            arrayLength: param.length\n          };\n        } else if (param.parameters && Array.isArray(param.parameters)) {\n          // HTTP Request headers/parameters\n          snapshot.parameterStructure[key] = {\n            paramCount: param.parameters.length\n          };\n        }\n      }\n    }\n  }\n  \n  return snapshot;\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const existingVersion = parseVersionFromNotes(node.notes);\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hashChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  // Check for name changes (MAJOR change that doesn't affect hash)\n  const nameChanged = storedSnapshot && storedSnapshot.name !== node.name;\n  \n  // Node has changed if hash OR name changed\n  const hasChanged = hashChanged || nameChanged;\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: config,\n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "326e8096",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 326e8096\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnMxNSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "3611b5bb-9f9a-4a6c-9ef5-86561a65f087",
      "name": "Respond to Webhook15",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        256,
        -14960
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2sxNSIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsib3B0aW9ucyIsInJlc3BvbmRXaXRoIiwicmVzcG9uc2VCb2R5Il0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "455df12e-7330-44e6-a20e-7de2836f51c2",
      "name": "Dry Run Response15",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -528,
        -14976
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'Dry run completed - no changes applied', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: { previous: data.workflowVersion.previous, wouldBecome: data.workflowVersion.current }, changes: data.nodeChanges, timestamp: data.timestamp, dryRun: true } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5226f176",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5226f176\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlMTUiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "a19a67ce-e712-47d2-ab0d-ced29d0b828c",
      "name": "Update Workflow with Versions15",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -640,
        -15568
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.config.n8nApiKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2b165197",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 2b165197\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnMxNSIsInR5cGVWZXJzaW9uIjo0LjIsInBhcmFtZXRlcktleXMiOlsiaGVhZGVyUGFyYW1ldGVycyIsImpzb25Cb2R5IiwibWV0aG9kIiwib3B0aW9ucyIsInNlbmRCb2R5Iiwic2VuZEhlYWRlcnMiLCJzcGVjaWZ5Qm9keSIsInVybCJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnsiaGVhZGVyUGFyYW1ldGVycyI6eyJwYXJhbUNvdW50IjoyfX19",
      "notesInFlow": true
    },
    {
      "id": "0b8c0057-d995-4e70-a36c-98c9e92e2c3e",
      "name": "Dry Run?15",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -768,
        -15056
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj8xNSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "2940abce-2543-44f5-a14a-0a89930285ca",
      "name": "No Changes Response15",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -416,
        -14704
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'No changes detected', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: data.workflowVersion.current, timestamp: data.timestamp } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3919f890",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3919f890\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlMTUiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "da00addf-bd36-4b5f-a214-390f9fbb5e65",
      "name": "Has Changes?15",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1056,
        -15040
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/MTUiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "57e905a0-2808-48be-87db-16e614dbfc09",
      "name": "Fetch Current Workflow15",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1424,
        -15040
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.n8nApiKey }}"
            }
          ]
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "22aea478",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 22aea478\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzE1IiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJoZWFkZXJQYXJhbWV0ZXJzIiwib3B0aW9ucyIsInNlbmRIZWFkZXJzIiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjF9fX0=",
      "notesInFlow": true
    },
    {
      "id": "95daaa50-1ea3-45d9-952b-84427f083776",
      "name": "Parse Configuration15",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1600,
        -15040
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\n// Configuration with defaults\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/data/workflow-backups',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupEnabled: input.localBackupEnabled ?? input.body?.localBackupEnabled ?? false,\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  localBackupMaxVersions: input.localBackupMaxVersions ?? input.body?.localBackupMaxVersions ?? 20,\n  cleanupOldBackupsEnabled: input.cleanupOldBackupsEnabled ?? input.body?.cleanupOldBackupsEnabled ?? false,\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl ||  'http://localhost:5678/api/v1',\n  n8nApiKey: input.n8nApiKey || input.body?.n8nApiKey || '',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null, // null = auto-generate\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nreturn { json: config };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "44b3eb33",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 44b3eb33\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uMTUiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "51cd4d35-42a4-4881-97cc-9fc6902d03cf",
      "name": "Cleanup Old Backups1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        752,
        -15280
      ],
      "parameters": {
        "jsCode": "// Cleanup Old Backups\n// Keep only newest N backups for the current workflow prefix.\n\nconst data = $input.first().json;\nconst config = data.config || {};\nconst cleanupEnabled = config.cleanupOldBackupsEnabled === true;\n\nif (!cleanupEnabled) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: false,\n      cleanupSkipped: true,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n    }\n  };\n}\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst backupDir = (data.backupDisplayPath || path.dirname(data.backupFullPath || '')).replace(/\\/+$/, '');\nconst currentFile = data.backupFilename || path.basename(data.backupFullPath || '');\nconst backupPrefix = data.backupPrefix || null;\n\nconst maxRaw = Number(config.localBackupMaxVersions ?? 20);\nconst maxVersions = Number.isFinite(maxRaw) ? Math.floor(maxRaw) : 20;\n\nfunction escapeRegex(value) {\n  return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction prefixFromFile(filename) {\n  const semverIndex = filename.indexOf('-v');\n  if (semverIndex > 0) return `${filename.slice(0, semverIndex)}-v`;\n  return null;\n}\n\nfunction getSortEpochMs(filename, fallbackMs) {\n  const match = filename.match(/-(\\d{4})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})\\.json$/);\n  if (!match) return fallbackMs;\n\n  const [, y, mo, d, h, mi, s] = match;\n  const dt = Date.UTC(Number(y), Number(mo) - 1, Number(d), Number(h), Number(mi), Number(s));\n  return Number.isFinite(dt) ? dt : fallbackMs;\n}\n\ntry {\n  if (!backupDir) {\n    return {\n      json: {\n        ...data,\n        cleanupEnabled: true,\n        cleanupSkipped: false,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Backup directory is missing.',\n      }\n    };\n  }\n\n  // Preserve the newest backup by default even if max is misconfigured.\n  const effectiveMax = maxVersions < 1 ? 1 : maxVersions;\n\n  const workflowPrefix = backupPrefix || prefixFromFile(currentFile);\n  if (!workflowPrefix) {\n    return {\n      json: {\n        ...data,\n        cleanupEnabled: true,\n        cleanupSkipped: false,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Unable to determine workflow backup prefix.',\n      }\n    };\n  }\n\n  const filePattern = new RegExp(\n    `^${escapeRegex(workflowPrefix)}\\\\d+\\\\.\\\\d+\\\\.\\\\d+-\\\\d{4}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}\\\\.json$`\n  );\n\n  const matchingFiles = fs\n    .readdirSync(backupDir, { withFileTypes: true })\n    .filter((entry) => entry.isFile())\n    .map((entry) => entry.name)\n    .filter((name) => filePattern.test(name))\n    .map((name) => {\n      const fullPath = path.join(backupDir, name);\n      const stats = fs.statSync(fullPath);\n      return {\n        name,\n        fullPath,\n        mtimeMs: stats.mtimeMs,\n        sortEpochMs: getSortEpochMs(name, stats.mtimeMs),\n      };\n    })\n    .sort((a, b) => {\n      if (a.sortEpochMs !== b.sortEpochMs) return a.sortEpochMs - b.sortEpochMs;\n      return a.mtimeMs - b.mtimeMs;\n    });\n\n  const deleteCount = Math.max(0, matchingFiles.length - effectiveMax);\n  const toDelete = matchingFiles.slice(0, deleteCount);\n\n  for (const file of toDelete) {\n    fs.unlinkSync(file.fullPath);\n  }\n\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: true,\n      cleanupPrefix: workflowPrefix,\n      cleanupMaxVersions: effectiveMax,\n      matchedBackups: matchingFiles.length,\n      deletedBackups: toDelete.length,\n      deletedFiles: toDelete.map((file) => file.name),\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n      backupCleanupError: error?.message || String(error),\n    }\n  };\n}\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "6c9b4b90",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 6c9b4b90\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDbGVhbnVwIE9sZCBCYWNrdXBzMSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "6fce0777-fe97-4ba2-9da7-0d6c2f7e8165",
      "name": "Mark Backup Complete4",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        384,
        -17392
      ],
      "parameters": {
        "jsCode": "// Mark Backup Complete\n\nconst data = $input.first().json;\n\nreturn {\n  json: {\n    ...data,\n    backupSaved: true,\n    backupTimestamp: new Date().toISOString(),\n    backupPath: data.backupFullPath || null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "84b988f",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 84b988f\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJNYXJrIEJhY2t1cCBDb21wbGV0ZTQiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "b0e3bd36-d07a-4b0b-afff-62eba076d202",
      "name": "Write Backup File4",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        192,
        -17392
      ],
      "parameters": {
        "fileName": "={{ $json.backupFullPath }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "20c20b9a",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1\nüîí Hash: 20c20b9a\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uud3JpdGVCaW5hcnlGaWxlIiwibmFtZSI6IldyaXRlIEJhY2t1cCBGaWxlNCIsInR5cGVWZXJzaW9uIjoxLCJwYXJhbWV0ZXJLZXlzIjpbImZpbGVOYW1lIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "c7f969fb-a78e-4cc3-b749-b5334476cc9d",
      "name": "Convert to Binary4",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        -17392
      ],
      "parameters": {
        "jsCode": "// Convert to Binary Data\n\nconst data = $input.first().json;\n\n// Convert JSON string to binary data\nconst binaryData = Buffer.from(data.workflowJson, 'utf-8');\n\nreturn {\n  json: data,\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'application/json',\n      fileName: data.backupFilename,\n      fileExtension: 'json'\n    }\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "792aa334",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 792aa334\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDb252ZXJ0IHRvIEJpbmFyeTQiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "4198bcd8-46db-4d68-8eea-a1b0107bfc32",
      "name": "Prepare Backup Data4",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -160,
        -17392
      ],
      "parameters": {
        "jsCode": "// Prepare Backup Data - Create filename and data\n\nconst data = $input.first().json;\nconst workflow = data.updatedWorkflow;\nconst version = data.workflowVersion.current;\nconst config = data.config;\n\n// Sanitize workflow name\nconst safeName = workflow.name\n  .replace(/\\s+/g, '_')\n  .replace(/[^a-zA-Z0-9_-]/g, '')\n  .substring(0, 50);\n\n// Generate human-readable timestamp\nconst now = new Date();\nconst year = now.getFullYear();\nconst month = String(now.getMonth() + 1).padStart(2, '0');\nconst day = String(now.getDate()).padStart(2, '0');\nconst hours = String(now.getHours()).padStart(2, '0');\nconst minutes = String(now.getMinutes()).padStart(2, '0');\nconst seconds = String(now.getSeconds()).padStart(2, '0');\n\nconst timestamp = `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;\n\nconst backupPrefix = `${safeName}-v`;\nconst filename = `${backupPrefix}${version}-${timestamp}.json`;\n\nlet backupDir = config.localBackupPath || '/tmp';\nif (backupDir.startsWith('~/')) {\n  const homeDir =\n    (typeof process !== 'undefined' && process.env && process.env.HOME)\n      ? process.env.HOME\n      : '/home/node';\n  backupDir = backupDir.replace(/^~(?=\\/)/, homeDir);\n}\n\nbackupDir = backupDir.replace(/\\/+$/, '') || '/tmp';\n\nreturn {\n  json: {\n    ...data,\n    backupPrefix,\n    backupFilename: filename,\n    backupDisplayPath: backupDir,\n    backupFullPath: `${backupDir}/${filename}`,\n    workflowJson: JSON.stringify(workflow, null, 2),\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "52eca43b",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 52eca43b\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcmVwYXJlIEJhY2t1cCBEYXRhNCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "9872d76b-f1e0-4717-98bf-c58e0fbc029d",
      "name": "Restore Data After Update6",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -480,
        -17264
      ],
      "parameters": {
        "jsCode": "// Restore Data After HTTP Request\n\n// Get the original data from Process Node Versions\nconst processData = $(\"Process Node Versions16\").first().json;\n\n// Get the HTTP response (current input)\nconst httpResponse = $input.first().json;\n\n// Merge them - keep all original data, add HTTP response\nreturn {\n  json: {\n    ...processData,\n    httpResponse: httpResponse,\n    workflowUpdated: true\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7b52e321",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 7b52e321\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJSZXN0b3JlIERhdGEgQWZ0ZXIgVXBkYXRlNiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "b2969d03-01c2-45f2-b6d7-aee44b54ad1c",
      "name": "Local Backup Enabled?7",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -320,
        -17264
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "local-backup-enabled",
              "leftValue": "={{ $json.config.localBackupEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "277dced1",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 277dced1\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiTG9jYWwgQmFja3VwIEVuYWJsZWQ/NyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "7ee06303-2a14-46af-8cc5-e72a83745814",
      "name": "Build Success Response16",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        976,
        -17232
      ],
      "parameters": {
        "jsCode": "// Build Success Response\n// Merge original process data with latest branch data so backup/cleanup fields are preserved.\n\nconst processData = $(\"Process Node Versions16\").first().json;\nconst latestData = $input.first().json;\nconst data = {\n  ...processData,\n  ...latestData,\n};\n\nconst cleanupEnabled = data.cleanupEnabled ?? (data.config?.cleanupOldBackupsEnabled ?? false);\n\nconst summary = {\n  success: true,\n  message: data.hasChanges\n    ? `‚úÖ Version control updated: ${data.nodeChanges.length} node${data.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId: data.config?.workflowId || 'unknown',\n  workflowName: data.updatedWorkflow?.name || data.originalWorkflow?.name || 'Unknown',\n  hasChanges: data.hasChanges || false,\n  nodeChanges: data.nodeChanges || [],\n  originalWorkflow: data.originalWorkflow,\n  updatedWorkflow: data.updatedWorkflow,\n  workflowVersion: data.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp: data.timestamp || new Date().toISOString(),\n  dryRun: false,\n};\n\nif (data.backupSaved !== undefined) {\n  summary.backup = {\n    saved: data.backupSaved,\n    filename: data.backupFilename || null,\n    path: data.backupPath || null,\n    error: data.backupError || data.backupCleanupError || null,\n    cleanup: {\n      enabled: cleanupEnabled,\n      performed: data.cleanupPerformed || false,\n      skipped: data.cleanupSkipped || false,\n      deleted: data.deletedBackups || 0,\n      files: data.deletedFiles || [],\n      prefix: data.cleanupPrefix || null,\n      matchedBackups: data.matchedBackups || 0,\n      maxVersions: data.cleanupMaxVersions ?? null,\n    },\n  };\n}\n\nreturn { json: summary };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "d4216cf",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: d4216cf\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlMTYiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "1078c576-2741-412f-ad6f-3a088d7cb560",
      "name": "Process Node Versions16",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1168,
        -17632
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\nconst config = $(\"Parse Configuration16\").first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldSnapshot, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldSnapshot) return { type: 'major', reason: 'New node' };\n  \n  // MAJOR: Node type changed\n  if (oldSnapshot.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldSnapshot.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldSnapshot.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldSnapshot.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Compare parameter keys (what we have in snapshot)\n  const oldKeys = (oldSnapshot.parameterKeys || []).sort();\n  const newParams = newNode.parameters || {};\n  const newParamsCopy = { ...newParams };\n  delete newParamsCopy._versionControl;\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // MINOR: Check parameter structure changes (array lengths, etc.)\n  if (oldSnapshot.parameterStructure && newParams) {\n    for (const key in oldSnapshot.parameterStructure) {\n      const oldStruct = oldSnapshot.parameterStructure[key];\n      const newParam = newParams[key];\n      \n      if (!newParam) continue; // Parameter was removed (caught above)\n      \n      // Check assignment count changes\n      if (oldStruct.assignmentCount !== undefined) {\n        const newCount = newParam.assignments?.length || 0;\n        if (oldStruct.assignmentCount !== newCount) {\n          const change = newCount > oldStruct.assignmentCount ? 'Added' : 'Removed';\n          const diff = Math.abs(newCount - oldStruct.assignmentCount);\n          return { \n            type: 'minor', \n            reason: `${change} ${diff} assignment${diff > 1 ? 's' : ''} in '${key}'`\n          };\n        }\n      }\n      \n      // Check array length changes\n      if (oldStruct.arrayLength !== undefined) {\n        const newLength = Array.isArray(newParam) ? newParam.length : 0;\n        if (oldStruct.arrayLength !== newLength) {\n          return { \n            type: 'minor', \n            reason: `Array '${key}' size changed: ${oldStruct.arrayLength} ‚Üí ${newLength}`\n          };\n        }\n      }\n      \n      // Check parameter count changes (like HTTP headers)\n      if (oldStruct.paramCount !== undefined) {\n        const newCount = newParam.parameters?.length || 0;\n        if (oldStruct.paramCount !== newCount) {\n          return { \n            type: 'minor', \n            reason: `Parameter count in '${key}' changed: ${oldStruct.paramCount} ‚Üí ${newCount}`\n          };\n        }\n      }\n    }\n  }\n  \n  // If keys are the same and structure unchanged, it's a PATCH (value change)\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const parts = (version || '1.0.0').split('.').map(Number);\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  const snapshot = {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n  \n  // Store array lengths for parameters that are arrays or contain arrays\n  // This helps detect adding/removing items (MINOR change)\n  if (node.parameters) {\n    snapshot.parameterStructure = {};\n    \n    for (const key of snapshot.parameterKeys) {\n      const param = node.parameters[key];\n      \n      if (param && typeof param === 'object') {\n        // Check for common n8n patterns\n        if (param.assignments && Array.isArray(param.assignments)) {\n          // Set/Edit Fields node with assignments\n          snapshot.parameterStructure[key] = {\n            assignmentCount: param.assignments.length\n          };\n        } else if (Array.isArray(param)) {\n          // Direct array parameter\n          snapshot.parameterStructure[key] = {\n            arrayLength: param.length\n          };\n        } else if (param.parameters && Array.isArray(param.parameters)) {\n          // HTTP Request headers/parameters\n          snapshot.parameterStructure[key] = {\n            paramCount: param.parameters.length\n          };\n        }\n      }\n    }\n  }\n  \n  return snapshot;\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const existingVersion = parseVersionFromNotes(node.notes);\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hashChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  // Check for name changes (MAJOR change that doesn't affect hash)\n  const nameChanged = storedSnapshot && storedSnapshot.name !== node.name;\n  \n  // Node has changed if hash OR name changed\n  const hasChanged = hashChanged || nameChanged;\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: config,\n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "33879775",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 33879775\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnMxNiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "63e0214f-3179-493b-bccd-9598f2e86420",
      "name": "Respond to Webhook16",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        -192,
        -17568
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2sxNiIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsib3B0aW9ucyIsInJlc3BvbmRXaXRoIiwicmVzcG9uc2VCb2R5Il0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "4df3a078-aa7a-4974-ad7b-c59f10bccbdb",
      "name": "Dry Run Response16",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -480,
        -17568
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'Dry run completed - no changes applied', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: { previous: data.workflowVersion.previous, wouldBecome: data.workflowVersion.current }, changes: data.nodeChanges, timestamp: data.timestamp, dryRun: true } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5226f176",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5226f176\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlMTYiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "a20014dd-37c7-4db8-b43e-566130e47eeb",
      "name": "Update Workflow with Versions16",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -624,
        -17264
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-KEY",
              "value": "={{ $json.config.n8nApiKey }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2b165197",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 2b165197\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnMxNiIsInR5cGVWZXJzaW9uIjo0LjIsInBhcmFtZXRlcktleXMiOlsiaGVhZGVyUGFyYW1ldGVycyIsImpzb25Cb2R5IiwibWV0aG9kIiwib3B0aW9ucyIsInNlbmRCb2R5Iiwic2VuZEhlYWRlcnMiLCJzcGVjaWZ5Qm9keSIsInVybCJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnsiaGVhZGVyUGFyYW1ldGVycyI6eyJwYXJhbUNvdW50IjoyfX19",
      "notesInFlow": true
    },
    {
      "id": "602506a8-7319-4270-a652-e4dd2688ece7",
      "name": "Dry Run?16",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -720,
        -17648
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj8xNiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "2b07f950-997e-49c5-9663-624fb08a131f",
      "name": "No Changes Response16",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1040,
        -17376
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'No changes detected', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: data.workflowVersion.current, timestamp: data.timestamp } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3919f890",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3919f890\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlMTYiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "25148f4a-d60b-479b-b055-bd293e81bd8c",
      "name": "Has Changes?16",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1008,
        -17632
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/MTYiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "909f200d-7dac-4f8c-97d9-c6ad92f1a779",
      "name": "Fetch Current Workflow16",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1376,
        -17632
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {}
          ]
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "51d46c6a",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 51d46c6a\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzE2IiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJhdXRoZW50aWNhdGlvbiIsImdlbmVyaWNBdXRoVHlwZSIsImhlYWRlclBhcmFtZXRlcnMiLCJvcHRpb25zIiwic2VuZEhlYWRlcnMiLCJ1cmwiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7ImhlYWRlclBhcmFtZXRlcnMiOnsicGFyYW1Db3VudCI6MX19fQ==",
      "notesInFlow": true
    },
    {
      "id": "cff1ef08-6e81-4415-bfc2-2105f491bd98",
      "name": "Parse Configuration16",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1552,
        -17632
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\n// Configuration with defaults\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/data/workflow-backups',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupEnabled: input.localBackupEnabled ?? input.body?.localBackupEnabled ?? false,\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  localBackupMaxVersions: input.localBackupMaxVersions ?? input.body?.localBackupMaxVersions ?? 20,\n  cleanupOldBackupsEnabled: input.cleanupOldBackupsEnabled ?? input.body?.cleanupOldBackupsEnabled ?? false,\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl ||  'http://localhost:5678/api/v1',\n  n8nApiKey: input.n8nApiKey || input.body?.n8nApiKey || '',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null, // null = auto-generate\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nreturn { json: config };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "44b3eb33",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 44b3eb33\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uMTYiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "bf522b59-96b0-417f-a5ca-e33749b437ab",
      "name": "Cleanup Old Backups2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        848,
        -17408
      ],
      "parameters": {
        "jsCode": "// Cleanup Old Backups\n// Keep only newest N backups for the current workflow prefix.\n\nconst data = $input.first().json;\nconst config = data.config || {};\nconst cleanupEnabled = config.cleanupOldBackupsEnabled === true;\n\nif (!cleanupEnabled) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: false,\n      cleanupSkipped: true,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n    }\n  };\n}\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst backupDir = (data.backupDisplayPath || path.dirname(data.backupFullPath || '')).replace(/\\/+$/, '');\nconst currentFile = data.backupFilename || path.basename(data.backupFullPath || '');\nconst backupPrefix = data.backupPrefix || null;\n\nconst maxRaw = Number(config.localBackupMaxVersions ?? 20);\nconst maxVersions = Number.isFinite(maxRaw) ? Math.floor(maxRaw) : 20;\n\nfunction escapeRegex(value) {\n  return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction prefixFromFile(filename) {\n  const semverIndex = filename.indexOf('-v');\n  if (semverIndex > 0) return `${filename.slice(0, semverIndex)}-v`;\n  return null;\n}\n\nfunction getSortEpochMs(filename, fallbackMs) {\n  const match = filename.match(/-(\\d{4})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})\\.json$/);\n  if (!match) return fallbackMs;\n\n  const [, y, mo, d, h, mi, s] = match;\n  const dt = Date.UTC(Number(y), Number(mo) - 1, Number(d), Number(h), Number(mi), Number(s));\n  return Number.isFinite(dt) ? dt : fallbackMs;\n}\n\ntry {\n  if (!backupDir) {\n    return {\n      json: {\n        ...data,\n        cleanupEnabled: true,\n        cleanupSkipped: false,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Backup directory is missing.',\n      }\n    };\n  }\n\n  // Preserve the newest backup by default even if max is misconfigured.\n  const effectiveMax = maxVersions < 1 ? 1 : maxVersions;\n\n  const workflowPrefix = backupPrefix || prefixFromFile(currentFile);\n  if (!workflowPrefix) {\n    return {\n      json: {\n        ...data,\n        cleanupEnabled: true,\n        cleanupSkipped: false,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Unable to determine workflow backup prefix.',\n      }\n    };\n  }\n\n  const filePattern = new RegExp(\n    `^${escapeRegex(workflowPrefix)}\\\\d+\\\\.\\\\d+\\\\.\\\\d+-\\\\d{4}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}\\\\.json$`\n  );\n\n  const matchingFiles = fs\n    .readdirSync(backupDir, { withFileTypes: true })\n    .filter((entry) => entry.isFile())\n    .map((entry) => entry.name)\n    .filter((name) => filePattern.test(name))\n    .map((name) => {\n      const fullPath = path.join(backupDir, name);\n      const stats = fs.statSync(fullPath);\n      return {\n        name,\n        fullPath,\n        mtimeMs: stats.mtimeMs,\n        sortEpochMs: getSortEpochMs(name, stats.mtimeMs),\n      };\n    })\n    .sort((a, b) => {\n      if (a.sortEpochMs !== b.sortEpochMs) return a.sortEpochMs - b.sortEpochMs;\n      return a.mtimeMs - b.mtimeMs;\n    });\n\n  const deleteCount = Math.max(0, matchingFiles.length - effectiveMax);\n  const toDelete = matchingFiles.slice(0, deleteCount);\n\n  for (const file of toDelete) {\n    fs.unlinkSync(file.fullPath);\n  }\n\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: true,\n      cleanupPrefix: workflowPrefix,\n      cleanupMaxVersions: effectiveMax,\n      matchedBackups: matchingFiles.length,\n      deletedBackups: toDelete.length,\n      deletedFiles: toDelete.map((file) => file.name),\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n      backupCleanupError: error?.message || String(error),\n    }\n  };\n}\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "6c9b4b90",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 6c9b4b90\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDbGVhbnVwIE9sZCBCYWNrdXBzMiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "c716cc73-9730-45e8-983b-fc44ffb3c10c",
      "name": "Delete Old Backups Enabled?1",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        576,
        -17392
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "cleanup-old-backups-enabled",
              "leftValue": "={{ $json.config.cleanupOldBackupsEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "47bddea4",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 47bddea4\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRGVsZXRlIE9sZCBCYWNrdXBzIEVuYWJsZWQ/MSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "df1ff188-0ba7-4ec1-ac10-9eee65dd8b97",
      "name": "Mark Backup Complete5",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        176,
        -18768
      ],
      "parameters": {
        "jsCode": "// Mark Backup Complete\n\nconst data = $input.first().json;\n\nreturn {\n  json: {\n    ...data,\n    backupSaved: true,\n    backupTimestamp: new Date().toISOString(),\n    backupPath: data.backupFullPath || null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "84b988f",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 84b988f\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJNYXJrIEJhY2t1cCBDb21wbGV0ZTUiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "6738a52f-113c-437d-b87e-e15be257407a",
      "name": "Write Backup File5",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        0,
        -18768
      ],
      "parameters": {
        "fileName": "={{ $json.backupFullPath }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "20c20b9a",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1\nüîí Hash: 20c20b9a\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uud3JpdGVCaW5hcnlGaWxlIiwibmFtZSI6IldyaXRlIEJhY2t1cCBGaWxlNSIsInR5cGVWZXJzaW9uIjoxLCJwYXJhbWV0ZXJLZXlzIjpbImZpbGVOYW1lIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "f24b30b1-5dc0-48c6-a88a-163883197a5f",
      "name": "Convert to Binary5",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -176,
        -18768
      ],
      "parameters": {
        "jsCode": "// Convert to Binary Data\n\nconst data = $input.first().json;\n\n// Convert JSON string to binary data\nconst binaryData = Buffer.from(data.workflowJson, 'utf-8');\n\nreturn {\n  json: data,\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'application/json',\n      fileName: data.backupFilename,\n      fileExtension: 'json'\n    }\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "792aa334",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 792aa334\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDb252ZXJ0IHRvIEJpbmFyeTUiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "7cb0a30a-0da9-47ed-81db-2b08537d51c3",
      "name": "Prepare Backup Data5",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -368,
        -18768
      ],
      "parameters": {
        "jsCode": "// Prepare Backup Data - Create filename and data\n\nconst data = $input.first().json;\nconst workflow = data.updatedWorkflow;\nconst version = data.workflowVersion.current;\nconst config = data.config;\n\n// Sanitize workflow name\nconst safeName = workflow.name\n  .replace(/\\s+/g, '_')\n  .replace(/[^a-zA-Z0-9_-]/g, '')\n  .substring(0, 50);\n\n// Generate human-readable timestamp\nconst now = new Date();\nconst year = now.getFullYear();\nconst month = String(now.getMonth() + 1).padStart(2, '0');\nconst day = String(now.getDate()).padStart(2, '0');\nconst hours = String(now.getHours()).padStart(2, '0');\nconst minutes = String(now.getMinutes()).padStart(2, '0');\nconst seconds = String(now.getSeconds()).padStart(2, '0');\n\nconst timestamp = `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;\n\nconst backupPrefix = `${safeName}-v`;\nconst filename = `${backupPrefix}${version}-${timestamp}.json`;\n\nlet backupDir = config.localBackupPath || '/tmp';\nif (backupDir.startsWith('~/')) {\n  const homeDir =\n    (typeof process !== 'undefined' && process.env && process.env.HOME)\n      ? process.env.HOME\n      : '/home/node';\n  backupDir = backupDir.replace(/^~(?=\\/)/, homeDir);\n}\n\nbackupDir = backupDir.replace(/\\/+$/, '') || '/tmp';\n\nreturn {\n  json: {\n    ...data,\n    backupPrefix,\n    backupFilename: filename,\n    backupDisplayPath: backupDir,\n    backupFullPath: `${backupDir}/${filename}`,\n    workflowJson: JSON.stringify(workflow, null, 2),\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "52eca43b",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 52eca43b\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcmVwYXJlIEJhY2t1cCBEYXRhNSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "0871bc43-cf66-483f-bfc0-b1a5bb8c687f",
      "name": "Restore Data After Update7",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -560,
        -19072
      ],
      "parameters": {
        "jsCode": "// Restore Data After HTTP Request\n\n// Get the original data from Process Node Versions\nconst processData = $(\"Process Node Versions17\").first().json;\n\n// Get the HTTP response (current input)\nconst httpResponse = $input.first().json;\n\n// Merge them - keep all original data, add HTTP response\nreturn {\n  json: {\n    ...processData,\n    httpResponse: httpResponse,\n    workflowUpdated: true\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7bcfe60",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 7bcfe60\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJSZXN0b3JlIERhdGEgQWZ0ZXIgVXBkYXRlNyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "caf71d43-b88d-441a-9489-188394058640",
      "name": "Local Backup Enabled?8",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -336,
        -19072
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "local-backup-enabled",
              "leftValue": "={{ $json.config.localBackupEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "277dced1",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 277dced1\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiTG9jYWwgQmFja3VwIEVuYWJsZWQ/OCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "2ee71771-7237-4177-a0c3-ac8bd1b0f9ad",
      "name": "Build Success Response17",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        864,
        -19072
      ],
      "parameters": {
        "jsCode": "// Build Success Response\n// Merge original process data with latest branch data so backup/cleanup fields are preserved.\n\nconst processData = $(\"Process Node Versions17\").first().json;\nconst latestData = $input.first().json;\nconst data = {\n  ...processData,\n  ...latestData,\n};\n\nconst cleanupEnabled = data.cleanupEnabled ?? (data.config?.cleanupOldBackupsEnabled ?? false);\n\nconst summary = {\n  success: true,\n  message: data.hasChanges\n    ? `‚úÖ Version control updated: ${data.nodeChanges.length} node${data.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId: data.config?.workflowId || 'unknown',\n  workflowName: data.updatedWorkflow?.name || data.originalWorkflow?.name || 'Unknown',\n  hasChanges: data.hasChanges || false,\n  nodeChanges: data.nodeChanges || [],\n  originalWorkflow: data.originalWorkflow,\n  updatedWorkflow: data.updatedWorkflow,\n  workflowVersion: data.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp: data.timestamp || new Date().toISOString(),\n  dryRun: false,\n};\n\nif (data.backupSaved !== undefined) {\n  summary.backup = {\n    saved: data.backupSaved,\n    filename: data.backupFilename || null,\n    path: data.backupPath || null,\n    error: data.backupError || data.backupCleanupError || null,\n    cleanup: {\n      enabled: cleanupEnabled,\n      performed: data.cleanupPerformed || false,\n      skipped: data.cleanupSkipped || false,\n      deleted: data.deletedBackups || 0,\n      files: data.deletedFiles || [],\n      prefix: data.cleanupPrefix || null,\n      matchedBackups: data.matchedBackups || 0,\n      maxVersions: data.cleanupMaxVersions ?? null,\n    },\n  };\n}\n\nreturn { json: summary };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "76cbc30",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 76cbc30\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlMTciLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "582cbc60-6cf4-4b94-baad-991de0059696",
      "name": "Process Node Versions17",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1408,
        -18656
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\nconst config = $(\"Parse Configuration17\").first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldSnapshot, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldSnapshot) return { type: 'major', reason: 'New node' };\n  \n  // MAJOR: Node type changed\n  if (oldSnapshot.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldSnapshot.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldSnapshot.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldSnapshot.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Compare parameter keys (what we have in snapshot)\n  const oldKeys = (oldSnapshot.parameterKeys || []).sort();\n  const newParams = newNode.parameters || {};\n  const newParamsCopy = { ...newParams };\n  delete newParamsCopy._versionControl;\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // MINOR: Check parameter structure changes (array lengths, etc.)\n  if (oldSnapshot.parameterStructure && newParams) {\n    for (const key in oldSnapshot.parameterStructure) {\n      const oldStruct = oldSnapshot.parameterStructure[key];\n      const newParam = newParams[key];\n      \n      if (!newParam) continue; // Parameter was removed (caught above)\n      \n      // Check assignment count changes\n      if (oldStruct.assignmentCount !== undefined) {\n        const newCount = newParam.assignments?.length || 0;\n        if (oldStruct.assignmentCount !== newCount) {\n          const change = newCount > oldStruct.assignmentCount ? 'Added' : 'Removed';\n          const diff = Math.abs(newCount - oldStruct.assignmentCount);\n          return { \n            type: 'minor', \n            reason: `${change} ${diff} assignment${diff > 1 ? 's' : ''} in '${key}'`\n          };\n        }\n      }\n      \n      // Check array length changes\n      if (oldStruct.arrayLength !== undefined) {\n        const newLength = Array.isArray(newParam) ? newParam.length : 0;\n        if (oldStruct.arrayLength !== newLength) {\n          return { \n            type: 'minor', \n            reason: `Array '${key}' size changed: ${oldStruct.arrayLength} ‚Üí ${newLength}`\n          };\n        }\n      }\n      \n      // Check parameter count changes (like HTTP headers)\n      if (oldStruct.paramCount !== undefined) {\n        const newCount = newParam.parameters?.length || 0;\n        if (oldStruct.paramCount !== newCount) {\n          return { \n            type: 'minor', \n            reason: `Parameter count in '${key}' changed: ${oldStruct.paramCount} ‚Üí ${newCount}`\n          };\n        }\n      }\n    }\n  }\n  \n  // If keys are the same and structure unchanged, it's a PATCH (value change)\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const rawParts = String(version || '1.0.0').split('.').map(part => Number(part));\n  const parts = [\n    Number.isFinite(rawParts[0]) ? rawParts[0] : 1,\n    Number.isFinite(rawParts[1]) ? rawParts[1] : 0,\n    Number.isFinite(rawParts[2]) ? rawParts[2] : 0,\n  ];\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  const snapshot = {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n  \n  // Store array lengths for parameters that are arrays or contain arrays\n  // This helps detect adding/removing items (MINOR change)\n  if (node.parameters) {\n    snapshot.parameterStructure = {};\n    \n    for (const key of snapshot.parameterKeys) {\n      const param = node.parameters[key];\n      \n      if (param && typeof param === 'object') {\n        // Check for common n8n patterns\n        if (param.assignments && Array.isArray(param.assignments)) {\n          // Set/Edit Fields node with assignments\n          snapshot.parameterStructure[key] = {\n            assignmentCount: param.assignments.length\n          };\n        } else if (Array.isArray(param)) {\n          // Direct array parameter\n          snapshot.parameterStructure[key] = {\n            arrayLength: param.length\n          };\n        } else if (param.parameters && Array.isArray(param.parameters)) {\n          // HTTP Request headers/parameters\n          snapshot.parameterStructure[key] = {\n            paramCount: param.parameters.length\n          };\n        }\n      }\n    }\n  }\n  \n  return snapshot;\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const parsedExistingVersion = parseVersionFromNotes(node.notes);\n  const existingVersion = parsedExistingVersion && parsedExistingVersion.version\n    ? parsedExistingVersion\n    : {\n      version: '1.0.0',\n      created: timestamp,\n      lastModified: timestamp\n    };\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hashChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  // Check for name changes (MAJOR change that doesn't affect hash)\n  const nameChanged = storedSnapshot && storedSnapshot.name !== node.name;\n  \n  // Node has changed if hash OR name changed\n  const hasChanged = hashChanged || nameChanged;\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: config,\n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2855233d",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2855233d\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnMxNyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "27a73bca-e604-422b-b1a3-a64ea67a003b",
      "name": "Respond to Webhook17",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        64,
        -18464
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2sxNyIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsib3B0aW9ucyIsInJlc3BvbmRXaXRoIiwicmVzcG9uc2VCb2R5Il0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "9a613904-a2e0-4189-9b54-3b8fddd79521",
      "name": "Dry Run Response17",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -720,
        -18480
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'Dry run completed - no changes applied', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: { previous: data.workflowVersion.previous, wouldBecome: data.workflowVersion.current }, changes: data.nodeChanges, timestamp: data.timestamp, dryRun: true } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5226f176",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5226f176\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlMTciLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "a5d890f8-0221-46c7-9730-6d29d7fbbff8",
      "name": "Update Workflow with Versions17",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -832,
        -19072
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1747da31",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 1747da31\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnMxNyIsInR5cGVWZXJzaW9uIjo0LjIsInBhcmFtZXRlcktleXMiOlsiYXV0aGVudGljYXRpb24iLCJnZW5lcmljQXV0aFR5cGUiLCJoZWFkZXJQYXJhbWV0ZXJzIiwianNvbkJvZHkiLCJtZXRob2QiLCJvcHRpb25zIiwic2VuZEJvZHkiLCJzZW5kSGVhZGVycyIsInNwZWNpZnlCb2R5IiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjF9fX0=",
      "notesInFlow": true
    },
    {
      "id": "19f16ab2-f550-4888-b764-875d36c3b5b9",
      "name": "Dry Run?17",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -960,
        -18560
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj8xNyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "b5e13574-866e-473d-8b01-39a278624337",
      "name": "No Changes Response17",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -608,
        -18208
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nreturn { json: { success: true, message: 'No changes detected', workflowId: data.config.workflowId, workflowName: data.originalWorkflow.name, version: data.workflowVersion.current, timestamp: data.timestamp } };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3919f890",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3919f890\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlMTciLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "25da019e-35c4-4ddf-bc05-4a081a741d2e",
      "name": "Has Changes?17",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1248,
        -18544
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/MTciLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "9ac99372-1472-40ac-83e4-d156574ed880",
      "name": "Fetch Current Workflow17",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1616,
        -18544
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7ffe44bb",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 7ffe44bb\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzE3IiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJhdXRoZW50aWNhdGlvbiIsImdlbmVyaWNBdXRoVHlwZSIsIm9wdGlvbnMiLCJ1cmwiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "55b4fe74-ee07-43da-9f1a-feee9fe4c0ee",
      "name": "Parse Configuration17",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1792,
        -18544
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\n// Configuration with defaults\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/data/workflow-backups',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupEnabled: input.localBackupEnabled ?? input.body?.localBackupEnabled ?? false,\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  localBackupMaxVersions: input.localBackupMaxVersions ?? input.body?.localBackupMaxVersions ?? 20,\n  cleanupOldBackupsEnabled: input.cleanupOldBackupsEnabled ?? input.body?.cleanupOldBackupsEnabled ?? false,\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl ||  'http://localhost:5678/api/v1',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null, // null = auto-generate\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nreturn { json: config };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2e2e397",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2e2e397\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uMTciLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "e0ad7441-01c7-456b-ace1-0daab9ac647a",
      "name": "Cleanup Old Backups3",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        560,
        -18784
      ],
      "parameters": {
        "jsCode": "// Cleanup Old Backups\n// Keep only newest N backups for the current workflow prefix.\n\nconst data = $input.first().json;\nconst config = data.config || {};\nconst cleanupEnabled = config.cleanupOldBackupsEnabled === true;\n\nif (!cleanupEnabled) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: false,\n      cleanupSkipped: true,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n    }\n  };\n}\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst backupDir = (data.backupDisplayPath || path.dirname(data.backupFullPath || '')).replace(/\\/+$/, '');\nconst currentFile = data.backupFilename || path.basename(data.backupFullPath || '');\nconst backupPrefix = data.backupPrefix || null;\n\nconst maxRaw = Number(config.localBackupMaxVersions ?? 20);\nconst maxVersions = Number.isFinite(maxRaw) ? Math.floor(maxRaw) : 20;\n\nfunction escapeRegex(value) {\n  return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction prefixFromFile(filename) {\n  const semverIndex = filename.indexOf('-v');\n  if (semverIndex > 0) return `${filename.slice(0, semverIndex)}-v`;\n  return null;\n}\n\nfunction getSortEpochMs(filename, fallbackMs) {\n  const match = filename.match(/-(\\d{4})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})\\.json$/);\n  if (!match) return fallbackMs;\n\n  const [, y, mo, d, h, mi, s] = match;\n  const dt = Date.UTC(Number(y), Number(mo) - 1, Number(d), Number(h), Number(mi), Number(s));\n  return Number.isFinite(dt) ? dt : fallbackMs;\n}\n\ntry {\n  if (!backupDir) {\n    return {\n      json: {\n        ...data,\n        cleanupEnabled: true,\n        cleanupSkipped: false,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Backup directory is missing.',\n      }\n    };\n  }\n\n  // Preserve the newest backup by default even if max is misconfigured.\n  const effectiveMax = maxVersions < 1 ? 1 : maxVersions;\n\n  const workflowPrefix = backupPrefix || prefixFromFile(currentFile);\n  if (!workflowPrefix) {\n    return {\n      json: {\n        ...data,\n        cleanupEnabled: true,\n        cleanupSkipped: false,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Unable to determine workflow backup prefix.',\n      }\n    };\n  }\n\n  const filePattern = new RegExp(\n    `^${escapeRegex(workflowPrefix)}\\\\d+\\\\.\\\\d+\\\\.\\\\d+-\\\\d{4}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}\\\\.json$`\n  );\n\n  const matchingFiles = fs\n    .readdirSync(backupDir, { withFileTypes: true })\n    .filter((entry) => entry.isFile())\n    .map((entry) => entry.name)\n    .filter((name) => filePattern.test(name))\n    .map((name) => {\n      const fullPath = path.join(backupDir, name);\n      const stats = fs.statSync(fullPath);\n      return {\n        name,\n        fullPath,\n        mtimeMs: stats.mtimeMs,\n        sortEpochMs: getSortEpochMs(name, stats.mtimeMs),\n      };\n    })\n    .sort((a, b) => {\n      if (a.sortEpochMs !== b.sortEpochMs) return a.sortEpochMs - b.sortEpochMs;\n      return a.mtimeMs - b.mtimeMs;\n    });\n\n  const deleteCount = Math.max(0, matchingFiles.length - effectiveMax);\n  const toDelete = matchingFiles.slice(0, deleteCount);\n\n  for (const file of toDelete) {\n    fs.unlinkSync(file.fullPath);\n  }\n\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: true,\n      cleanupPrefix: workflowPrefix,\n      cleanupMaxVersions: effectiveMax,\n      matchedBackups: matchingFiles.length,\n      deletedBackups: toDelete.length,\n      deletedFiles: toDelete.map((file) => file.name),\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n      backupCleanupError: error?.message || String(error),\n    }\n  };\n}\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "6c9b4b90",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 6c9b4b90\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDbGVhbnVwIE9sZCBCYWNrdXBzMyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "125edf1b-6363-4830-b7ba-602e0e081587",
      "name": "Delete Old Backups Enabled?2",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        336,
        -18768
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "cleanup-old-backups-enabled",
              "leftValue": "={{ $json.config.cleanupOldBackupsEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "47bddea4",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 47bddea4\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRGVsZXRlIE9sZCBCYWNrdXBzIEVuYWJsZWQ/MiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "2f128c3c-c248-4906-a453-1a1f6f64f245",
      "name": "Mark Backup Complete6",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        640,
        -20048
      ],
      "parameters": {
        "jsCode": "// Mark Backup Complete\n\nconst data = $input.first().json;\n\nreturn {\n  json: {\n    ...data,\n    backupSaved: true,\n    backupTimestamp: new Date().toISOString(),\n    backupPath: data.backupFullPath || null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "84b988f",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 84b988f\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJNYXJrIEJhY2t1cCBDb21wbGV0ZTYiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "3f596f8f-83c2-402b-90de-36ec3cd73f36",
      "name": "Write Backup File6",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        464,
        -20048
      ],
      "parameters": {
        "fileName": "={{ $json.backupFullPath }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "20c20b9a",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1\nüîí Hash: 20c20b9a\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uud3JpdGVCaW5hcnlGaWxlIiwibmFtZSI6IldyaXRlIEJhY2t1cCBGaWxlNiIsInR5cGVWZXJzaW9uIjoxLCJwYXJhbWV0ZXJLZXlzIjpbImZpbGVOYW1lIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "e1466729-c16f-4976-9129-6c6aa0836df5",
      "name": "Convert to Binary6",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        288,
        -20048
      ],
      "parameters": {
        "jsCode": "// Convert to Binary Data\n\nconst data = $input.first().json;\n\n// Convert JSON string to binary data\nconst binaryData = Buffer.from(data.workflowJson, 'utf-8');\n\nreturn {\n  json: data,\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'application/json',\n      fileName: data.backupFilename,\n      fileExtension: 'json'\n    }\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "792aa334",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 792aa334\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDb252ZXJ0IHRvIEJpbmFyeTYiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "48bf4aa1-8547-48d8-882c-0fb560b2f088",
      "name": "Prepare Backup Data6",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        96,
        -20048
      ],
      "parameters": {
        "jsCode": "// Prepare Backup Data - Create filename and data\n\nconst data = $input.first().json;\nconst workflow = data.updatedWorkflow;\nconst version = data.workflowVersion.current;\nconst config = data.config;\n\n// Sanitize workflow name\nconst safeName = workflow.name\n  .replace(/\\s+/g, '_')\n  .replace(/[^a-zA-Z0-9_-]/g, '')\n  .substring(0, 50);\n\n// Generate human-readable timestamp\nconst now = new Date();\nconst year = now.getFullYear();\nconst month = String(now.getMonth() + 1).padStart(2, '0');\nconst day = String(now.getDate()).padStart(2, '0');\nconst hours = String(now.getHours()).padStart(2, '0');\nconst minutes = String(now.getMinutes()).padStart(2, '0');\nconst seconds = String(now.getSeconds()).padStart(2, '0');\n\nconst timestamp = `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;\n\nconst backupPrefix = `${safeName}-v`;\nconst filename = `${backupPrefix}${version}-${timestamp}.json`;\n\nlet backupDir = config.localBackupPath || '/tmp';\nif (backupDir.startsWith('~/')) {\n  const homeDir =\n    (typeof process !== 'undefined' && process.env && process.env.HOME)\n      ? process.env.HOME\n      : '/home/node';\n  backupDir = backupDir.replace(/^~(?=\\/)/, homeDir);\n}\n\nbackupDir = backupDir.replace(/\\/+$/, '') || '/tmp';\n\nreturn {\n  json: {\n    ...data,\n    backupPrefix,\n    backupFilename: filename,\n    backupDisplayPath: backupDir,\n    backupFullPath: `${backupDir}/${filename}`,\n    workflowJson: JSON.stringify(workflow, null, 2),\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "52eca43b",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 52eca43b\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcmVwYXJlIEJhY2t1cCBEYXRhNiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "9e2386ef-7e2f-4ae5-b200-da445dab548e",
      "name": "Restore Data After Update8",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -96,
        -20352
      ],
      "parameters": {
        "jsCode": "// Restore Data After HTTP Request\n\n// Get the original data from Process Node Versions\nconst processData = $(\"Process Node Versions18\").first().json;\n\n// Get the HTTP response (current input)\nconst httpResponse = $input.first().json;\n\n// Merge them - keep all original data, add HTTP response\nreturn {\n  json: {\n    ...processData,\n    httpResponse: httpResponse,\n    workflowUpdated: true\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "6bd8e661",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 6bd8e661\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJSZXN0b3JlIERhdGEgQWZ0ZXIgVXBkYXRlOCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "3a148d36-6fad-4236-84da-915956fbcf43",
      "name": "Local Backup Enabled?9",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        128,
        -20352
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "local-backup-enabled",
              "leftValue": "={{ $json.config.localBackupEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "277dced1",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 277dced1\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiTG9jYWwgQmFja3VwIEVuYWJsZWQ/OSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "3037631c-bcb0-43d0-9ec3-6ff4b54519e3",
      "name": "Build Success Response18",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1680,
        -20208
      ],
      "parameters": {
        "jsCode": "// Build Success Response\n// Merge original process data with latest branch data so backup/cleanup fields are preserved.\n\nconst processData = $(\"Process Node Versions18\").first().json;\nconst latestData = $input.first().json;\nconst data = {\n  ...processData,\n  ...latestData,\n};\n\nconst cleanupEnabled = data.cleanupEnabled ?? (data.config?.cleanupOldBackupsEnabled ?? false);\n\nfunction buildWorkflowOpenUrl(apiUrl, workflowId, timestamp) {\n  if (!workflowId) return null;\n\n  const rawApiUrl = String(apiUrl || '').trim();\n  if (!rawApiUrl) return null;\n\n  const normalizedApiUrl = rawApiUrl.replace(/\\/$/, '');\n  const baseUrl = normalizedApiUrl\n    .replace(/\\/api\\/v\\d+$/, '')\n    .replace(/\\/api$/, '');\n\n  return `${baseUrl}/workflow/${encodeURIComponent(workflowId)}?updated=${encodeURIComponent(timestamp)}`;\n}\n\nconst timestamp = data.timestamp || new Date().toISOString();\nconst workflowId = data.config?.workflowId || 'unknown';\nconst openWorkflowUrl = buildWorkflowOpenUrl(data.config?.n8nApiUrl, workflowId, timestamp);\n\nconst summary = {\n  success: true,\n  message: data.hasChanges\n    ? `‚úÖ Version control updated: ${data.nodeChanges.length} node${data.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId,\n  workflowName: data.updatedWorkflow?.name || data.originalWorkflow?.name || 'Unknown',\n  hasChanges: data.hasChanges || false,\n  nodeChanges: data.nodeChanges || [],\n  originalWorkflow: data.originalWorkflow,\n  updatedWorkflow: data.updatedWorkflow,\n  workflowVersion: data.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp,\n  dryRun: false,\n  openWorkflowUrl,\n};\n\nif (data.backupSaved !== undefined) {\n  summary.backup = {\n    saved: data.backupSaved,\n    filename: data.backupFilename || null,\n    path: data.backupPath || null,\n    error: data.backupError || data.backupCleanupError || null,\n    cleanup: {\n      enabled: cleanupEnabled,\n      performed: data.cleanupPerformed || false,\n      skipped: data.cleanupSkipped || false,\n      deleted: data.deletedBackups || 0,\n      files: data.deletedFiles || [],\n      prefix: data.cleanupPrefix || null,\n      matchedBackups: data.matchedBackups || 0,\n      maxVersions: data.cleanupMaxVersions ?? null,\n    },\n  };\n}\n\nreturn { json: summary };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "676f4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 676f4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlMTgiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "ed9cef64-c71a-4593-ae5c-9f642479e5d9",
      "name": "Process Node Versions18",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -944,
        -19936
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\nconst config = $(\"Parse Configuration18\").first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldSnapshot, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldSnapshot) return { type: 'major', reason: 'New node' };\n  \n  // MAJOR: Node type changed\n  if (oldSnapshot.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldSnapshot.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldSnapshot.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldSnapshot.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Compare parameter keys (what we have in snapshot)\n  const oldKeys = (oldSnapshot.parameterKeys || []).sort();\n  const newParams = newNode.parameters || {};\n  const newParamsCopy = { ...newParams };\n  delete newParamsCopy._versionControl;\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // MINOR: Check parameter structure changes (array lengths, etc.)\n  if (oldSnapshot.parameterStructure && newParams) {\n    for (const key in oldSnapshot.parameterStructure) {\n      const oldStruct = oldSnapshot.parameterStructure[key];\n      const newParam = newParams[key];\n      \n      if (!newParam) continue; // Parameter was removed (caught above)\n      \n      // Check assignment count changes\n      if (oldStruct.assignmentCount !== undefined) {\n        const newCount = newParam.assignments?.length || 0;\n        if (oldStruct.assignmentCount !== newCount) {\n          const change = newCount > oldStruct.assignmentCount ? 'Added' : 'Removed';\n          const diff = Math.abs(newCount - oldStruct.assignmentCount);\n          return { \n            type: 'minor', \n            reason: `${change} ${diff} assignment${diff > 1 ? 's' : ''} in '${key}'`\n          };\n        }\n      }\n      \n      // Check array length changes\n      if (oldStruct.arrayLength !== undefined) {\n        const newLength = Array.isArray(newParam) ? newParam.length : 0;\n        if (oldStruct.arrayLength !== newLength) {\n          return { \n            type: 'minor', \n            reason: `Array '${key}' size changed: ${oldStruct.arrayLength} ‚Üí ${newLength}`\n          };\n        }\n      }\n      \n      // Check parameter count changes (like HTTP headers)\n      if (oldStruct.paramCount !== undefined) {\n        const newCount = newParam.parameters?.length || 0;\n        if (oldStruct.paramCount !== newCount) {\n          return { \n            type: 'minor', \n            reason: `Parameter count in '${key}' changed: ${oldStruct.paramCount} ‚Üí ${newCount}`\n          };\n        }\n      }\n    }\n  }\n  \n  // If keys are the same and structure unchanged, it's a PATCH (value change)\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const rawParts = String(version || '1.0.0').split('.').map(part => Number(part));\n  const parts = [\n    Number.isFinite(rawParts[0]) ? rawParts[0] : 1,\n    Number.isFinite(rawParts[1]) ? rawParts[1] : 0,\n    Number.isFinite(rawParts[2]) ? rawParts[2] : 0,\n  ];\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  const snapshot = {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n  \n  // Store array lengths for parameters that are arrays or contain arrays\n  // This helps detect adding/removing items (MINOR change)\n  if (node.parameters) {\n    snapshot.parameterStructure = {};\n    \n    for (const key of snapshot.parameterKeys) {\n      const param = node.parameters[key];\n      \n      if (param && typeof param === 'object') {\n        // Check for common n8n patterns\n        if (param.assignments && Array.isArray(param.assignments)) {\n          // Set/Edit Fields node with assignments\n          snapshot.parameterStructure[key] = {\n            assignmentCount: param.assignments.length\n          };\n        } else if (Array.isArray(param)) {\n          // Direct array parameter\n          snapshot.parameterStructure[key] = {\n            arrayLength: param.length\n          };\n        } else if (param.parameters && Array.isArray(param.parameters)) {\n          // HTTP Request headers/parameters\n          snapshot.parameterStructure[key] = {\n            paramCount: param.parameters.length\n          };\n        }\n      }\n    }\n  }\n  \n  return snapshot;\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const parsedExistingVersion = parseVersionFromNotes(node.notes);\n  const existingVersion = parsedExistingVersion && parsedExistingVersion.version\n    ? parsedExistingVersion\n    : {\n      version: '1.0.0',\n      created: timestamp,\n      lastModified: timestamp\n    };\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hashChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  // Check for name changes (MAJOR change that doesn't affect hash)\n  const nameChanged = storedSnapshot && storedSnapshot.name !== node.name;\n  \n  // Node has changed if hash OR name changed\n  const hasChanged = hashChanged || nameChanged;\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: config,\n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "58ef351c",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 58ef351c\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnMxOCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "801ac022-6be7-46d9-942a-2bdc01f3da57",
      "name": "Respond to Webhook18",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        528,
        -19744
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2sxOCIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsib3B0aW9ucyIsInJlc3BvbmRXaXRoIiwicmVzcG9uc2VCb2R5Il0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "538d386f-fce7-4055-83fb-99b228a5cec8",
      "name": "Dry Run Response18",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -256,
        -19760
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\n\nfunction buildWorkflowOpenUrl(apiUrl, workflowId, timestamp) {\n  if (!workflowId) return null;\n\n  const rawApiUrl = String(apiUrl || '').trim();\n  if (!rawApiUrl) return null;\n\n  const normalizedApiUrl = rawApiUrl.replace(/\\/$/, '');\n  const baseUrl = normalizedApiUrl\n    .replace(/\\/api\\/v\\d+$/, '')\n    .replace(/\\/api$/, '');\n\n  return `${baseUrl}/workflow/${encodeURIComponent(workflowId)}?updated=${encodeURIComponent(timestamp)}`;\n}\n\nconst timestamp = data.timestamp || new Date().toISOString();\nconst workflowId = data.config?.workflowId || null;\nconst openWorkflowUrl = buildWorkflowOpenUrl(data.config?.n8nApiUrl, workflowId, timestamp);\n\nreturn {\n  json: {\n    success: true,\n    message: 'Dry run completed - no changes applied',\n    workflowId,\n    workflowName: data.originalWorkflow?.name,\n    version: {\n      previous: data.workflowVersion?.previous,\n      wouldBecome: data.workflowVersion?.current,\n    },\n    changes: data.nodeChanges,\n    timestamp,\n    dryRun: true,\n    openWorkflowUrl,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "54cd6021",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 54cd6021\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlMTgiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "08abfba8-ea7d-403e-99b6-72208caf3f8c",
      "name": "Update Workflow with Versions18",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -368,
        -20352
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1747da31",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 1747da31\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnMxOCIsInR5cGVWZXJzaW9uIjo0LjIsInBhcmFtZXRlcktleXMiOlsiYXV0aGVudGljYXRpb24iLCJnZW5lcmljQXV0aFR5cGUiLCJoZWFkZXJQYXJhbWV0ZXJzIiwianNvbkJvZHkiLCJtZXRob2QiLCJvcHRpb25zIiwic2VuZEJvZHkiLCJzZW5kSGVhZGVycyIsInNwZWNpZnlCb2R5IiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjF9fX0=",
      "notesInFlow": true
    },
    {
      "id": "3bd34171-af0c-4b3f-95aa-71bb1b07cc61",
      "name": "Dry Run?18",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -496,
        -19840
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj8xOCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "b7e8d2ed-62e0-49af-acf2-e70ea487c3f5",
      "name": "No Changes Response18",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -144,
        -19488
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\n\nfunction buildWorkflowOpenUrl(apiUrl, workflowId, timestamp) {\n  if (!workflowId) return null;\n\n  const rawApiUrl = String(apiUrl || '').trim();\n  if (!rawApiUrl) return null;\n\n  const normalizedApiUrl = rawApiUrl.replace(/\\/$/, '');\n  const baseUrl = normalizedApiUrl\n    .replace(/\\/api\\/v\\d+$/, '')\n    .replace(/\\/api$/, '');\n\n  return `${baseUrl}/workflow/${encodeURIComponent(workflowId)}?updated=${encodeURIComponent(timestamp)}`;\n}\n\nconst timestamp = data.timestamp || new Date().toISOString();\nconst workflowId = data.config?.workflowId || null;\nconst openWorkflowUrl = buildWorkflowOpenUrl(data.config?.n8nApiUrl, workflowId, timestamp);\n\nreturn {\n  json: {\n    success: true,\n    message: 'No changes detected',\n    workflowId,\n    workflowName: data.originalWorkflow?.name,\n    version: data.workflowVersion?.current,\n    timestamp,\n    openWorkflowUrl,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2fd48f36",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2fd48f36\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlMTgiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "ccc5cc01-51d4-4229-bf47-162e6bf11cb0",
      "name": "Has Changes?18",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -784,
        -19824
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/MTgiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "75a12e8c-1c83-4c61-b818-dd1e19418f3f",
      "name": "Fetch Current Workflow18",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1152,
        -19824
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7ffe44bb",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 7ffe44bb\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzE4IiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJhdXRoZW50aWNhdGlvbiIsImdlbmVyaWNBdXRoVHlwZSIsIm9wdGlvbnMiLCJ1cmwiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "19c5e7aa-b1ff-4fae-b914-64ae135381ad",
      "name": "Parse Configuration18",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1328,
        -19824
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\n// Configuration with defaults\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/data/workflow-backups',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupEnabled: input.localBackupEnabled ?? input.body?.localBackupEnabled ?? false,\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  localBackupMaxVersions: input.localBackupMaxVersions ?? input.body?.localBackupMaxVersions ?? 20,\n  cleanupOldBackupsEnabled: input.cleanupOldBackupsEnabled ?? input.body?.cleanupOldBackupsEnabled ?? false,\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl ||  'http://localhost:5678/api/v1',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null, // null = auto-generate\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nreturn { json: config };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2e2e397",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2e2e397\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uMTgiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "6022b4a1-18cc-40dd-bfd2-77cb09f8ca30",
      "name": "Cleanup Old Backups4",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        928,
        -20288
      ],
      "parameters": {
        "jsCode": "// Cleanup Old Backups\n// Keep only newest N backups for the current workflow prefix.\n\nconst data = $input.first().json;\nconst config = data.config || {};\nconst cleanupEnabled = config.cleanupOldBackupsEnabled === true;\n\nif (!cleanupEnabled) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: false,\n      cleanupSkipped: true,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n    }\n  };\n}\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst backupDir = (data.backupDisplayPath || path.dirname(data.backupFullPath || '')).replace(/\\/+$/, '');\nconst currentFile = data.backupFilename || path.basename(data.backupFullPath || '');\nconst backupPrefix = data.backupPrefix || null;\n\nconst maxRaw = Number(config.localBackupMaxVersions ?? 20);\nconst maxVersions = Number.isFinite(maxRaw) ? Math.floor(maxRaw) : 20;\n\nfunction escapeRegex(value) {\n  return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction prefixFromFile(filename) {\n  const semverIndex = filename.indexOf('-v');\n  if (semverIndex > 0) return `${filename.slice(0, semverIndex)}-v`;\n  return null;\n}\n\nfunction getSortEpochMs(filename, fallbackMs) {\n  const match = filename.match(/-(\\d{4})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})\\.json$/);\n  if (!match) return fallbackMs;\n\n  const [, y, mo, d, h, mi, s] = match;\n  const dt = Date.UTC(Number(y), Number(mo) - 1, Number(d), Number(h), Number(mi), Number(s));\n  return Number.isFinite(dt) ? dt : fallbackMs;\n}\n\ntry {\n  if (!backupDir) {\n    return {\n      json: {\n        ...data,\n        cleanupEnabled: true,\n        cleanupSkipped: false,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Backup directory is missing.',\n      }\n    };\n  }\n\n  // Preserve the newest backup by default even if max is misconfigured.\n  const effectiveMax = maxVersions < 1 ? 1 : maxVersions;\n\n  const workflowPrefix = backupPrefix || prefixFromFile(currentFile);\n  if (!workflowPrefix) {\n    return {\n      json: {\n        ...data,\n        cleanupEnabled: true,\n        cleanupSkipped: false,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Unable to determine workflow backup prefix.',\n      }\n    };\n  }\n\n  const filePattern = new RegExp(\n    `^${escapeRegex(workflowPrefix)}\\\\d+\\\\.\\\\d+\\\\.\\\\d+-\\\\d{4}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}\\\\.json$`\n  );\n\n  const matchingFiles = fs\n    .readdirSync(backupDir, { withFileTypes: true })\n    .filter((entry) => entry.isFile())\n    .map((entry) => entry.name)\n    .filter((name) => filePattern.test(name))\n    .map((name) => {\n      const fullPath = path.join(backupDir, name);\n      const stats = fs.statSync(fullPath);\n      return {\n        name,\n        fullPath,\n        mtimeMs: stats.mtimeMs,\n        sortEpochMs: getSortEpochMs(name, stats.mtimeMs),\n      };\n    })\n    .sort((a, b) => {\n      if (a.sortEpochMs !== b.sortEpochMs) return a.sortEpochMs - b.sortEpochMs;\n      return a.mtimeMs - b.mtimeMs;\n    });\n\n  const deleteCount = Math.max(0, matchingFiles.length - effectiveMax);\n  const toDelete = matchingFiles.slice(0, deleteCount);\n\n  for (const file of toDelete) {\n    fs.unlinkSync(file.fullPath);\n  }\n\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: true,\n      cleanupPrefix: workflowPrefix,\n      cleanupMaxVersions: effectiveMax,\n      matchedBackups: matchingFiles.length,\n      deletedBackups: toDelete.length,\n      deletedFiles: toDelete.map((file) => file.name),\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n      backupCleanupError: error?.message || String(error),\n    }\n  };\n}\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "6c9b4b90",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 6c9b4b90\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDbGVhbnVwIE9sZCBCYWNrdXBzNCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "78f2de4a-781f-450c-9391-fe1d350e371e",
      "name": "Delete Old Backups Enabled?3",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        800,
        -20048
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "cleanup-old-backups-enabled",
              "leftValue": "={{ $json.config.cleanupOldBackupsEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "47bddea4",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 47bddea4\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRGVsZXRlIE9sZCBCYWNrdXBzIEVuYWJsZWQ/MyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "6f1a8112-8a0d-460e-9c0f-5e551bf44f1d",
      "name": "Git Enabled?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        272,
        -21664
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "git-enabled",
              "leftValue": "={{ $json.config.gitEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "6d2083b6",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 6d2083b6\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiR2l0IEVuYWJsZWQ/IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsiY29uZGl0aW9ucyIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "414571d0-ad30-437f-9a74-d2c18ec594a7",
      "name": "Prepare Git Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        464,
        -21856
      ],
      "parameters": {
        "jsCode": "// Prepare Git Data with stable filename (workflowId-based)\n\nconst data = $input.first().json;\nconst config = data.config || {};\n\nconst workflowId = config.workflowId || data.workflowId || 'unknown-workflow';\nconst repoPath = String(config.gitRepoPath || '/files/backups/git-repo').replace(/\\/+$/, '');\nconst gitFileName = `workflow-${workflowId}.json`;\nconst gitFilePath = `${repoPath}/${gitFileName}`;\n\nconst currentVersion = data.workflowVersion?.current || '1.0.0';\nconst commitMessage = config.commitMessage\n  || `chore(workflow): ${workflowId} -> v${currentVersion}`;\n\nconst gitWorkflowJson = `${JSON.stringify(data.updatedWorkflow, null, 2)}\n`;\n\nreturn {\n  json: {\n    ...data,\n    gitRepoPath: repoPath,\n    gitFileName,\n    gitFilePath,\n    gitWorkflowJson,\n    gitCommitMessage: commitMessage,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "6432b068",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 6432b068\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcmVwYXJlIEdpdCBEYXRhIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "5e6de2e1-14f4-4a73-b990-370f0db44f5a",
      "name": "Convert Git Workflow to Binary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        656,
        -21856
      ],
      "parameters": {
        "jsCode": "// Convert Git workflow JSON to binary for Write Binary File node\n\nconst data = $input.first().json;\nconst binaryData = Buffer.from(data.gitWorkflowJson, 'utf-8');\n\nreturn {\n  json: data,\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'application/json',\n      fileName: data.gitFileName,\n      fileExtension: 'json',\n    }\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1e6d3a18",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 1e6d3a18\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDb252ZXJ0IEdpdCBXb3JrZmxvdyB0byBCaW5hcnkiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "42289528-6d4a-4e83-b5cf-8e8d20523485",
      "name": "Write Git Workflow File",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        848,
        -21856
      ],
      "parameters": {
        "fileName": "={{ $json.gitFilePath }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2307914b",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1\nüîí Hash: 2307914b\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uud3JpdGVCaW5hcnlGaWxlIiwibmFtZSI6IldyaXRlIEdpdCBXb3JrZmxvdyBGaWxlIiwidHlwZVZlcnNpb24iOjEsInBhcmFtZXRlcktleXMiOlsiZmlsZU5hbWUiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "bae3d3a0-b4f2-4d25-bc97-c6a02a6aaa5c",
      "name": "Git Add Workflow File",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        1040,
        -21856
      ],
      "parameters": {
        "operation": "add",
        "repositoryPath": "={{ $json.gitRepoPath }}",
        "pathsToAdd": "={{ $json.gitFileName }}",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "226bce3c",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 226bce3c\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBBZGQgV29ya2Zsb3cgRmlsZSIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsib3BlcmF0aW9uIiwicGF0aHNUb0FkZCIsInJlcG9zaXRvcnlQYXRoIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "53b47383-246f-49b6-8447-0a55e6bd7e02",
      "name": "Git Commit Workflow File",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        1232,
        -21856
      ],
      "parameters": {
        "operation": "commit",
        "repositoryPath": "={{ $json.gitRepoPath }}",
        "message": "={{ $json.gitCommitMessage }}",
        "options": {
          "branch": "={{ $json.config.gitBranch }}",
          "pathsToAdd": "={{ $json.gitFileName }}"
        },
        "_versionControl": {
          "version": "1.0.0",
          "hash": "55fa3267",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 55fa3267\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBDb21taXQgV29ya2Zsb3cgRmlsZSIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsibWVzc2FnZSIsIm9wZXJhdGlvbiIsIm9wdGlvbnMiLCJyZXBvc2l0b3J5UGF0aCJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "f428fb20-584a-47e0-888e-5abd96ff939c",
      "name": "Git Latest Commit",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        1424,
        -21856
      ],
      "parameters": {
        "repositoryPath": "={{ $json.gitRepoPath }}",
        "limit": 1,
        "options": {
          "file": "={{ $json.gitFileName }}"
        },
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3cedb724",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 3cedb724\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBMYXRlc3QgQ29tbWl0IiwidHlwZVZlcnNpb24iOjEuMSwicGFyYW1ldGVyS2V5cyI6WyJsaW1pdCIsIm9wdGlvbnMiLCJyZXBvc2l0b3J5UGF0aCJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "b41a6a18-8a15-4593-ad0a-c386ebce288e",
      "name": "Git Push Enabled?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1616,
        -21856
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "git-push-enabled",
              "leftValue": "={{ $json.config.gitPushEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3658c517",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3658c517\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiR2l0IFB1c2ggRW5hYmxlZD8iLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "db823d6d-4b30-450d-ad0d-7d4deef14973",
      "name": "Git Push Remote",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        1808,
        -21952
      ],
      "parameters": {
        "operation": "push",
        "repositoryPath": "={{ $json.gitRepoPath }}",
        "options": {
          "branch": "={{ $json.config.gitBranch }}"
        },
        "_versionControl": {
          "version": "1.0.0",
          "hash": "414ba768",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 414ba768\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBQdXNoIFJlbW90ZSIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsib3BlcmF0aW9uIiwib3B0aW9ucyIsInJlcG9zaXRvcnlQYXRoIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "4b215b0f-6171-4e6d-aa09-cd3fb94bbaf4",
      "name": "Finalize Git Local",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1808,
        -21680
      ],
      "parameters": {
        "jsCode": "// Finalize Git status for local commit only\n\nconst base = $(\"Prepare Git Data\").first().json;\nconst commit = $(\"Git Latest Commit\").first().json;\n\nreturn {\n  json: {\n    ...base,\n    gitCommitted: true,\n    gitPushed: false,\n    gitCommit: commit\n      ? {\n          hash: commit.hash || null,\n          message: commit.message || null,\n          date: commit.date || null,\n          authorName: commit.author_name || null,\n          authorEmail: commit.author_email || null,\n        }\n      : null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "4ca5af10",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 4ca5af10\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJGaW5hbGl6ZSBHaXQgTG9jYWwiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "0404fc02-43a0-43e9-8b58-1e492657e776",
      "name": "Finalize Git Push",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2000,
        -21952
      ],
      "parameters": {
        "jsCode": "// Finalize Git status for local commit + remote push\n\nconst base = $(\"Prepare Git Data\").first().json;\nconst commit = $(\"Git Latest Commit\").first().json;\n\nreturn {\n  json: {\n    ...base,\n    gitCommitted: true,\n    gitPushed: true,\n    gitCommit: commit\n      ? {\n          hash: commit.hash || null,\n          message: commit.message || null,\n          date: commit.date || null,\n          authorName: commit.author_name || null,\n          authorEmail: commit.author_email || null,\n        }\n      : null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3d304966",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 3d304966\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJGaW5hbGl6ZSBHaXQgUHVzaCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "7bd57da4-acaf-4a40-aa81-27132eb256b0",
      "name": "Mark Backup Complete7",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -144,
        -21328
      ],
      "parameters": {
        "jsCode": "// Mark Backup Complete\n\nconst data = $input.first().json;\n\nreturn {\n  json: {\n    ...data,\n    backupSaved: true,\n    backupTimestamp: new Date().toISOString(),\n    backupPath: data.backupFullPath || null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "84b988f",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 84b988f\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJNYXJrIEJhY2t1cCBDb21wbGV0ZTciLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "08ec2d8a-5b1a-4193-aa0b-9e96c659e1a5",
      "name": "Write Backup File7",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        -320,
        -21328
      ],
      "parameters": {
        "fileName": "={{ $json.backupFullPath }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "20c20b9a",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1\nüîí Hash: 20c20b9a\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uud3JpdGVCaW5hcnlGaWxlIiwibmFtZSI6IldyaXRlIEJhY2t1cCBGaWxlNyIsInR5cGVWZXJzaW9uIjoxLCJwYXJhbWV0ZXJLZXlzIjpbImZpbGVOYW1lIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "9293c6ce-bb95-4a0b-8229-462be7f9c2c3",
      "name": "Convert to Binary7",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -496,
        -21328
      ],
      "parameters": {
        "jsCode": "// Convert to Binary Data\n\nconst data = $input.first().json;\n\n// Convert JSON string to binary data\nconst binaryData = Buffer.from(data.workflowJson, 'utf-8');\n\nreturn {\n  json: data,\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'application/json',\n      fileName: data.backupFilename,\n      fileExtension: 'json'\n    }\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "792aa334",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 792aa334\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDb252ZXJ0IHRvIEJpbmFyeTciLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "c725a3b7-ecf6-4521-905e-eb517625b7f1",
      "name": "Prepare Backup Data7",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -688,
        -21328
      ],
      "parameters": {
        "jsCode": "// Prepare Backup Data - Create filename and data\n\nconst data = $input.first().json;\nconst workflow = data.updatedWorkflow;\nconst version = data.workflowVersion.current;\nconst config = data.config;\n\n// Sanitize workflow name\nconst safeName = workflow.name\n  .replace(/\\s+/g, '_')\n  .replace(/[^a-zA-Z0-9_-]/g, '')\n  .substring(0, 50);\n\n// Generate human-readable timestamp\nconst now = new Date();\nconst year = now.getFullYear();\nconst month = String(now.getMonth() + 1).padStart(2, '0');\nconst day = String(now.getDate()).padStart(2, '0');\nconst hours = String(now.getHours()).padStart(2, '0');\nconst minutes = String(now.getMinutes()).padStart(2, '0');\nconst seconds = String(now.getSeconds()).padStart(2, '0');\n\nconst timestamp = `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;\n\nconst backupPrefix = `${safeName}-v`;\nconst filename = `${backupPrefix}${version}-${timestamp}.json`;\n\nlet backupDir = config.localBackupPath || '/tmp';\nif (backupDir.startsWith('~/')) {\n  const homeDir =\n    (typeof process !== 'undefined' && process.env && process.env.HOME)\n      ? process.env.HOME\n      : '/home/node';\n  backupDir = backupDir.replace(/^~(?=\\/)/, homeDir);\n}\n\nbackupDir = backupDir.replace(/\\/+$/, '') || '/tmp';\n\nreturn {\n  json: {\n    ...data,\n    backupPrefix,\n    backupFilename: filename,\n    backupDisplayPath: backupDir,\n    backupFullPath: `${backupDir}/${filename}`,\n    workflowJson: JSON.stringify(workflow, null, 2),\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "52eca43b",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 52eca43b\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcmVwYXJlIEJhY2t1cCBEYXRhNyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "7e79aa9d-8f9f-46f5-94c7-170de8a1e8f1",
      "name": "Restore Data After Update9",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -880,
        -21632
      ],
      "parameters": {
        "jsCode": "// Restore Data After HTTP Request\n\n// Get the original data from Process Node Versions\nconst processData = $(\"Process Node Versions19\").first().json;\n\n// Get the HTTP response (current input)\nconst httpResponse = $input.first().json;\n\n// Merge them - keep all original data, add HTTP response\nreturn {\n  json: {\n    ...processData,\n    httpResponse: httpResponse,\n    workflowUpdated: true\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "209134de",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 209134de\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJSZXN0b3JlIERhdGEgQWZ0ZXIgVXBkYXRlOSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "893c0913-20a6-4389-8125-92937ead42a0",
      "name": "Local Backup Enabled?10",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -656,
        -21632
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "local-backup-enabled",
              "leftValue": "={{ $json.config.localBackupEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "277dced1",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 277dced1\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiTG9jYWwgQmFja3VwIEVuYWJsZWQ/MTAiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "2cc08efb-ccf9-49ce-a5e6-1135dbe68165",
      "name": "Build Success Response19",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        512,
        -21664
      ],
      "parameters": {
        "jsCode": "// Build Success Response\n// Merge original process data with latest branch data so backup/cleanup/git fields are preserved.\n\nconst processData = $(\"Process Node Versions19\").first().json;\nconst latestData = $input.first().json;\nconst data = {\n  ...processData,\n  ...latestData,\n};\n\nconst cleanupEnabled = data.cleanupEnabled ?? (data.config?.cleanupOldBackupsEnabled ?? false);\n\nfunction buildWorkflowOpenUrl(apiUrl, workflowId, timestamp) {\n  if (!workflowId) return null;\n\n  const rawApiUrl = String(apiUrl || '').trim();\n  if (!rawApiUrl) return null;\n\n  const normalizedApiUrl = rawApiUrl.replace(/\\/$/, '');\n  const baseUrl = normalizedApiUrl\n    .replace(/\\/api\\/v\\d+$/, '')\n    .replace(/\\/api$/, '');\n\n  return `${baseUrl}/workflow/${encodeURIComponent(workflowId)}?updated=${encodeURIComponent(timestamp)}`;\n}\n\nconst timestamp = data.timestamp || new Date().toISOString();\nconst workflowId = data.config?.workflowId || 'unknown';\nconst openWorkflowUrl = buildWorkflowOpenUrl(data.config?.n8nApiUrl, workflowId, timestamp);\n\nconst summary = {\n  success: true,\n  message: data.hasChanges\n    ? `‚úÖ Version control updated: ${data.nodeChanges.length} node${data.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId,\n  workflowName: data.updatedWorkflow?.name || data.originalWorkflow?.name || 'Unknown',\n  hasChanges: data.hasChanges || false,\n  nodeChanges: data.nodeChanges || [],\n  originalWorkflow: data.originalWorkflow,\n  updatedWorkflow: data.updatedWorkflow,\n  workflowVersion: data.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp,\n  dryRun: false,\n  openWorkflowUrl,\n};\n\nsummary.git = {\n  enabled: data.config?.gitEnabled ?? false,\n  remotePushEnabled: data.config?.gitPushEnabled ?? false,\n  repoPath: data.gitRepoPath || data.config?.gitRepoPath || null,\n  fileName: data.gitFileName || null,\n  filePath: data.gitFilePath || null,\n  branch: data.config?.gitBranch || null,\n  remote: data.config?.gitRemote || null,\n  commitMessage: data.gitCommitMessage || data.config?.commitMessage || null,\n  committed: data.gitCommitted || false,\n  pushed: data.gitPushed || false,\n  commit: data.gitCommit || null,\n  error: data.gitError || null,\n};\n\nif (data.backupSaved !== undefined) {\n  summary.backup = {\n    saved: data.backupSaved,\n    filename: data.backupFilename || null,\n    path: data.backupPath || null,\n    error: data.backupError || data.backupCleanupError || null,\n    cleanup: {\n      enabled: cleanupEnabled,\n      performed: data.cleanupPerformed || false,\n      skipped: data.cleanupSkipped || false,\n      deleted: data.deletedBackups || 0,\n      files: data.deletedFiles || [],\n      prefix: data.cleanupPrefix || null,\n      matchedBackups: data.matchedBackups || 0,\n      maxVersions: data.cleanupMaxVersions ?? null,\n    },\n  };\n}\n\nreturn { json: summary };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "ca87b5d",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: ca87b5d\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlMTkiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "0aea77a3-32f2-4915-a38a-0d1b6cf5c0a6",
      "name": "Process Node Versions19",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1728,
        -21216
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\nconst config = $(\"Parse Configuration19\").first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldSnapshot, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldSnapshot) return { type: 'major', reason: 'New node' };\n  \n  // MAJOR: Node type changed\n  if (oldSnapshot.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldSnapshot.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldSnapshot.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldSnapshot.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Compare parameter keys (what we have in snapshot)\n  const oldKeys = (oldSnapshot.parameterKeys || []).sort();\n  const newParams = newNode.parameters || {};\n  const newParamsCopy = { ...newParams };\n  delete newParamsCopy._versionControl;\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // MINOR: Check parameter structure changes (array lengths, etc.)\n  if (oldSnapshot.parameterStructure && newParams) {\n    for (const key in oldSnapshot.parameterStructure) {\n      const oldStruct = oldSnapshot.parameterStructure[key];\n      const newParam = newParams[key];\n      \n      if (!newParam) continue; // Parameter was removed (caught above)\n      \n      // Check assignment count changes\n      if (oldStruct.assignmentCount !== undefined) {\n        const newCount = newParam.assignments?.length || 0;\n        if (oldStruct.assignmentCount !== newCount) {\n          const change = newCount > oldStruct.assignmentCount ? 'Added' : 'Removed';\n          const diff = Math.abs(newCount - oldStruct.assignmentCount);\n          return { \n            type: 'minor', \n            reason: `${change} ${diff} assignment${diff > 1 ? 's' : ''} in '${key}'`\n          };\n        }\n      }\n      \n      // Check array length changes\n      if (oldStruct.arrayLength !== undefined) {\n        const newLength = Array.isArray(newParam) ? newParam.length : 0;\n        if (oldStruct.arrayLength !== newLength) {\n          return { \n            type: 'minor', \n            reason: `Array '${key}' size changed: ${oldStruct.arrayLength} ‚Üí ${newLength}`\n          };\n        }\n      }\n      \n      // Check parameter count changes (like HTTP headers)\n      if (oldStruct.paramCount !== undefined) {\n        const newCount = newParam.parameters?.length || 0;\n        if (oldStruct.paramCount !== newCount) {\n          return { \n            type: 'minor', \n            reason: `Parameter count in '${key}' changed: ${oldStruct.paramCount} ‚Üí ${newCount}`\n          };\n        }\n      }\n    }\n  }\n  \n  // If keys are the same and structure unchanged, it's a PATCH (value change)\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const rawParts = String(version || '1.0.0').split('.').map(part => Number(part));\n  const parts = [\n    Number.isFinite(rawParts[0]) ? rawParts[0] : 1,\n    Number.isFinite(rawParts[1]) ? rawParts[1] : 0,\n    Number.isFinite(rawParts[2]) ? rawParts[2] : 0,\n  ];\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  const snapshot = {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n  \n  // Store array lengths for parameters that are arrays or contain arrays\n  // This helps detect adding/removing items (MINOR change)\n  if (node.parameters) {\n    snapshot.parameterStructure = {};\n    \n    for (const key of snapshot.parameterKeys) {\n      const param = node.parameters[key];\n      \n      if (param && typeof param === 'object') {\n        // Check for common n8n patterns\n        if (param.assignments && Array.isArray(param.assignments)) {\n          // Set/Edit Fields node with assignments\n          snapshot.parameterStructure[key] = {\n            assignmentCount: param.assignments.length\n          };\n        } else if (Array.isArray(param)) {\n          // Direct array parameter\n          snapshot.parameterStructure[key] = {\n            arrayLength: param.length\n          };\n        } else if (param.parameters && Array.isArray(param.parameters)) {\n          // HTTP Request headers/parameters\n          snapshot.parameterStructure[key] = {\n            paramCount: param.parameters.length\n          };\n        }\n      }\n    }\n  }\n  \n  return snapshot;\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const parsedExistingVersion = parseVersionFromNotes(node.notes);\n  const existingVersion = parsedExistingVersion && parsedExistingVersion.version\n    ? parsedExistingVersion\n    : {\n      version: '1.0.0',\n      created: timestamp,\n      lastModified: timestamp\n    };\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hashChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  // Check for name changes (MAJOR change that doesn't affect hash)\n  const nameChanged = storedSnapshot && storedSnapshot.name !== node.name;\n  \n  // Node has changed if hash OR name changed\n  const hasChanged = hashChanged || nameChanged;\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: config,\n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7676b905",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 7676b905\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnMxOSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "94889d1a-4a6b-4d67-b0ee-b8a078bdb305",
      "name": "Respond to Webhook19",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        -256,
        -21024
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2sxOSIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsib3B0aW9ucyIsInJlc3BvbmRXaXRoIiwicmVzcG9uc2VCb2R5Il0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "89c6b540-c10e-4c24-938f-7152cdf46bb8",
      "name": "Dry Run Response19",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1040,
        -21040
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\n\nfunction buildWorkflowOpenUrl(apiUrl, workflowId, timestamp) {\n  if (!workflowId) return null;\n\n  const rawApiUrl = String(apiUrl || '').trim();\n  if (!rawApiUrl) return null;\n\n  const normalizedApiUrl = rawApiUrl.replace(/\\/$/, '');\n  const baseUrl = normalizedApiUrl\n    .replace(/\\/api\\/v\\d+$/, '')\n    .replace(/\\/api$/, '');\n\n  return `${baseUrl}/workflow/${encodeURIComponent(workflowId)}?updated=${encodeURIComponent(timestamp)}`;\n}\n\nconst timestamp = data.timestamp || new Date().toISOString();\nconst workflowId = data.config?.workflowId || null;\nconst openWorkflowUrl = buildWorkflowOpenUrl(data.config?.n8nApiUrl, workflowId, timestamp);\n\nreturn {\n  json: {\n    success: true,\n    message: 'Dry run completed - no changes applied',\n    workflowId,\n    workflowName: data.originalWorkflow?.name,\n    version: {\n      previous: data.workflowVersion?.previous,\n      wouldBecome: data.workflowVersion?.current,\n    },\n    changes: data.nodeChanges,\n    timestamp,\n    dryRun: true,\n    openWorkflowUrl,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "54cd6021",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 54cd6021\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlMTkiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "00e46da4-461c-4928-88a0-5fa147f0db8c",
      "name": "Update Workflow with Versions19",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1152,
        -21632
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1747da31",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 1747da31\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnMxOSIsInR5cGVWZXJzaW9uIjo0LjIsInBhcmFtZXRlcktleXMiOlsiYXV0aGVudGljYXRpb24iLCJnZW5lcmljQXV0aFR5cGUiLCJoZWFkZXJQYXJhbWV0ZXJzIiwianNvbkJvZHkiLCJtZXRob2QiLCJvcHRpb25zIiwic2VuZEJvZHkiLCJzZW5kSGVhZGVycyIsInNwZWNpZnlCb2R5IiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjF9fX0=",
      "notesInFlow": true
    },
    {
      "id": "9b649c41-3b54-4f37-b809-eb624cbe19db",
      "name": "Dry Run?19",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1280,
        -21120
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj8xOSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "e8fe59f5-ccae-4a5c-b258-8bbea237bf3b",
      "name": "No Changes Response19",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -928,
        -20768
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\n\nfunction buildWorkflowOpenUrl(apiUrl, workflowId, timestamp) {\n  if (!workflowId) return null;\n\n  const rawApiUrl = String(apiUrl || '').trim();\n  if (!rawApiUrl) return null;\n\n  const normalizedApiUrl = rawApiUrl.replace(/\\/$/, '');\n  const baseUrl = normalizedApiUrl\n    .replace(/\\/api\\/v\\d+$/, '')\n    .replace(/\\/api$/, '');\n\n  return `${baseUrl}/workflow/${encodeURIComponent(workflowId)}?updated=${encodeURIComponent(timestamp)}`;\n}\n\nconst timestamp = data.timestamp || new Date().toISOString();\nconst workflowId = data.config?.workflowId || null;\nconst openWorkflowUrl = buildWorkflowOpenUrl(data.config?.n8nApiUrl, workflowId, timestamp);\n\nreturn {\n  json: {\n    success: true,\n    message: 'No changes detected',\n    workflowId,\n    workflowName: data.originalWorkflow?.name,\n    version: data.workflowVersion?.current,\n    timestamp,\n    openWorkflowUrl,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2fd48f36",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2fd48f36\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlMTkiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "0d6276b8-ccfb-4bb9-a9f8-ea9b4b1c6755",
      "name": "Has Changes?19",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1568,
        -21104
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/MTkiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "34b59ccc-055b-4fe7-8682-c24222e6b812",
      "name": "Fetch Current Workflow19",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1936,
        -21104
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7ffe44bb",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 7ffe44bb\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzE5IiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJhdXRoZW50aWNhdGlvbiIsImdlbmVyaWNBdXRoVHlwZSIsIm9wdGlvbnMiLCJ1cmwiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "f7128f08-049e-42b5-8530-4f9ab016f137",
      "name": "Parse Configuration19",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2112,
        -21104
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitPushEnabled: input.gitPushEnabled ?? input.body?.gitPushEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/files/backups/git-repo',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupEnabled: input.localBackupEnabled ?? input.body?.localBackupEnabled ?? false,\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  localBackupMaxVersions: input.localBackupMaxVersions ?? input.body?.localBackupMaxVersions ?? 20,\n  cleanupOldBackupsEnabled: input.cleanupOldBackupsEnabled ?? input.body?.cleanupOldBackupsEnabled ?? false,\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl || 'http://localhost:5678/api/v1',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null,\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false,\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nif (config.gitEnabled && !config.gitRepoPath) {\n  throw new Error('gitRepoPath is required when gitEnabled=true.');\n}\n\nreturn { json: config };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5892ecd9",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5892ecd9\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uMTkiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "62d6d73f-44b0-4217-93e1-c81e860818ea",
      "name": "Cleanup Old Backups5",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        144,
        -21568
      ],
      "parameters": {
        "jsCode": "// Cleanup Old Backups\n// Keep only newest N backups for the current workflow prefix.\n\nconst data = $input.first().json;\nconst config = data.config || {};\nconst cleanupEnabled = config.cleanupOldBackupsEnabled === true;\n\nif (!cleanupEnabled) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: false,\n      cleanupSkipped: true,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n    }\n  };\n}\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst backupDir = (data.backupDisplayPath || path.dirname(data.backupFullPath || '')).replace(/\\/+$/, '');\nconst currentFile = data.backupFilename || path.basename(data.backupFullPath || '');\nconst backupPrefix = data.backupPrefix || null;\n\nconst maxRaw = Number(config.localBackupMaxVersions ?? 20);\nconst maxVersions = Number.isFinite(maxRaw) ? Math.floor(maxRaw) : 20;\n\nfunction escapeRegex(value) {\n  return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction prefixFromFile(filename) {\n  const semverIndex = filename.indexOf('-v');\n  if (semverIndex > 0) return `${filename.slice(0, semverIndex)}-v`;\n  return null;\n}\n\nfunction getSortEpochMs(filename, fallbackMs) {\n  const match = filename.match(/-(\\d{4})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})\\.json$/);\n  if (!match) return fallbackMs;\n\n  const [, y, mo, d, h, mi, s] = match;\n  const dt = Date.UTC(Number(y), Number(mo) - 1, Number(d), Number(h), Number(mi), Number(s));\n  return Number.isFinite(dt) ? dt : fallbackMs;\n}\n\ntry {\n  if (!backupDir) {\n    return {\n      json: {\n        ...data,\n        cleanupEnabled: true,\n        cleanupSkipped: false,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Backup directory is missing.',\n      }\n    };\n  }\n\n  // Preserve the newest backup by default even if max is misconfigured.\n  const effectiveMax = maxVersions < 1 ? 1 : maxVersions;\n\n  const workflowPrefix = backupPrefix || prefixFromFile(currentFile);\n  if (!workflowPrefix) {\n    return {\n      json: {\n        ...data,\n        cleanupEnabled: true,\n        cleanupSkipped: false,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Unable to determine workflow backup prefix.',\n      }\n    };\n  }\n\n  const filePattern = new RegExp(\n    `^${escapeRegex(workflowPrefix)}\\\\d+\\\\.\\\\d+\\\\.\\\\d+-\\\\d{4}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}\\\\.json$`\n  );\n\n  const matchingFiles = fs\n    .readdirSync(backupDir, { withFileTypes: true })\n    .filter((entry) => entry.isFile())\n    .map((entry) => entry.name)\n    .filter((name) => filePattern.test(name))\n    .map((name) => {\n      const fullPath = path.join(backupDir, name);\n      const stats = fs.statSync(fullPath);\n      return {\n        name,\n        fullPath,\n        mtimeMs: stats.mtimeMs,\n        sortEpochMs: getSortEpochMs(name, stats.mtimeMs),\n      };\n    })\n    .sort((a, b) => {\n      if (a.sortEpochMs !== b.sortEpochMs) return a.sortEpochMs - b.sortEpochMs;\n      return a.mtimeMs - b.mtimeMs;\n    });\n\n  const deleteCount = Math.max(0, matchingFiles.length - effectiveMax);\n  const toDelete = matchingFiles.slice(0, deleteCount);\n\n  for (const file of toDelete) {\n    fs.unlinkSync(file.fullPath);\n  }\n\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: true,\n      cleanupPrefix: workflowPrefix,\n      cleanupMaxVersions: effectiveMax,\n      matchedBackups: matchingFiles.length,\n      deletedBackups: toDelete.length,\n      deletedFiles: toDelete.map((file) => file.name),\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n      backupCleanupError: error?.message || String(error),\n    }\n  };\n}\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "6c9b4b90",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 6c9b4b90\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDbGVhbnVwIE9sZCBCYWNrdXBzNSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "f44043cc-3cf0-43e4-bacc-89295238518d",
      "name": "Delete Old Backups Enabled?4",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        16,
        -21328
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "cleanup-old-backups-enabled",
              "leftValue": "={{ $json.config.cleanupOldBackupsEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "47bddea4",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 47bddea4\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRGVsZXRlIE9sZCBCYWNrdXBzIEVuYWJsZWQ/NCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "a5d9bd76-8d09-41f0-9292-ffdc75da1dfa",
      "name": "Mark Backup Complete8",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        624,
        -22816
      ],
      "parameters": {
        "jsCode": "// Mark Backup Complete\n\nconst data = $input.first().json;\n\nreturn {\n  json: {\n    ...data,\n    backupSaved: true,\n    backupTimestamp: new Date().toISOString(),\n    backupPath: data.backupFullPath || null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "84b988f",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 84b988f\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJNYXJrIEJhY2t1cCBDb21wbGV0ZTgiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "cac0566b-b98b-4cf8-84cf-99691b6675f2",
      "name": "Write Backup File8",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        448,
        -22816
      ],
      "parameters": {
        "fileName": "={{ $json.backupFullPath }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "20c20b9a",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1\nüîí Hash: 20c20b9a\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uud3JpdGVCaW5hcnlGaWxlIiwibmFtZSI6IldyaXRlIEJhY2t1cCBGaWxlOCIsInR5cGVWZXJzaW9uIjoxLCJwYXJhbWV0ZXJLZXlzIjpbImZpbGVOYW1lIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "67ea8dd1-db2c-4156-bec4-078fba1e49fa",
      "name": "Convert to Binary8",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        272,
        -22816
      ],
      "parameters": {
        "jsCode": "// Convert to Binary Data\n\nconst data = $input.first().json;\n\n// Convert JSON string to binary data\nconst binaryData = Buffer.from(data.workflowJson, 'utf-8');\n\nreturn {\n  json: data,\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'application/json',\n      fileName: data.backupFilename,\n      fileExtension: 'json'\n    }\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "792aa334",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 792aa334\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDb252ZXJ0IHRvIEJpbmFyeTgiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "313a2b30-8933-4bd5-a2a2-6f4fea20faad",
      "name": "Prepare Backup Data8",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        80,
        -22816
      ],
      "parameters": {
        "jsCode": "// Prepare Backup Data - Create filename and data\n\nconst data = $input.first().json;\nconst workflow = data.updatedWorkflow;\nconst version = data.workflowVersion.current;\nconst config = data.config;\n\n// Sanitize workflow name\nconst safeName = workflow.name\n  .replace(/\\s+/g, '_')\n  .replace(/[^a-zA-Z0-9_-]/g, '')\n  .substring(0, 50);\n\n// Generate human-readable timestamp\nconst now = new Date();\nconst year = now.getFullYear();\nconst month = String(now.getMonth() + 1).padStart(2, '0');\nconst day = String(now.getDate()).padStart(2, '0');\nconst hours = String(now.getHours()).padStart(2, '0');\nconst minutes = String(now.getMinutes()).padStart(2, '0');\nconst seconds = String(now.getSeconds()).padStart(2, '0');\n\nconst timestamp = `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;\n\nconst backupPrefix = `${safeName}-v`;\nconst filename = `${backupPrefix}${version}-${timestamp}.json`;\n\nlet backupDir = config.localBackupPath || '/tmp';\nif (backupDir.startsWith('~/')) {\n  const homeDir =\n    (typeof process !== 'undefined' && process.env && process.env.HOME)\n      ? process.env.HOME\n      : '/home/node';\n  backupDir = backupDir.replace(/^~(?=\\/)/, homeDir);\n}\n\nbackupDir = backupDir.replace(/\\/+$/, '') || '/tmp';\n\nreturn {\n  json: {\n    ...data,\n    backupPrefix,\n    backupFilename: filename,\n    backupDisplayPath: backupDir,\n    backupFullPath: `${backupDir}/${filename}`,\n    workflowJson: JSON.stringify(workflow, null, 2),\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "52eca43b",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 52eca43b\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcmVwYXJlIEJhY2t1cCBEYXRhOCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "6f90f8f7-bb69-44a8-a5cd-df1ec605fde8",
      "name": "Restore Data After Update10",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -112,
        -23120
      ],
      "parameters": {
        "jsCode": "// Restore Data After HTTP Request\n\n// Get the original data from Process Node Versions\nconst processData = $(\"Process Node Versions20\").first().json;\n\n// Get the HTTP response (current input)\nconst httpResponse = $input.first().json;\n\n// Merge them - keep all original data, add HTTP response\nreturn {\n  json: {\n    ...processData,\n    httpResponse: httpResponse,\n    workflowUpdated: true\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "4a83c2c6",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 4a83c2c6\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJSZXN0b3JlIERhdGEgQWZ0ZXIgVXBkYXRlMTAiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "5c6cb766-fcd4-4eb5-b572-5d00f0535e6a",
      "name": "Local Backup Enabled?11",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        112,
        -23120
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "local-backup-enabled",
              "leftValue": "={{ $json.config.localBackupEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "277dced1",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 277dced1\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiTG9jYWwgQmFja3VwIEVuYWJsZWQ/MTEiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "04992629-658a-420b-9cbc-5ca55956bbe5",
      "name": "Build Success Response20",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1280,
        -23152
      ],
      "parameters": {
        "jsCode": "// Build Success Response\n// Merge original process data with latest branch data so backup/cleanup/git fields are preserved.\n\nconst processData = $(\"Process Node Versions20\").first().json;\nconst latestData = $input.first().json;\nconst data = {\n  ...processData,\n  ...latestData,\n};\n\nconst cleanupEnabled = data.cleanupEnabled ?? (data.config?.cleanupOldBackupsEnabled ?? false);\n\nfunction buildWorkflowOpenUrl(apiUrl, workflowId, timestamp) {\n  if (!workflowId) return null;\n\n  const rawApiUrl = String(apiUrl || '').trim();\n  if (!rawApiUrl) return null;\n\n  const normalizedApiUrl = rawApiUrl.replace(/\\/$/, '');\n  const baseUrl = normalizedApiUrl\n    .replace(/\\/api\\/v\\d+$/, '')\n    .replace(/\\/api$/, '');\n\n  return `${baseUrl}/workflow/${encodeURIComponent(workflowId)}?updated=${encodeURIComponent(timestamp)}`;\n}\n\nconst timestamp = data.timestamp || new Date().toISOString();\nconst workflowId = data.config?.workflowId || 'unknown';\nconst openWorkflowUrl = buildWorkflowOpenUrl(data.config?.n8nApiUrl, workflowId, timestamp);\n\nconst summary = {\n  success: true,\n  message: data.hasChanges\n    ? `‚úÖ Version control updated: ${data.nodeChanges.length} node${data.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId,\n  workflowName: data.updatedWorkflow?.name || data.originalWorkflow?.name || 'Unknown',\n  hasChanges: data.hasChanges || false,\n  nodeChanges: data.nodeChanges || [],\n  originalWorkflow: data.originalWorkflow,\n  updatedWorkflow: data.updatedWorkflow,\n  workflowVersion: data.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp,\n  dryRun: false,\n  openWorkflowUrl,\n};\n\nsummary.git = {\n  enabled: data.config?.gitEnabled ?? false,\n  remotePushEnabled: data.config?.gitPushEnabled ?? false,\n  repoPath: data.gitRepoPath || data.config?.gitRepoPath || null,\n  fileName: data.gitFileName || null,\n  filePath: data.gitFilePath || null,\n  branch: data.config?.gitBranch || null,\n  remote: data.config?.gitRemote || null,\n  commitMessage: data.gitCommitMessage || data.config?.commitMessage || null,\n  committed: data.gitCommitted || false,\n  pushed: data.gitPushed || false,\n  commit: data.gitCommit || null,\n  error: data.gitError || null,\n};\n\nif (data.backupSaved !== undefined) {\n  summary.backup = {\n    saved: data.backupSaved,\n    filename: data.backupFilename || null,\n    path: data.backupPath || null,\n    error: data.backupError || data.backupCleanupError || null,\n    cleanup: {\n      enabled: cleanupEnabled,\n      performed: data.cleanupPerformed || false,\n      skipped: data.cleanupSkipped || false,\n      deleted: data.deletedBackups || 0,\n      files: data.deletedFiles || [],\n      prefix: data.cleanupPrefix || null,\n      matchedBackups: data.matchedBackups || 0,\n      maxVersions: data.cleanupMaxVersions ?? null,\n    },\n  };\n}\n\nreturn { json: summary };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "59d5ea45",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 59d5ea45\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlMjAiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "d41fc130-02b4-4735-80bf-877c846709e0",
      "name": "Process Node Versions20",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -960,
        -22704
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\nconst config = $(\"Parse Configuration20\").first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldSnapshot, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldSnapshot) return { type: 'major', reason: 'New node' };\n  \n  // MAJOR: Node type changed\n  if (oldSnapshot.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldSnapshot.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldSnapshot.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldSnapshot.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Compare parameter keys (what we have in snapshot)\n  const oldKeys = (oldSnapshot.parameterKeys || []).sort();\n  const newParams = newNode.parameters || {};\n  const newParamsCopy = { ...newParams };\n  delete newParamsCopy._versionControl;\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // MINOR: Check parameter structure changes (array lengths, etc.)\n  if (oldSnapshot.parameterStructure && newParams) {\n    for (const key in oldSnapshot.parameterStructure) {\n      const oldStruct = oldSnapshot.parameterStructure[key];\n      const newParam = newParams[key];\n      \n      if (!newParam) continue; // Parameter was removed (caught above)\n      \n      // Check assignment count changes\n      if (oldStruct.assignmentCount !== undefined) {\n        const newCount = newParam.assignments?.length || 0;\n        if (oldStruct.assignmentCount !== newCount) {\n          const change = newCount > oldStruct.assignmentCount ? 'Added' : 'Removed';\n          const diff = Math.abs(newCount - oldStruct.assignmentCount);\n          return { \n            type: 'minor', \n            reason: `${change} ${diff} assignment${diff > 1 ? 's' : ''} in '${key}'`\n          };\n        }\n      }\n      \n      // Check array length changes\n      if (oldStruct.arrayLength !== undefined) {\n        const newLength = Array.isArray(newParam) ? newParam.length : 0;\n        if (oldStruct.arrayLength !== newLength) {\n          return { \n            type: 'minor', \n            reason: `Array '${key}' size changed: ${oldStruct.arrayLength} ‚Üí ${newLength}`\n          };\n        }\n      }\n      \n      // Check parameter count changes (like HTTP headers)\n      if (oldStruct.paramCount !== undefined) {\n        const newCount = newParam.parameters?.length || 0;\n        if (oldStruct.paramCount !== newCount) {\n          return { \n            type: 'minor', \n            reason: `Parameter count in '${key}' changed: ${oldStruct.paramCount} ‚Üí ${newCount}`\n          };\n        }\n      }\n    }\n  }\n  \n  // If keys are the same and structure unchanged, it's a PATCH (value change)\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const rawParts = String(version || '1.0.0').split('.').map(part => Number(part));\n  const parts = [\n    Number.isFinite(rawParts[0]) ? rawParts[0] : 1,\n    Number.isFinite(rawParts[1]) ? rawParts[1] : 0,\n    Number.isFinite(rawParts[2]) ? rawParts[2] : 0,\n  ];\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  const snapshot = {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n  \n  // Store array lengths for parameters that are arrays or contain arrays\n  // This helps detect adding/removing items (MINOR change)\n  if (node.parameters) {\n    snapshot.parameterStructure = {};\n    \n    for (const key of snapshot.parameterKeys) {\n      const param = node.parameters[key];\n      \n      if (param && typeof param === 'object') {\n        // Check for common n8n patterns\n        if (param.assignments && Array.isArray(param.assignments)) {\n          // Set/Edit Fields node with assignments\n          snapshot.parameterStructure[key] = {\n            assignmentCount: param.assignments.length\n          };\n        } else if (Array.isArray(param)) {\n          // Direct array parameter\n          snapshot.parameterStructure[key] = {\n            arrayLength: param.length\n          };\n        } else if (param.parameters && Array.isArray(param.parameters)) {\n          // HTTP Request headers/parameters\n          snapshot.parameterStructure[key] = {\n            paramCount: param.parameters.length\n          };\n        }\n      }\n    }\n  }\n  \n  return snapshot;\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const parsedExistingVersion = parseVersionFromNotes(node.notes);\n  const existingVersion = parsedExistingVersion && parsedExistingVersion.version\n    ? parsedExistingVersion\n    : {\n      version: '1.0.0',\n      created: timestamp,\n      lastModified: timestamp\n    };\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hashChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  // Check for name changes (MAJOR change that doesn't affect hash)\n  const nameChanged = storedSnapshot && storedSnapshot.name !== node.name;\n  \n  // Node has changed if hash OR name changed\n  const hasChanged = hashChanged || nameChanged;\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: config,\n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "17faf3e3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 17faf3e3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnMyMCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "1094cbed-8a4e-410e-bd2b-a9b71fc9c4cd",
      "name": "Respond to Webhook20",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        512,
        -22512
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2syMCIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsib3B0aW9ucyIsInJlc3BvbmRXaXRoIiwicmVzcG9uc2VCb2R5Il0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "a89a052e-1622-43cb-93e2-6f8445b3fdf2",
      "name": "Dry Run Response20",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -272,
        -22528
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\n\nfunction buildWorkflowOpenUrl(apiUrl, workflowId, timestamp) {\n  if (!workflowId) return null;\n\n  const rawApiUrl = String(apiUrl || '').trim();\n  if (!rawApiUrl) return null;\n\n  const normalizedApiUrl = rawApiUrl.replace(/\\/$/, '');\n  const baseUrl = normalizedApiUrl\n    .replace(/\\/api\\/v\\d+$/, '')\n    .replace(/\\/api$/, '');\n\n  return `${baseUrl}/workflow/${encodeURIComponent(workflowId)}?updated=${encodeURIComponent(timestamp)}`;\n}\n\nconst timestamp = data.timestamp || new Date().toISOString();\nconst workflowId = data.config?.workflowId || null;\nconst openWorkflowUrl = buildWorkflowOpenUrl(data.config?.n8nApiUrl, workflowId, timestamp);\n\nreturn {\n  json: {\n    success: true,\n    message: 'Dry run completed - no changes applied',\n    workflowId,\n    workflowName: data.originalWorkflow?.name,\n    version: {\n      previous: data.workflowVersion?.previous,\n      wouldBecome: data.workflowVersion?.current,\n    },\n    changes: data.nodeChanges,\n    timestamp,\n    dryRun: true,\n    openWorkflowUrl,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "54cd6021",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 54cd6021\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlMjAiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "a61d124e-5b3a-43f0-9e35-523aaaab1126",
      "name": "Update Workflow with Versions20",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -384,
        -23120
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1747da31",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 1747da31\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnMyMCIsInR5cGVWZXJzaW9uIjo0LjIsInBhcmFtZXRlcktleXMiOlsiYXV0aGVudGljYXRpb24iLCJnZW5lcmljQXV0aFR5cGUiLCJoZWFkZXJQYXJhbWV0ZXJzIiwianNvbkJvZHkiLCJtZXRob2QiLCJvcHRpb25zIiwic2VuZEJvZHkiLCJzZW5kSGVhZGVycyIsInNwZWNpZnlCb2R5IiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjF9fX0=",
      "notesInFlow": true
    },
    {
      "id": "e2a836ce-82e3-499d-a9ab-89ce1ecc3290",
      "name": "Dry Run?20",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -512,
        -22608
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj8yMCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "cc03c922-33c6-41ed-bfaf-86c5b6b8934c",
      "name": "No Changes Response20",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -160,
        -22256
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\n\nfunction buildWorkflowOpenUrl(apiUrl, workflowId, timestamp) {\n  if (!workflowId) return null;\n\n  const rawApiUrl = String(apiUrl || '').trim();\n  if (!rawApiUrl) return null;\n\n  const normalizedApiUrl = rawApiUrl.replace(/\\/$/, '');\n  const baseUrl = normalizedApiUrl\n    .replace(/\\/api\\/v\\d+$/, '')\n    .replace(/\\/api$/, '');\n\n  return `${baseUrl}/workflow/${encodeURIComponent(workflowId)}?updated=${encodeURIComponent(timestamp)}`;\n}\n\nconst timestamp = data.timestamp || new Date().toISOString();\nconst workflowId = data.config?.workflowId || null;\nconst openWorkflowUrl = buildWorkflowOpenUrl(data.config?.n8nApiUrl, workflowId, timestamp);\n\nreturn {\n  json: {\n    success: true,\n    message: 'No changes detected',\n    workflowId,\n    workflowName: data.originalWorkflow?.name,\n    version: data.workflowVersion?.current,\n    timestamp,\n    openWorkflowUrl,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2fd48f36",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2fd48f36\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlMjAiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "f3deb73d-eec5-461c-8d42-03dabe102629",
      "name": "Has Changes?20",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -800,
        -22592
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/MjAiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "c39fee21-8708-4b4d-8547-c250a1fc3d66",
      "name": "Fetch Current Workflow20",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1168,
        -22592
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7ffe44bb",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 7ffe44bb\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzIwIiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJhdXRoZW50aWNhdGlvbiIsImdlbmVyaWNBdXRoVHlwZSIsIm9wdGlvbnMiLCJ1cmwiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "f4163838-8898-460a-8f22-f980013bffe4",
      "name": "Parse Configuration20",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1344,
        -22592
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitPushEnabled: input.gitPushEnabled ?? input.body?.gitPushEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/files/backups/git-repo',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupEnabled: input.localBackupEnabled ?? input.body?.localBackupEnabled ?? false,\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  localBackupMaxVersions: input.localBackupMaxVersions ?? input.body?.localBackupMaxVersions ?? 20,\n  cleanupOldBackupsEnabled: input.cleanupOldBackupsEnabled ?? input.body?.cleanupOldBackupsEnabled ?? false,\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl || 'http://localhost:5678/api/v1',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null,\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false,\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nif (config.gitEnabled && !config.gitRepoPath) {\n  throw new Error('gitRepoPath is required when gitEnabled=true.');\n}\n\nreturn { json: config };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5892ecd9",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5892ecd9\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uMjAiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "b4c031e4-cfd0-472a-8a32-02d50882104d",
      "name": "Cleanup Old Backups6",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        912,
        -23056
      ],
      "parameters": {
        "jsCode": "// Cleanup Old Backups\n// Keep only newest N backups for the current workflow prefix.\n\nconst data = $input.first().json;\nconst config = data.config || {};\nconst cleanupEnabled = config.cleanupOldBackupsEnabled === true;\n\nif (!cleanupEnabled) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: false,\n      cleanupSkipped: true,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n    }\n  };\n}\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst backupDir = (data.backupDisplayPath || path.dirname(data.backupFullPath || '')).replace(/\\/+$/, '');\nconst currentFile = data.backupFilename || path.basename(data.backupFullPath || '');\nconst backupPrefix = data.backupPrefix || null;\n\nconst maxRaw = Number(config.localBackupMaxVersions ?? 20);\nconst maxVersions = Number.isFinite(maxRaw) ? Math.floor(maxRaw) : 20;\n\nfunction escapeRegex(value) {\n  return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction prefixFromFile(filename) {\n  const semverIndex = filename.indexOf('-v');\n  if (semverIndex > 0) return `${filename.slice(0, semverIndex)}-v`;\n  return null;\n}\n\nfunction getSortEpochMs(filename, fallbackMs) {\n  const match = filename.match(/-(\\d{4})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})\\.json$/);\n  if (!match) return fallbackMs;\n\n  const [, y, mo, d, h, mi, s] = match;\n  const dt = Date.UTC(Number(y), Number(mo) - 1, Number(d), Number(h), Number(mi), Number(s));\n  return Number.isFinite(dt) ? dt : fallbackMs;\n}\n\ntry {\n  if (!backupDir) {\n    return {\n      json: {\n        ...data,\n        cleanupEnabled: true,\n        cleanupSkipped: false,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Backup directory is missing.',\n      }\n    };\n  }\n\n  // Preserve the newest backup by default even if max is misconfigured.\n  const effectiveMax = maxVersions < 1 ? 1 : maxVersions;\n\n  const workflowPrefix = backupPrefix || prefixFromFile(currentFile);\n  if (!workflowPrefix) {\n    return {\n      json: {\n        ...data,\n        cleanupEnabled: true,\n        cleanupSkipped: false,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Unable to determine workflow backup prefix.',\n      }\n    };\n  }\n\n  const filePattern = new RegExp(\n    `^${escapeRegex(workflowPrefix)}\\\\d+\\\\.\\\\d+\\\\.\\\\d+-\\\\d{4}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}\\\\.json$`\n  );\n\n  const matchingFiles = fs\n    .readdirSync(backupDir, { withFileTypes: true })\n    .filter((entry) => entry.isFile())\n    .map((entry) => entry.name)\n    .filter((name) => filePattern.test(name))\n    .map((name) => {\n      const fullPath = path.join(backupDir, name);\n      const stats = fs.statSync(fullPath);\n      return {\n        name,\n        fullPath,\n        mtimeMs: stats.mtimeMs,\n        sortEpochMs: getSortEpochMs(name, stats.mtimeMs),\n      };\n    })\n    .sort((a, b) => {\n      if (a.sortEpochMs !== b.sortEpochMs) return a.sortEpochMs - b.sortEpochMs;\n      return a.mtimeMs - b.mtimeMs;\n    });\n\n  const deleteCount = Math.max(0, matchingFiles.length - effectiveMax);\n  const toDelete = matchingFiles.slice(0, deleteCount);\n\n  for (const file of toDelete) {\n    fs.unlinkSync(file.fullPath);\n  }\n\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: true,\n      cleanupPrefix: workflowPrefix,\n      cleanupMaxVersions: effectiveMax,\n      matchedBackups: matchingFiles.length,\n      deletedBackups: toDelete.length,\n      deletedFiles: toDelete.map((file) => file.name),\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n      backupCleanupError: error?.message || String(error),\n    }\n  };\n}\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "6c9b4b90",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 6c9b4b90\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDbGVhbnVwIE9sZCBCYWNrdXBzNiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "4e5f5b3d-6662-43d6-9f55-86977b9574b3",
      "name": "Delete Old Backups Enabled?5",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        784,
        -22816
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "cleanup-old-backups-enabled",
              "leftValue": "={{ $json.config.cleanupOldBackupsEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "47bddea4",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 47bddea4\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRGVsZXRlIE9sZCBCYWNrdXBzIEVuYWJsZWQ/NSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "bf3cced9-a387-440f-8c31-661e3de18f7c",
      "name": "Git Enabled?1",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1040,
        -23152
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "git-enabled",
              "leftValue": "={{ $json.config.gitEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "6d2083b6",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 6d2083b6\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiR2l0IEVuYWJsZWQ/MSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "cc9017d1-cada-46c3-b949-5340a7638b13",
      "name": "Prepare Git Data1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1232,
        -23344
      ],
      "parameters": {
        "jsCode": "// Prepare Git Data with stable filename (workflowId-based)\n\nconst data = $input.first().json;\nconst config = data.config || {};\n\nconst workflowId = config.workflowId || data.workflowId || 'unknown-workflow';\nconst repoPath = String(config.gitRepoPath || '/files/backups/git-repo').replace(/\\/+$/, '');\nconst gitFileName = `workflow-${workflowId}.json`;\nconst gitFilePath = `${repoPath}/${gitFileName}`;\n\nconst currentVersion = data.workflowVersion?.current || '1.0.0';\nconst commitMessage = config.commitMessage\n  || `chore(workflow): ${workflowId} -> v${currentVersion}`;\n\nconst gitWorkflowJson = `${JSON.stringify(data.updatedWorkflow, null, 2)}\n`;\n\nreturn {\n  json: {\n    ...data,\n    gitRepoPath: repoPath,\n    gitFileName,\n    gitFilePath,\n    gitWorkflowJson,\n    gitCommitMessage: commitMessage,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "6432b068",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 6432b068\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcmVwYXJlIEdpdCBEYXRhMSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "f0f48feb-7405-4148-b843-4685b3ddc4e3",
      "name": "Convert Git Workflow to Binary1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1424,
        -23344
      ],
      "parameters": {
        "jsCode": "// Convert Git workflow JSON to binary for Write Binary File node\n\nconst data = $input.first().json;\nconst binaryData = Buffer.from(data.gitWorkflowJson, 'utf-8');\n\nreturn {\n  json: data,\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'application/json',\n      fileName: data.gitFileName,\n      fileExtension: 'json',\n    }\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1e6d3a18",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 1e6d3a18\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDb252ZXJ0IEdpdCBXb3JrZmxvdyB0byBCaW5hcnkxIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "82ee1931-f6a0-4da8-a6c5-6bec7fa3c9cb",
      "name": "Write Git Workflow File1",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        1616,
        -23344
      ],
      "parameters": {
        "fileName": "={{ $json.gitFilePath }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2307914b",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1\nüîí Hash: 2307914b\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uud3JpdGVCaW5hcnlGaWxlIiwibmFtZSI6IldyaXRlIEdpdCBXb3JrZmxvdyBGaWxlMSIsInR5cGVWZXJzaW9uIjoxLCJwYXJhbWV0ZXJLZXlzIjpbImZpbGVOYW1lIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "336d2951-959a-4b9a-9354-8374c8720743",
      "name": "Git Add Workflow File1",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        1808,
        -23344
      ],
      "parameters": {
        "operation": "add",
        "repositoryPath": "={{ $(\"Prepare Git Data1\").first().json.gitRepoPath }}",
        "pathsToAdd": "={{ $(\"Prepare Git Data1\").first().json.gitFileName }}",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7c316c7c",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 7c316c7c\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBBZGQgV29ya2Zsb3cgRmlsZTEiLCJ0eXBlVmVyc2lvbiI6MS4xLCJwYXJhbWV0ZXJLZXlzIjpbIm9wZXJhdGlvbiIsInBhdGhzVG9BZGQiLCJyZXBvc2l0b3J5UGF0aCJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "f797f9b6-4d36-4b5f-9610-055b6a5a89fc",
      "name": "Git Commit Workflow File1",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        2000,
        -23344
      ],
      "parameters": {
        "operation": "commit",
        "repositoryPath": "={{ $(\"Prepare Git Data1\").first().json.gitRepoPath }}",
        "message": "={{ $(\"Prepare Git Data1\").first().json.gitCommitMessage }}",
        "options": {
          "branch": "={{ $(\"Prepare Git Data1\").first().json.config.gitBranch }}",
          "pathsToAdd": "={{ $(\"Prepare Git Data1\").first().json.gitFileName }}"
        },
        "_versionControl": {
          "version": "1.0.0",
          "hash": "66a53119",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 66a53119\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBDb21taXQgV29ya2Zsb3cgRmlsZTEiLCJ0eXBlVmVyc2lvbiI6MS4xLCJwYXJhbWV0ZXJLZXlzIjpbIm1lc3NhZ2UiLCJvcGVyYXRpb24iLCJvcHRpb25zIiwicmVwb3NpdG9yeVBhdGgiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "7a33fd62-ea1e-4d48-b600-3f7c6ed4de30",
      "name": "Git Latest Commit1",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        2192,
        -23344
      ],
      "parameters": {
        "repositoryPath": "={{ $(\"Prepare Git Data1\").first().json.gitRepoPath }}",
        "limit": 1,
        "options": {
          "file": "={{ $(\"Prepare Git Data1\").first().json.gitFileName }}"
        },
        "_versionControl": {
          "version": "1.0.0",
          "hash": "6d500564",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 6d500564\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBMYXRlc3QgQ29tbWl0MSIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsibGltaXQiLCJvcHRpb25zIiwicmVwb3NpdG9yeVBhdGgiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "f8b235a2-c822-4c30-b120-246edc7063a7",
      "name": "Git Push Enabled?1",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2384,
        -23344
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "git-push-enabled",
              "leftValue": "={{ $(\"Prepare Git Data1\").first().json.config.gitPushEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1cc95237",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 1cc95237\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiR2l0IFB1c2ggRW5hYmxlZD8xIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsiY29uZGl0aW9ucyIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "d09af7b3-4260-4d1f-97d0-22f71daecedf",
      "name": "Git Push Remote1",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        1904,
        -23744
      ],
      "parameters": {
        "operation": "push",
        "repositoryPath": "={{ $(\"Prepare Git Data1\").first().json.gitRepoPath }}",
        "options": {
          "branch": "={{ $(\"Prepare Git Data1\").first().json.config.gitBranch }}"
        },
        "_versionControl": {
          "version": "1.0.0",
          "hash": "63cf45a8",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 63cf45a8\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBQdXNoIFJlbW90ZTEiLCJ0eXBlVmVyc2lvbiI6MS4xLCJwYXJhbWV0ZXJLZXlzIjpbIm9wZXJhdGlvbiIsIm9wdGlvbnMiLCJyZXBvc2l0b3J5UGF0aCJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "07f80f61-bae0-4f09-8915-6b2539e2d302",
      "name": "Finalize Git Local1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2576,
        -23168
      ],
      "parameters": {
        "jsCode": "// Finalize Git status for local commit only\n\nconst base = $(\"Prepare Git Data1\").first().json;\nconst commit = $(\"Git Latest Commit1\").first().json;\n\nreturn {\n  json: {\n    ...base,\n    gitCommitted: true,\n    gitPushed: false,\n    gitCommit: commit\n      ? {\n          hash: commit.hash || null,\n          message: commit.message || null,\n          date: commit.date || null,\n          authorName: commit.author_name || null,\n          authorEmail: commit.author_email || null,\n        }\n      : null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "ec257ce",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: ec257ce\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJGaW5hbGl6ZSBHaXQgTG9jYWwxIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "0096877f-95ea-44d3-8773-4e27f3ede74e",
      "name": "Finalize Git Push1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2096,
        -23744
      ],
      "parameters": {
        "jsCode": "// Finalize Git status for local commit + remote push\n\nconst base = $(\"Prepare Git Data1\").first().json;\nconst commit = $(\"Git Latest Commit1\").first().json;\n\nreturn {\n  json: {\n    ...base,\n    gitCommitted: true,\n    gitPushed: true,\n    gitCommit: commit\n      ? {\n          hash: commit.hash || null,\n          message: commit.message || null,\n          date: commit.date || null,\n          authorName: commit.author_name || null,\n          authorEmail: commit.author_email || null,\n        }\n      : null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5ab09cbc",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5ab09cbc\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJGaW5hbGl6ZSBHaXQgUHVzaDEiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "5bb506ce-0813-4194-a8d2-95270a8e0fec",
      "name": "Mark Backup Complete9",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        480,
        -24448
      ],
      "parameters": {
        "jsCode": "// Mark Backup Complete\n\nconst data = $input.first().json;\n\nreturn {\n  json: {\n    ...data,\n    backupSaved: true,\n    backupTimestamp: new Date().toISOString(),\n    backupPath: data.backupFullPath || null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "84b988f",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 84b988f\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJNYXJrIEJhY2t1cCBDb21wbGV0ZTkiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "07e31d2c-ff99-4eca-8b9d-d0c8b3a8b6fd",
      "name": "Write Backup File9",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        304,
        -24448
      ],
      "parameters": {
        "fileName": "={{ $json.backupFullPath }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "20c20b9a",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1\nüîí Hash: 20c20b9a\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uud3JpdGVCaW5hcnlGaWxlIiwibmFtZSI6IldyaXRlIEJhY2t1cCBGaWxlOSIsInR5cGVWZXJzaW9uIjoxLCJwYXJhbWV0ZXJLZXlzIjpbImZpbGVOYW1lIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "b383380f-2926-442f-985c-f8bea5f7690a",
      "name": "Convert to Binary9",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        128,
        -24448
      ],
      "parameters": {
        "jsCode": "// Convert to Binary Data\n\nconst data = $input.first().json;\n\n// Convert JSON string to binary data\nconst binaryData = Buffer.from(data.workflowJson, 'utf-8');\n\nreturn {\n  json: data,\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'application/json',\n      fileName: data.backupFilename,\n      fileExtension: 'json'\n    }\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "792aa334",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 792aa334\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDb252ZXJ0IHRvIEJpbmFyeTkiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "8b01e389-5ab7-4bc2-a828-214f430669ae",
      "name": "Prepare Backup Data9",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -64,
        -24448
      ],
      "parameters": {
        "jsCode": "// Prepare Backup Data - Create filename and data\n\nconst data = $input.first().json;\nconst workflow = data.updatedWorkflow;\nconst version = data.workflowVersion.current;\nconst config = data.config;\n\n// Sanitize workflow name\nconst safeName = workflow.name\n  .replace(/\\s+/g, '_')\n  .replace(/[^a-zA-Z0-9_-]/g, '')\n  .substring(0, 50);\n\n// Generate human-readable timestamp\nconst now = new Date();\nconst year = now.getFullYear();\nconst month = String(now.getMonth() + 1).padStart(2, '0');\nconst day = String(now.getDate()).padStart(2, '0');\nconst hours = String(now.getHours()).padStart(2, '0');\nconst minutes = String(now.getMinutes()).padStart(2, '0');\nconst seconds = String(now.getSeconds()).padStart(2, '0');\n\nconst timestamp = `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;\n\nconst backupPrefix = `${safeName}-v`;\nconst filename = `${backupPrefix}${version}-${timestamp}.json`;\n\nlet backupDir = config.localBackupPath || '/tmp';\nif (backupDir.startsWith('~/')) {\n  const homeDir =\n    (typeof process !== 'undefined' && process.env && process.env.HOME)\n      ? process.env.HOME\n      : '/home/node';\n  backupDir = backupDir.replace(/^~(?=\\/)/, homeDir);\n}\n\nbackupDir = backupDir.replace(/\\/+$/, '') || '/tmp';\n\nreturn {\n  json: {\n    ...data,\n    backupPrefix,\n    backupFilename: filename,\n    backupDisplayPath: backupDir,\n    backupFullPath: `${backupDir}/${filename}`,\n    workflowJson: JSON.stringify(workflow, null, 2),\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "52eca43b",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 52eca43b\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcmVwYXJlIEJhY2t1cCBEYXRhOSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "a90c6f01-f07d-42c4-bd07-332860a14cf8",
      "name": "Restore Data After Update11",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -256,
        -24752
      ],
      "parameters": {
        "jsCode": "// Restore Data After HTTP Request\n\n// Get the original data from Process Node Versions\nconst processData = $(\"Process Node Versions21\").first().json;\n\n// Get the HTTP response (current input)\nconst httpResponse = $input.first().json;\n\n// Merge them - keep all original data, add HTTP response\nreturn {\n  json: {\n    ...processData,\n    httpResponse: httpResponse,\n    workflowUpdated: true\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "291221fb",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 291221fb\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJSZXN0b3JlIERhdGEgQWZ0ZXIgVXBkYXRlMTEiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "3576db4e-e8d3-4a7f-beb3-fe21a4314a6d",
      "name": "Local Backup Enabled?12",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -32,
        -24752
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "local-backup-enabled",
              "leftValue": "={{ $json.config.localBackupEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "277dced1",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 277dced1\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiTG9jYWwgQmFja3VwIEVuYWJsZWQ/MTIiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "834cad94-008b-4c9c-b989-7efef385bbdd",
      "name": "Build Success Response21",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1136,
        -24784
      ],
      "parameters": {
        "jsCode": "// Build Success Response\n// Merge original process data with latest branch data so backup/cleanup/git fields are preserved.\n\nconst processData = $(\"Process Node Versions21\").first().json;\nconst latestData = $input.first().json;\nconst data = {\n  ...processData,\n  ...latestData,\n};\n\nconst cleanupEnabled = data.cleanupEnabled ?? (data.config?.cleanupOldBackupsEnabled ?? false);\n\nfunction buildWorkflowOpenUrl(apiUrl, workflowId, timestamp) {\n  if (!workflowId) return null;\n\n  const rawApiUrl = String(apiUrl || '').trim();\n  if (!rawApiUrl) return null;\n\n  const normalizedApiUrl = rawApiUrl.replace(/\\/$/, '');\n  const baseUrl = normalizedApiUrl\n    .replace(/\\/api\\/v\\d+$/, '')\n    .replace(/\\/api$/, '');\n\n  return `${baseUrl}/workflow/${encodeURIComponent(workflowId)}?updated=${encodeURIComponent(timestamp)}`;\n}\n\nconst timestamp = data.timestamp || new Date().toISOString();\nconst workflowId = data.config?.workflowId || 'unknown';\nconst openWorkflowUrl = buildWorkflowOpenUrl(data.config?.n8nApiUrl, workflowId, timestamp);\n\nconst summary = {\n  success: true,\n  message: data.hasChanges\n    ? `‚úÖ Version control updated: ${data.nodeChanges.length} node${data.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId,\n  workflowName: data.updatedWorkflow?.name || data.originalWorkflow?.name || 'Unknown',\n  hasChanges: data.hasChanges || false,\n  nodeChanges: data.nodeChanges || [],\n  originalWorkflow: data.originalWorkflow,\n  updatedWorkflow: data.updatedWorkflow,\n  workflowVersion: data.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp,\n  dryRun: false,\n  openWorkflowUrl,\n};\n\nsummary.git = {\n  enabled: data.config?.gitEnabled ?? false,\n  remotePushEnabled: data.config?.gitPushEnabled ?? false,\n  repoPath: data.gitRepoPath || data.config?.gitRepoPath || null,\n  fileName: data.gitFileName || null,\n  filePath: data.gitFilePath || null,\n  branch: data.config?.gitBranch || null,\n  remote: data.config?.gitRemote || null,\n  commitMessage: data.gitCommitMessage || data.config?.commitMessage || null,\n  committed: data.gitCommitted || false,\n  pushed: data.gitPushed || false,\n  commit: data.gitCommit || null,\n  error: data.gitError || null,\n};\n\nif (data.backupSaved !== undefined) {\n  summary.backup = {\n    saved: data.backupSaved,\n    filename: data.backupFilename || null,\n    path: data.backupPath || null,\n    error: data.backupError || data.backupCleanupError || null,\n    cleanup: {\n      enabled: cleanupEnabled,\n      performed: data.cleanupPerformed || false,\n      skipped: data.cleanupSkipped || false,\n      deleted: data.deletedBackups || 0,\n      files: data.deletedFiles || [],\n      prefix: data.cleanupPrefix || null,\n      matchedBackups: data.matchedBackups || 0,\n      maxVersions: data.cleanupMaxVersions ?? null,\n    },\n  };\n}\n\nreturn { json: summary };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7b7cee4",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 7b7cee4\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlMjEiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "eab246e0-839a-4778-b7f7-bd677d0f759a",
      "name": "Process Node Versions21",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1120,
        -24224
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\nconst config = $(\"Parse Configuration21\").first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldSnapshot, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldSnapshot) return { type: 'major', reason: 'New node' };\n  \n  // MAJOR: Node type changed\n  if (oldSnapshot.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldSnapshot.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldSnapshot.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldSnapshot.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Compare parameter keys (what we have in snapshot)\n  const oldKeys = (oldSnapshot.parameterKeys || []).sort();\n  const newParams = newNode.parameters || {};\n  const newParamsCopy = { ...newParams };\n  delete newParamsCopy._versionControl;\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // MINOR: Check parameter structure changes (array lengths, etc.)\n  if (oldSnapshot.parameterStructure && newParams) {\n    for (const key in oldSnapshot.parameterStructure) {\n      const oldStruct = oldSnapshot.parameterStructure[key];\n      const newParam = newParams[key];\n      \n      if (!newParam) continue; // Parameter was removed (caught above)\n      \n      // Check assignment count changes\n      if (oldStruct.assignmentCount !== undefined) {\n        const newCount = newParam.assignments?.length || 0;\n        if (oldStruct.assignmentCount !== newCount) {\n          const change = newCount > oldStruct.assignmentCount ? 'Added' : 'Removed';\n          const diff = Math.abs(newCount - oldStruct.assignmentCount);\n          return { \n            type: 'minor', \n            reason: `${change} ${diff} assignment${diff > 1 ? 's' : ''} in '${key}'`\n          };\n        }\n      }\n      \n      // Check array length changes\n      if (oldStruct.arrayLength !== undefined) {\n        const newLength = Array.isArray(newParam) ? newParam.length : 0;\n        if (oldStruct.arrayLength !== newLength) {\n          return { \n            type: 'minor', \n            reason: `Array '${key}' size changed: ${oldStruct.arrayLength} ‚Üí ${newLength}`\n          };\n        }\n      }\n      \n      // Check parameter count changes (like HTTP headers)\n      if (oldStruct.paramCount !== undefined) {\n        const newCount = newParam.parameters?.length || 0;\n        if (oldStruct.paramCount !== newCount) {\n          return { \n            type: 'minor', \n            reason: `Parameter count in '${key}' changed: ${oldStruct.paramCount} ‚Üí ${newCount}`\n          };\n        }\n      }\n    }\n  }\n  \n  // If keys are the same and structure unchanged, it's a PATCH (value change)\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const rawParts = String(version || '1.0.0').split('.').map(part => Number(part));\n  const parts = [\n    Number.isFinite(rawParts[0]) ? rawParts[0] : 1,\n    Number.isFinite(rawParts[1]) ? rawParts[1] : 0,\n    Number.isFinite(rawParts[2]) ? rawParts[2] : 0,\n  ];\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  const snapshot = {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n  \n  // Store array lengths for parameters that are arrays or contain arrays\n  // This helps detect adding/removing items (MINOR change)\n  if (node.parameters) {\n    snapshot.parameterStructure = {};\n    \n    for (const key of snapshot.parameterKeys) {\n      const param = node.parameters[key];\n      \n      if (param && typeof param === 'object') {\n        // Check for common n8n patterns\n        if (param.assignments && Array.isArray(param.assignments)) {\n          // Set/Edit Fields node with assignments\n          snapshot.parameterStructure[key] = {\n            assignmentCount: param.assignments.length\n          };\n        } else if (Array.isArray(param)) {\n          // Direct array parameter\n          snapshot.parameterStructure[key] = {\n            arrayLength: param.length\n          };\n        } else if (param.parameters && Array.isArray(param.parameters)) {\n          // HTTP Request headers/parameters\n          snapshot.parameterStructure[key] = {\n            paramCount: param.parameters.length\n          };\n        }\n      }\n    }\n  }\n  \n  return snapshot;\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const parsedExistingVersion = parseVersionFromNotes(node.notes);\n  const existingVersion = parsedExistingVersion && parsedExistingVersion.version\n    ? parsedExistingVersion\n    : {\n      version: '1.0.0',\n      created: timestamp,\n      lastModified: timestamp\n    };\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hashChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  // Check for name changes (MAJOR change that doesn't affect hash)\n  const nameChanged = storedSnapshot && storedSnapshot.name !== node.name;\n  \n  // Node has changed if hash OR name changed\n  const hasChanged = hashChanged || nameChanged;\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: config,\n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "489505c2",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 489505c2\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnMyMSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "84be358a-5a9a-4631-baf8-cad92c784521",
      "name": "Respond to Webhook21",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        368,
        -24144
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2syMSIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsib3B0aW9ucyIsInJlc3BvbmRXaXRoIiwicmVzcG9uc2VCb2R5Il0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "b9174d5d-6107-466d-b097-c84403b9346e",
      "name": "Dry Run Response21",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -416,
        -24160
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\n\nfunction buildWorkflowOpenUrl(apiUrl, workflowId, timestamp) {\n  if (!workflowId) return null;\n\n  const rawApiUrl = String(apiUrl || '').trim();\n  if (!rawApiUrl) return null;\n\n  const normalizedApiUrl = rawApiUrl.replace(/\\/$/, '');\n  const baseUrl = normalizedApiUrl\n    .replace(/\\/api\\/v\\d+$/, '')\n    .replace(/\\/api$/, '');\n\n  return `${baseUrl}/workflow/${encodeURIComponent(workflowId)}?updated=${encodeURIComponent(timestamp)}`;\n}\n\nconst timestamp = data.timestamp || new Date().toISOString();\nconst workflowId = data.config?.workflowId || null;\nconst openWorkflowUrl = buildWorkflowOpenUrl(data.config?.n8nApiUrl, workflowId, timestamp);\n\nreturn {\n  json: {\n    success: true,\n    message: 'Dry run completed - no changes applied',\n    workflowId,\n    workflowName: data.originalWorkflow?.name,\n    version: {\n      previous: data.workflowVersion?.previous,\n      wouldBecome: data.workflowVersion?.current,\n    },\n    changes: data.nodeChanges,\n    timestamp,\n    dryRun: true,\n    openWorkflowUrl,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "54cd6021",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 54cd6021\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlMjEiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "fd0719ab-6123-476c-a86e-b545cc3fd2f4",
      "name": "Update Workflow with Versions21",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -528,
        -24752
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1747da31",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 1747da31\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnMyMSIsInR5cGVWZXJzaW9uIjo0LjIsInBhcmFtZXRlcktleXMiOlsiYXV0aGVudGljYXRpb24iLCJnZW5lcmljQXV0aFR5cGUiLCJoZWFkZXJQYXJhbWV0ZXJzIiwianNvbkJvZHkiLCJtZXRob2QiLCJvcHRpb25zIiwic2VuZEJvZHkiLCJzZW5kSGVhZGVycyIsInNwZWNpZnlCb2R5IiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjF9fX0=",
      "notesInFlow": true
    },
    {
      "id": "dabeb8f0-9b47-4b04-9a25-79fd1502d676",
      "name": "Dry Run?21",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -656,
        -24240
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj8yMSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "4eb93c15-16a2-489c-a535-5178c65f8372",
      "name": "No Changes Response21",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -304,
        -23888
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\n\nfunction buildWorkflowOpenUrl(apiUrl, workflowId, timestamp) {\n  if (!workflowId) return null;\n\n  const rawApiUrl = String(apiUrl || '').trim();\n  if (!rawApiUrl) return null;\n\n  const normalizedApiUrl = rawApiUrl.replace(/\\/$/, '');\n  const baseUrl = normalizedApiUrl\n    .replace(/\\/api\\/v\\d+$/, '')\n    .replace(/\\/api$/, '');\n\n  return `${baseUrl}/workflow/${encodeURIComponent(workflowId)}?updated=${encodeURIComponent(timestamp)}`;\n}\n\nconst timestamp = data.timestamp || new Date().toISOString();\nconst workflowId = data.config?.workflowId || null;\nconst openWorkflowUrl = buildWorkflowOpenUrl(data.config?.n8nApiUrl, workflowId, timestamp);\n\nreturn {\n  json: {\n    success: true,\n    message: 'No changes detected',\n    workflowId,\n    workflowName: data.originalWorkflow?.name,\n    version: data.workflowVersion?.current,\n    timestamp,\n    openWorkflowUrl,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2fd48f36",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2fd48f36\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlMjEiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "500a7013-094c-49b0-982c-16e308dce3b9",
      "name": "Has Changes?21",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -944,
        -24224
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/MjEiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "671415ed-54fa-4111-8d19-17dcafd4b0ec",
      "name": "Fetch Current Workflow21",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1312,
        -24224
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7ffe44bb",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 7ffe44bb\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzIxIiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJhdXRoZW50aWNhdGlvbiIsImdlbmVyaWNBdXRoVHlwZSIsIm9wdGlvbnMiLCJ1cmwiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "34b6e4e9-9176-405f-a3a0-e4ec51c95f53",
      "name": "Parse Configuration21",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1488,
        -24224
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitPushEnabled: input.gitPushEnabled ?? input.body?.gitPushEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/files/backups/git-repo',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupEnabled: input.localBackupEnabled ?? input.body?.localBackupEnabled ?? false,\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/data/workflow-backups/local',\n  localBackupMaxVersions: input.localBackupMaxVersions ?? input.body?.localBackupMaxVersions ?? 20,\n  cleanupOldBackupsEnabled: input.cleanupOldBackupsEnabled ?? input.body?.cleanupOldBackupsEnabled ?? false,\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl || 'http://localhost:5678/api/v1',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null,\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false,\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nif (config.gitEnabled && !config.gitRepoPath) {\n  throw new Error('gitRepoPath is required when gitEnabled=true.');\n}\n\nreturn { json: config };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5892ecd9",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5892ecd9\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uMjEiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "0f8e4d5a-ed93-41fe-8b5e-a406c6e2c97e",
      "name": "Cleanup Old Backups7",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        768,
        -24688
      ],
      "parameters": {
        "jsCode": "// Cleanup Old Backups\n// Keep only newest N backups for the current workflow prefix.\n\nconst data = $input.first().json;\nconst config = data.config || {};\nconst cleanupEnabled = config.cleanupOldBackupsEnabled === true;\n\nif (!cleanupEnabled) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: false,\n      cleanupSkipped: true,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n    }\n  };\n}\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst backupDir = (data.backupDisplayPath || path.dirname(data.backupFullPath || '')).replace(/\\/+$/, '');\nconst currentFile = data.backupFilename || path.basename(data.backupFullPath || '');\nconst backupPrefix = data.backupPrefix || null;\n\nconst maxRaw = Number(config.localBackupMaxVersions ?? 20);\nconst maxVersions = Number.isFinite(maxRaw) ? Math.floor(maxRaw) : 20;\n\nfunction escapeRegex(value) {\n  return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction prefixFromFile(filename) {\n  const semverIndex = filename.indexOf('-v');\n  if (semverIndex > 0) return `${filename.slice(0, semverIndex)}-v`;\n  return null;\n}\n\nfunction getSortEpochMs(filename, fallbackMs) {\n  const match = filename.match(/-(\\d{4})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})\\.json$/);\n  if (!match) return fallbackMs;\n\n  const [, y, mo, d, h, mi, s] = match;\n  const dt = Date.UTC(Number(y), Number(mo) - 1, Number(d), Number(h), Number(mi), Number(s));\n  return Number.isFinite(dt) ? dt : fallbackMs;\n}\n\ntry {\n  if (!backupDir) {\n    return {\n      json: {\n        ...data,\n        cleanupEnabled: true,\n        cleanupSkipped: false,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Backup directory is missing.',\n      }\n    };\n  }\n\n  // Preserve the newest backup by default even if max is misconfigured.\n  const effectiveMax = maxVersions < 1 ? 1 : maxVersions;\n\n  const workflowPrefix = backupPrefix || prefixFromFile(currentFile);\n  if (!workflowPrefix) {\n    return {\n      json: {\n        ...data,\n        cleanupEnabled: true,\n        cleanupSkipped: false,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Unable to determine workflow backup prefix.',\n      }\n    };\n  }\n\n  const filePattern = new RegExp(\n    `^${escapeRegex(workflowPrefix)}\\\\d+\\\\.\\\\d+\\\\.\\\\d+-\\\\d{4}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}\\\\.json$`\n  );\n\n  const matchingFiles = fs\n    .readdirSync(backupDir, { withFileTypes: true })\n    .filter((entry) => entry.isFile())\n    .map((entry) => entry.name)\n    .filter((name) => filePattern.test(name))\n    .map((name) => {\n      const fullPath = path.join(backupDir, name);\n      const stats = fs.statSync(fullPath);\n      return {\n        name,\n        fullPath,\n        mtimeMs: stats.mtimeMs,\n        sortEpochMs: getSortEpochMs(name, stats.mtimeMs),\n      };\n    })\n    .sort((a, b) => {\n      if (a.sortEpochMs !== b.sortEpochMs) return a.sortEpochMs - b.sortEpochMs;\n      return a.mtimeMs - b.mtimeMs;\n    });\n\n  const deleteCount = Math.max(0, matchingFiles.length - effectiveMax);\n  const toDelete = matchingFiles.slice(0, deleteCount);\n\n  for (const file of toDelete) {\n    fs.unlinkSync(file.fullPath);\n  }\n\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: true,\n      cleanupPrefix: workflowPrefix,\n      cleanupMaxVersions: effectiveMax,\n      matchedBackups: matchingFiles.length,\n      deletedBackups: toDelete.length,\n      deletedFiles: toDelete.map((file) => file.name),\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n      backupCleanupError: error?.message || String(error),\n    }\n  };\n}\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "6c9b4b90",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 6c9b4b90\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDbGVhbnVwIE9sZCBCYWNrdXBzNyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "37eabe21-ace8-47b4-b939-52ed23775f28",
      "name": "Delete Old Backups Enabled?6",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        640,
        -24448
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "cleanup-old-backups-enabled",
              "leftValue": "={{ $json.config.cleanupOldBackupsEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "47bddea4",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 47bddea4\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRGVsZXRlIE9sZCBCYWNrdXBzIEVuYWJsZWQ/NiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "dcf7e557-26ee-46bb-ab4e-9466a47fe2e7",
      "name": "Git Enabled?2",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        896,
        -24784
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "git-enabled",
              "leftValue": "={{ $json.config.gitEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "6d2083b6",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 6d2083b6\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiR2l0IEVuYWJsZWQ/MiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "623befee-04a2-4e1d-8125-45b06b9433fd",
      "name": "Prepare Git Data2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1088,
        -24976
      ],
      "parameters": {
        "jsCode": "// Prepare Git Data with stable filename (workflowId-based)\n\nconst data = $input.first().json;\nconst config = data.config || {};\n\nconst workflowId = config.workflowId || data.workflowId || 'unknown-workflow';\nconst repoPath = String(config.gitRepoPath || '/files/backups/git-repo').replace(/\\/+$/, '');\nconst gitFileName = `workflow-${workflowId}.json`;\nconst gitFilePath = `${repoPath}/${gitFileName}`;\n\nconst currentVersion = data.workflowVersion?.current || '1.0.0';\nconst workflowName = String(data.updatedWorkflow?.name || data.originalWorkflow?.name || 'Unknown Workflow')\n  .replace(/\\s+/g, ' ')\n  .trim();\nconst commitMessage = config.commitMessage\n  || `chore(workflow): ${workflowName} (${workflowId}) -> v${currentVersion}`;\n\nconst gitWorkflowJson = `${JSON.stringify(data.updatedWorkflow, null, 2)}\n`;\n\nreturn {\n  json: {\n    ...data,\n    gitRepoPath: repoPath,\n    gitFileName,\n    gitFilePath,\n    gitWorkflowJson,\n    gitCommitMessage: commitMessage,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "57b1e7cc",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 57b1e7cc\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcmVwYXJlIEdpdCBEYXRhMiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "eca6e8f3-3ddd-4951-9910-75b54eda8ce0",
      "name": "Convert Git Workflow to Binary2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1280,
        -24976
      ],
      "parameters": {
        "jsCode": "// Convert Git workflow JSON to binary for Write Binary File node\n\nconst data = $input.first().json;\nconst binaryData = Buffer.from(data.gitWorkflowJson, 'utf-8');\n\nreturn {\n  json: data,\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'application/json',\n      fileName: data.gitFileName,\n      fileExtension: 'json',\n    }\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1e6d3a18",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 1e6d3a18\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDb252ZXJ0IEdpdCBXb3JrZmxvdyB0byBCaW5hcnkyIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "88ffffc4-c33b-4d43-bdf3-036852446162",
      "name": "Write Git Workflow File2",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        1472,
        -24976
      ],
      "parameters": {
        "fileName": "={{ $json.gitFilePath }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2307914b",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1\nüîí Hash: 2307914b\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uud3JpdGVCaW5hcnlGaWxlIiwibmFtZSI6IldyaXRlIEdpdCBXb3JrZmxvdyBGaWxlMiIsInR5cGVWZXJzaW9uIjoxLCJwYXJhbWV0ZXJLZXlzIjpbImZpbGVOYW1lIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "b3ea0599-4af2-4285-9f3e-b1d7f0a904fa",
      "name": "Git Add Workflow File2",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        1664,
        -24976
      ],
      "parameters": {
        "operation": "add",
        "repositoryPath": "={{ $(\"Prepare Git Data2\").first().json.gitRepoPath }}",
        "pathsToAdd": "={{ $(\"Prepare Git Data2\").first().json.gitFileName }}",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2dd1fe",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 2dd1fe\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBBZGQgV29ya2Zsb3cgRmlsZTIiLCJ0eXBlVmVyc2lvbiI6MS4xLCJwYXJhbWV0ZXJLZXlzIjpbIm9wZXJhdGlvbiIsInBhdGhzVG9BZGQiLCJyZXBvc2l0b3J5UGF0aCJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "55674200-5e89-4164-bc9f-f2022df88198",
      "name": "Git Commit Workflow File2",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        1856,
        -24976
      ],
      "parameters": {
        "operation": "commit",
        "repositoryPath": "={{ $(\"Prepare Git Data2\").first().json.gitRepoPath }}",
        "message": "={{ $(\"Prepare Git Data2\").first().json.gitCommitMessage }}",
        "options": {
          "branch": "={{ $(\"Prepare Git Data2\").first().json.config.gitBranch }}",
          "pathsToAdd": "={{ $(\"Prepare Git Data2\").first().json.gitFileName }}"
        },
        "_versionControl": {
          "version": "1.0.0",
          "hash": "66008c2b",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 66008c2b\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBDb21taXQgV29ya2Zsb3cgRmlsZTIiLCJ0eXBlVmVyc2lvbiI6MS4xLCJwYXJhbWV0ZXJLZXlzIjpbIm1lc3NhZ2UiLCJvcGVyYXRpb24iLCJvcHRpb25zIiwicmVwb3NpdG9yeVBhdGgiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "2a724a46-22cc-4460-9c5b-a22a06d11ddd",
      "name": "Git Latest Commit2",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        2048,
        -24976
      ],
      "parameters": {
        "repositoryPath": "={{ $(\"Prepare Git Data2\").first().json.gitRepoPath }}",
        "limit": 1,
        "options": {
          "file": "={{ $(\"Prepare Git Data2\").first().json.gitFileName }}"
        },
        "_versionControl": {
          "version": "1.0.0",
          "hash": "43abdb06",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 43abdb06\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBMYXRlc3QgQ29tbWl0MiIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsibGltaXQiLCJvcHRpb25zIiwicmVwb3NpdG9yeVBhdGgiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "05b4db2c-61d1-4907-9e8a-5b07908e4522",
      "name": "Git Push Enabled?2",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2240,
        -24976
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "git-push-enabled",
              "leftValue": "={{ $(\"Prepare Git Data2\").first().json.config.gitPushEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "84f7678",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 84f7678\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiR2l0IFB1c2ggRW5hYmxlZD8yIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsiY29uZGl0aW9ucyIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "76632bc7-1084-4eb7-b36a-38c215e036b5",
      "name": "Git Push Remote2",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        2432,
        -25072
      ],
      "parameters": {
        "authentication": "gitPassword",
        "operation": "push",
        "repositoryPath": "={{ $(\"Prepare Git Data2\").first().json.gitRepoPath }}",
        "options": {
          "branch": "={{ $(\"Prepare Git Data2\").first().json.config.gitBranch }}"
        },
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7bb34451",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 7bb34451\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBQdXNoIFJlbW90ZTIiLCJ0eXBlVmVyc2lvbiI6MS4xLCJwYXJhbWV0ZXJLZXlzIjpbImF1dGhlbnRpY2F0aW9uIiwib3BlcmF0aW9uIiwib3B0aW9ucyIsInJlcG9zaXRvcnlQYXRoIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "5610f9f6-64e4-400b-9dd3-9ed49ef75d4f",
      "name": "Finalize Git Local2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2432,
        -24800
      ],
      "parameters": {
        "jsCode": "// Finalize Git status for local commit only\n\nconst base = $(\"Prepare Git Data2\").first().json;\nconst commit = $(\"Git Latest Commit2\").first().json;\n\nreturn {\n  json: {\n    ...base,\n    gitCommitted: true,\n    gitPushed: false,\n    gitCommit: commit\n      ? {\n          hash: commit.hash || null,\n          message: commit.message || null,\n          date: commit.date || null,\n          authorName: commit.author_name || null,\n          authorEmail: commit.author_email || null,\n        }\n      : null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "586be74",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 586be74\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJGaW5hbGl6ZSBHaXQgTG9jYWwyIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "5d7542cb-81e9-44d2-b004-09a167d5acef",
      "name": "Finalize Git Push2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2624,
        -25072
      ],
      "parameters": {
        "jsCode": "// Finalize Git status for local commit + remote push\n\nconst base = $(\"Prepare Git Data2\").first().json;\nconst commit = $(\"Git Latest Commit2\").first().json;\n\nreturn {\n  json: {\n    ...base,\n    gitCommitted: true,\n    gitPushed: true,\n    gitCommit: commit\n      ? {\n          hash: commit.hash || null,\n          message: commit.message || null,\n          date: commit.date || null,\n          authorName: commit.author_name || null,\n          authorEmail: commit.author_email || null,\n        }\n      : null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "20d10d42",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 20d10d42\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJGaW5hbGl6ZSBHaXQgUHVzaDIiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "20d5924f-222c-4f4f-bb68-e2f88991ebda",
      "name": "Manual Save Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -1008,
        -28480
      ],
      "parameters": {
        "_versionControl": {
          "version": "1.0.2",
          "hash": "4f01dfa4",
          "created": "Feb 6, 2026, 05:16 PM",
          "lastModified": "Feb 6, 2026, 07:42 PM"
        }
      },
      "notes": "üìå Version: 1.0.2\nüìÖ Modified: Feb 6, 2026, 07:42 PM\nüîß Node Type: v1\nüîí Hash: 4f01dfa4\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UubWFudWFsVHJpZ2dlciIsIm5hbWUiOiJNYW51YWwgU2F2ZSBUcmlnZ2VyIiwidHlwZVZlcnNpb24iOjEsInBhcmFtZXRlcktleXMiOltdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==\nüÜï Created: Feb 6, 2026, 05:16 PM",
      "notesInFlow": true
    },
    {
      "id": "799a15b5-692f-44c1-8750-ebd44b43c0ff",
      "name": "Set Version Control Config1",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -784,
        -28480
      ],
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "1",
              "name": "workflowId",
              "value": "={{ $workflow.id }}",
              "type": "string"
            },
            {
              "id": "2",
              "name": "gitEnabled",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "7",
              "name": "localBackupEnabled",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "3",
              "name": "localBackupPath",
              "value": "/files/backups",
              "type": "string"
            },
            {
              "id": "9",
              "name": "localBackupMaxVersions",
              "value": 20,
              "type": "number"
            },
            {
              "id": "4",
              "name": "n8nApiUrl",
              "value": "http://localhost:5678/api/v1",
              "type": "string"
            },
            {
              "id": "6",
              "name": "dryRun",
              "value": false,
              "type": "boolean"
            },
            {
              "id": "10",
              "name": "cleanupOldBackupsEnabled",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "11",
              "name": "gitPushEnabled",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "12",
              "name": "gitRepoPath",
              "value": "/files/backups/git-repo",
              "type": "string"
            },
            {
              "id": "13",
              "name": "gitBranch",
              "value": "main",
              "type": "string"
            },
            {
              "id": "14",
              "name": "gitRemote",
              "value": "origin",
              "type": "string"
            }
          ]
        },
        "options": {},
        "_versionControl": {
          "version": "1.2.1",
          "hash": "30fbd73e",
          "created": "Feb 6, 2026, 05:16 PM",
          "lastModified": "Feb 8, 2026, 01:52 AM"
        }
      },
      "notes": "üìå Version: 1.2.1\nüìÖ Modified: Feb 8, 2026, 01:52 AM\nüîß Node Type: v3.4\nüîí Hash: 30fbd73e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uuc2V0IiwibmFtZSI6IlNldCBWZXJzaW9uIENvbnRyb2wgQ29uZmlnMSIsInR5cGVWZXJzaW9uIjozLjQsInBhcmFtZXRlcktleXMiOlsiYXNzaWdubWVudHMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJhc3NpZ25tZW50cyI6eyJhc3NpZ25tZW50Q291bnQiOjEyfX19\nüÜï Created: Feb 6, 2026, 05:16 PM",
      "notesInFlow": true
    },
    {
      "id": "1180bce9-2fd1-47df-a112-4fcb3f5d924e",
      "name": "Call Sub-workflow (update value)1",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        -544,
        -28480
      ],
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "XgpTIAZCl4XT2rlPS-NgC",
          "mode": "list",
          "cachedResultUrl": "/workflow/XgpTIAZCl4XT2rlPS-NgC",
          "cachedResultName": "Subworkflow (Version Control)"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.2",
          "hash": "32f23958",
          "created": "Feb 6, 2026, 05:16 PM",
          "lastModified": "Feb 6, 2026, 07:42 PM"
        }
      },
      "notes": "üìå Version: 1.0.2\nüìÖ Modified: Feb 6, 2026, 07:42 PM\nüîß Node Type: v1.2\nüîí Hash: 32f23958\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZXhlY3V0ZVdvcmtmbG93IiwibmFtZSI6IkNhbGwgU3ViLXdvcmtmbG93ICh1cGRhdGUgdmFsdWUpMSIsInR5cGVWZXJzaW9uIjoxLjIsInBhcmFtZXRlcktleXMiOlsib3B0aW9ucyIsIndvcmtmbG93SWQiLCJ3b3JrZmxvd0lucHV0cyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==\nüÜï Created: Feb 6, 2026, 05:16 PM",
      "notesInFlow": true
    },
    {
      "id": "df58dc88-a6ec-40db-a7a1-3ab0484ff6bc",
      "name": "Show Completion Message1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -304,
        -28480
      ],
      "parameters": {
        "jsCode": "const result = $input.first().json;\n\nif (!result || result.hasChanges === undefined) {\n  return {\n    json: {\n      status: \"‚ÑπÔ∏è NO CHANGES\",\n      message: \"No result from version control subworkflow\",\n      action: \"Check subworkflow execution\",\n      openWorkflowUrl: null,\n    }\n  };\n}\n\nconst changesList = result.nodeChanges?.map((c) => {\n  if (c.action === 'created') {\n    return `‚ûï ${c.nodeName}: v${c.version} (new)`;\n  }\n\n  if (c.action === 'modified') {\n    let icon = '‚úèÔ∏è';\n    let badge = '';\n\n    if (c.changeType === 'major') {\n      icon = 'üö®';\n      badge = ' [MAJOR]';\n    } else if (c.changeType === 'minor') {\n      icon = '‚ö†Ô∏è';\n      badge = ' [MINOR]';\n    }\n\n    const reasonLine = c.reason ? `\\n   ‚îî‚îÄ ${c.reason}` : '';\n    return `${icon} ${c.nodeName}: v${c.previousVersion} ‚Üí v${c.version}${badge}${reasonLine}`;\n  }\n\n  return `${c.nodeName}: v${c.version}`;\n}).join('\\n') || 'No changes detected';\n\nconst majorCount = result.nodeChanges?.filter((c) => c.changeType === 'major').length || 0;\nconst minorCount = result.nodeChanges?.filter((c) => c.changeType === 'minor').length || 0;\nconst patchCount = result.nodeChanges?.filter((c) => c.changeType === 'patch').length || 0;\n\nconst summaryParts = [];\nif (majorCount > 0) summaryParts.push(`${majorCount} MAJOR`);\nif (minorCount > 0) summaryParts.push(`${minorCount} MINOR`);\nif (patchCount > 0) summaryParts.push(`${patchCount} PATCH`);\n\nconst changeSummary = summaryParts.length > 0\n  ? ` (${summaryParts.join(', ')})`\n  : '';\n\nconst openWorkflowUrl = result.openWorkflowUrl || null;\nconst git = result.git || {};\n\nconst commitHashShort = git.commit?.hash ? String(git.commit.hash).slice(0, 8) : null;\nconst gitStatus = git.enabled\n  ? `Git ${git.committed ? 'committed' : 'not committed'}${git.remotePushEnabled ? (git.pushed ? ' + pushed' : ' (push not enabled/completed)') : ''}`\n  : 'Git disabled';\n\nlet tip = \"üí° Tip: Open the workflow URL below to load the latest version without manual refresh.\";\nif (majorCount > 0) {\n  tip = \"‚ö†Ô∏è MAJOR changes detected! Review carefully before activating.\";\n} else if (minorCount > 0) {\n  tip = \"üí° MINOR changes detected. Re-test key paths after update.\";\n}\n\nreturn {\n  json: {\n    status: result.hasChanges ? \"‚úÖ SUCCESS\" : \"‚ÑπÔ∏è NO CHANGES\",\n    message: result.hasChanges\n      ? `Version control updated successfully!${changeSummary}`\n      : \"No node changes detected - all versions remain the same\",\n    action: openWorkflowUrl\n      ? `Open updated workflow: ${openWorkflowUrl}`\n      : (result.hasChanges\n        ? \"Update completed. Open the workflow again from the list to load latest state.\"\n        : \"No action needed\"),\n    openWorkflowUrl,\n    details: {\n      workflowId: result.workflowId || null,\n      workflowName: result.workflowName || result.originalWorkflow?.name || \"Unknown\",\n      totalNodes: result.updatedWorkflow?.nodes?.length || 0,\n      changedNodes: result.nodeChanges?.length || 0,\n      majorChanges: majorCount,\n      minorChanges: minorCount,\n      patchChanges: patchCount,\n      gitStatus,\n      gitRepoPath: git.repoPath || null,\n      gitFilePath: git.filePath || null,\n      gitBranch: git.branch || null,\n      gitCommitHash: commitHashShort,\n      timestamp: new Date().toLocaleString('en-US', {\n        month: 'short',\n        day: 'numeric',\n        year: 'numeric',\n        hour: '2-digit',\n        minute: '2-digit',\n        second: '2-digit',\n      }),\n    },\n    changes: changesList,\n    git,\n    tip,\n  },\n};\n",
        "_versionControl": {
          "version": "1.0.6",
          "hash": "53972c67",
          "created": "Feb 6, 2026, 05:16 PM",
          "lastModified": "Feb 8, 2026, 01:31 AM"
        }
      },
      "notes": "üìå Version: 1.0.6\nüìÖ Modified: Feb 8, 2026, 01:31 AM\nüîß Node Type: v2\nüîí Hash: 53972c67\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJTaG93IENvbXBsZXRpb24gTWVzc2FnZTEiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=\nüÜï Created: Feb 6, 2026, 05:16 PM",
      "notesInFlow": true
    },
    {
      "id": "ae36f204-ccd2-41c3-8eac-6706e6699105",
      "name": "Mark Backup Complete10",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1056,
        -27488
      ],
      "parameters": {
        "jsCode": "// Mark Backup Complete\n\nconst data = $input.first().json;\n\nreturn {\n  json: {\n    ...data,\n    backupSaved: true,\n    backupTimestamp: new Date().toISOString(),\n    backupPath: data.backupFullPath || null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "84b988f",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 84b988f\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJNYXJrIEJhY2t1cCBDb21wbGV0ZTEwIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "ac026f17-8033-4dfb-aa7c-956f3bb66f48",
      "name": "Write Backup File10",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        880,
        -27488
      ],
      "parameters": {
        "fileName": "={{ $json.backupFullPath }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "20c20b9a",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1\nüîí Hash: 20c20b9a\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uud3JpdGVCaW5hcnlGaWxlIiwibmFtZSI6IldyaXRlIEJhY2t1cCBGaWxlMTAiLCJ0eXBlVmVyc2lvbiI6MSwicGFyYW1ldGVyS2V5cyI6WyJmaWxlTmFtZSIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "8eaf1395-fdfe-4a08-bc13-e39921a31fbe",
      "name": "Convert to Binary10",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        704,
        -27488
      ],
      "parameters": {
        "jsCode": "// Convert to Binary Data\n\nconst data = $input.first().json;\n\n// Convert JSON string to binary data\nconst binaryData = Buffer.from(data.workflowJson, 'utf-8');\n\nreturn {\n  json: data,\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'application/json',\n      fileName: data.backupFilename,\n      fileExtension: 'json'\n    }\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "792aa334",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 792aa334\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDb252ZXJ0IHRvIEJpbmFyeTEwIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "81a81dd9-41a1-4633-bed2-47667b7e2727",
      "name": "Prepare Backup Data10",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        512,
        -27488
      ],
      "parameters": {
        "jsCode": "// Prepare Backup Data - Create filename and data\n\nconst data = $input.first().json;\nconst workflow = data.updatedWorkflow;\nconst version = data.workflowVersion.current;\nconst config = data.config;\n\n// Sanitize workflow name\nconst safeName = workflow.name\n  .replace(/\\s+/g, '_')\n  .replace(/[^a-zA-Z0-9_-]/g, '')\n  .substring(0, 50);\n\n// Generate human-readable timestamp\nconst now = new Date();\nconst year = now.getFullYear();\nconst month = String(now.getMonth() + 1).padStart(2, '0');\nconst day = String(now.getDate()).padStart(2, '0');\nconst hours = String(now.getHours()).padStart(2, '0');\nconst minutes = String(now.getMinutes()).padStart(2, '0');\nconst seconds = String(now.getSeconds()).padStart(2, '0');\n\nconst timestamp = `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;\n\nconst backupPrefix = `${safeName}-v`;\nconst filename = `${backupPrefix}${version}-${timestamp}.json`;\n\nlet backupDir = config.localBackupPath || '/tmp';\nif (backupDir.startsWith('~/')) {\n  const homeDir =\n    (typeof process !== 'undefined' && process.env && process.env.HOME)\n      ? process.env.HOME\n      : '/home/node';\n  backupDir = backupDir.replace(/^~(?=\\/)/, homeDir);\n}\n\nbackupDir = backupDir.replace(/\\/+$/, '') || '/tmp';\n\nreturn {\n  json: {\n    ...data,\n    backupPrefix,\n    backupFilename: filename,\n    backupDisplayPath: backupDir,\n    backupFullPath: `${backupDir}/${filename}`,\n    workflowJson: JSON.stringify(workflow, null, 2),\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "52eca43b",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 52eca43b\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcmVwYXJlIEJhY2t1cCBEYXRhMTAiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "3aaaeb0d-4a0c-40e5-96b1-9291a8deef7a",
      "name": "Restore Data After Update12",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        320,
        -27792
      ],
      "parameters": {
        "jsCode": "// Restore Data After HTTP Request\n\n// Get the original data from Process Node Versions\nconst processData = $(\"Process Node Versions22\").first().json;\n\n// Get the HTTP response (current input)\nconst httpResponse = $input.first().json;\n\n// Merge them - keep all original data, add HTTP response\nreturn {\n  json: {\n    ...processData,\n    httpResponse: httpResponse,\n    workflowUpdated: true\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "6357f944",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 6357f944\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJSZXN0b3JlIERhdGEgQWZ0ZXIgVXBkYXRlMTIiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "a31a0bc2-e863-4a68-b034-40b1b256b6e9",
      "name": "Local Backup Enabled?13",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        544,
        -27792
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "local-backup-enabled",
              "leftValue": "={{ $json.config.localBackupEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "277dced1",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 277dced1\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiTG9jYWwgQmFja3VwIEVuYWJsZWQ/MTMiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "ff7ddab5-080e-49ed-a069-2171a4670d0d",
      "name": "Build Success Response22",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1712,
        -27824
      ],
      "parameters": {
        "jsCode": "// Build Success Response\n// Merge original process data with latest branch data so backup/cleanup/git fields are preserved.\n\nconst processData = $(\"Process Node Versions22\").first().json;\nconst latestData = $input.first().json;\nconst data = {\n  ...processData,\n  ...latestData,\n};\n\nconst cleanupEnabled = data.cleanupEnabled ?? (data.config?.cleanupOldBackupsEnabled ?? false);\n\nfunction buildWorkflowOpenUrl(apiUrl, workflowId, timestamp) {\n  if (!workflowId) return null;\n\n  const rawApiUrl = String(apiUrl || '').trim();\n  if (!rawApiUrl) return null;\n\n  const normalizedApiUrl = rawApiUrl.replace(/\\/$/, '');\n  const baseUrl = normalizedApiUrl\n    .replace(/\\/api\\/v\\d+$/, '')\n    .replace(/\\/api$/, '');\n\n  return `${baseUrl}/workflow/${encodeURIComponent(workflowId)}?updated=${encodeURIComponent(timestamp)}`;\n}\n\nconst timestamp = data.timestamp || new Date().toISOString();\nconst workflowId = data.config?.workflowId || 'unknown';\nconst openWorkflowUrl = buildWorkflowOpenUrl(data.config?.n8nApiUrl, workflowId, timestamp);\n\nconst summary = {\n  success: true,\n  message: data.hasChanges\n    ? `‚úÖ Version control updated: ${data.nodeChanges.length} node${data.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId,\n  workflowName: data.updatedWorkflow?.name || data.originalWorkflow?.name || 'Unknown',\n  hasChanges: data.hasChanges || false,\n  nodeChanges: data.nodeChanges || [],\n  originalWorkflow: data.originalWorkflow,\n  updatedWorkflow: data.updatedWorkflow,\n  workflowVersion: data.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp,\n  dryRun: false,\n  openWorkflowUrl,\n};\n\nsummary.git = {\n  enabled: data.config?.gitEnabled ?? false,\n  remotePushEnabled: data.config?.gitPushEnabled ?? false,\n  repoPath: data.gitRepoPath || data.config?.gitRepoPath || null,\n  fileName: data.gitFileName || null,\n  filePath: data.gitFilePath || null,\n  branch: data.config?.gitBranch || null,\n  remote: data.config?.gitRemote || null,\n  commitMessage: data.gitCommitMessage || data.config?.commitMessage || null,\n  committed: data.gitCommitted || false,\n  pushed: data.gitPushed || false,\n  commit: data.gitCommit || null,\n  error: data.gitError || null,\n};\n\nif (data.backupSaved !== undefined) {\n  summary.backup = {\n    saved: data.backupSaved,\n    filename: data.backupFilename || null,\n    path: data.backupPath || null,\n    error: data.backupError || data.backupCleanupError || null,\n    cleanup: {\n      enabled: cleanupEnabled,\n      performed: data.cleanupPerformed || false,\n      skipped: data.cleanupSkipped || false,\n      deleted: data.deletedBackups || 0,\n      files: data.deletedFiles || [],\n      prefix: data.cleanupPrefix || null,\n      matchedBackups: data.matchedBackups || 0,\n      maxVersions: data.cleanupMaxVersions ?? null,\n    },\n  };\n}\n\nreturn { json: summary };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "4a664c7d",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 4a664c7d\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlMjIiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "c87e9e69-1aa8-4093-8a6e-de3d960fad3b",
      "name": "Process Node Versions22",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -528,
        -27376
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\nconst config = $(\"Parse Configuration22\").first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldSnapshot, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldSnapshot) return { type: 'major', reason: 'New node' };\n  \n  // MAJOR: Node type changed\n  if (oldSnapshot.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldSnapshot.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldSnapshot.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldSnapshot.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Compare parameter keys (what we have in snapshot)\n  const oldKeys = (oldSnapshot.parameterKeys || []).sort();\n  const newParams = newNode.parameters || {};\n  const newParamsCopy = { ...newParams };\n  delete newParamsCopy._versionControl;\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // MINOR: Check parameter structure changes (array lengths, etc.)\n  if (oldSnapshot.parameterStructure && newParams) {\n    for (const key in oldSnapshot.parameterStructure) {\n      const oldStruct = oldSnapshot.parameterStructure[key];\n      const newParam = newParams[key];\n      \n      if (!newParam) continue; // Parameter was removed (caught above)\n      \n      // Check assignment count changes\n      if (oldStruct.assignmentCount !== undefined) {\n        const newCount = newParam.assignments?.length || 0;\n        if (oldStruct.assignmentCount !== newCount) {\n          const change = newCount > oldStruct.assignmentCount ? 'Added' : 'Removed';\n          const diff = Math.abs(newCount - oldStruct.assignmentCount);\n          return { \n            type: 'minor', \n            reason: `${change} ${diff} assignment${diff > 1 ? 's' : ''} in '${key}'`\n          };\n        }\n      }\n      \n      // Check array length changes\n      if (oldStruct.arrayLength !== undefined) {\n        const newLength = Array.isArray(newParam) ? newParam.length : 0;\n        if (oldStruct.arrayLength !== newLength) {\n          return { \n            type: 'minor', \n            reason: `Array '${key}' size changed: ${oldStruct.arrayLength} ‚Üí ${newLength}`\n          };\n        }\n      }\n      \n      // Check parameter count changes (like HTTP headers)\n      if (oldStruct.paramCount !== undefined) {\n        const newCount = newParam.parameters?.length || 0;\n        if (oldStruct.paramCount !== newCount) {\n          return { \n            type: 'minor', \n            reason: `Parameter count in '${key}' changed: ${oldStruct.paramCount} ‚Üí ${newCount}`\n          };\n        }\n      }\n    }\n  }\n  \n  // If keys are the same and structure unchanged, it's a PATCH (value change)\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const rawParts = String(version || '1.0.0').split('.').map(part => Number(part));\n  const parts = [\n    Number.isFinite(rawParts[0]) ? rawParts[0] : 1,\n    Number.isFinite(rawParts[1]) ? rawParts[1] : 0,\n    Number.isFinite(rawParts[2]) ? rawParts[2] : 0,\n  ];\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  const snapshot = {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n  \n  // Store array lengths for parameters that are arrays or contain arrays\n  // This helps detect adding/removing items (MINOR change)\n  if (node.parameters) {\n    snapshot.parameterStructure = {};\n    \n    for (const key of snapshot.parameterKeys) {\n      const param = node.parameters[key];\n      \n      if (param && typeof param === 'object') {\n        // Check for common n8n patterns\n        if (param.assignments && Array.isArray(param.assignments)) {\n          // Set/Edit Fields node with assignments\n          snapshot.parameterStructure[key] = {\n            assignmentCount: param.assignments.length\n          };\n        } else if (Array.isArray(param)) {\n          // Direct array parameter\n          snapshot.parameterStructure[key] = {\n            arrayLength: param.length\n          };\n        } else if (param.parameters && Array.isArray(param.parameters)) {\n          // HTTP Request headers/parameters\n          snapshot.parameterStructure[key] = {\n            paramCount: param.parameters.length\n          };\n        }\n      }\n    }\n  }\n  \n  return snapshot;\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const parsedExistingVersion = parseVersionFromNotes(node.notes);\n  const existingVersion = parsedExistingVersion && parsedExistingVersion.version\n    ? parsedExistingVersion\n    : {\n      version: '1.0.0',\n      created: timestamp,\n      lastModified: timestamp\n    };\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hashChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  // Check for name changes (MAJOR change that doesn't affect hash)\n  const nameChanged = storedSnapshot && storedSnapshot.name !== node.name;\n  \n  // Node has changed if hash OR name changed\n  const hasChanged = hashChanged || nameChanged;\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: config,\n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "792f17a1",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 792f17a1\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnMyMiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "9f49a915-7b8a-4266-9007-cdad94abf311",
      "name": "Respond to Webhook22",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        944,
        -27184
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2syMiIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsib3B0aW9ucyIsInJlc3BvbmRXaXRoIiwicmVzcG9uc2VCb2R5Il0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "d2d80fff-60d0-4e73-8c18-24c98be2347f",
      "name": "Dry Run Response22",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        160,
        -27200
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\n\nfunction buildWorkflowOpenUrl(apiUrl, workflowId, timestamp) {\n  if (!workflowId) return null;\n\n  const rawApiUrl = String(apiUrl || '').trim();\n  if (!rawApiUrl) return null;\n\n  const normalizedApiUrl = rawApiUrl.replace(/\\/$/, '');\n  const baseUrl = normalizedApiUrl\n    .replace(/\\/api\\/v\\d+$/, '')\n    .replace(/\\/api$/, '');\n\n  return `${baseUrl}/workflow/${encodeURIComponent(workflowId)}?updated=${encodeURIComponent(timestamp)}`;\n}\n\nconst timestamp = data.timestamp || new Date().toISOString();\nconst workflowId = data.config?.workflowId || null;\nconst openWorkflowUrl = buildWorkflowOpenUrl(data.config?.n8nApiUrl, workflowId, timestamp);\n\nreturn {\n  json: {\n    success: true,\n    message: 'Dry run completed - no changes applied',\n    workflowId,\n    workflowName: data.originalWorkflow?.name,\n    version: {\n      previous: data.workflowVersion?.previous,\n      wouldBecome: data.workflowVersion?.current,\n    },\n    changes: data.nodeChanges,\n    timestamp,\n    dryRun: true,\n    openWorkflowUrl,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "54cd6021",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 54cd6021\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlMjIiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "ef5dcbba-5076-447e-8635-f7825fb4279d",
      "name": "Update Workflow with Versions22",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        48,
        -27792
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1747da31",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 1747da31\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnMyMiIsInR5cGVWZXJzaW9uIjo0LjIsInBhcmFtZXRlcktleXMiOlsiYXV0aGVudGljYXRpb24iLCJnZW5lcmljQXV0aFR5cGUiLCJoZWFkZXJQYXJhbWV0ZXJzIiwianNvbkJvZHkiLCJtZXRob2QiLCJvcHRpb25zIiwic2VuZEJvZHkiLCJzZW5kSGVhZGVycyIsInNwZWNpZnlCb2R5IiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjF9fX0=",
      "notesInFlow": true
    },
    {
      "id": "2606723c-ab11-4239-8e7e-195f40354de1",
      "name": "Dry Run?22",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -80,
        -27280
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj8yMiIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "3775f2a1-9afd-4ec9-8b32-078a49772b53",
      "name": "No Changes Response22",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        272,
        -26928
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\n\nfunction buildWorkflowOpenUrl(apiUrl, workflowId, timestamp) {\n  if (!workflowId) return null;\n\n  const rawApiUrl = String(apiUrl || '').trim();\n  if (!rawApiUrl) return null;\n\n  const normalizedApiUrl = rawApiUrl.replace(/\\/$/, '');\n  const baseUrl = normalizedApiUrl\n    .replace(/\\/api\\/v\\d+$/, '')\n    .replace(/\\/api$/, '');\n\n  return `${baseUrl}/workflow/${encodeURIComponent(workflowId)}?updated=${encodeURIComponent(timestamp)}`;\n}\n\nconst timestamp = data.timestamp || new Date().toISOString();\nconst workflowId = data.config?.workflowId || null;\nconst openWorkflowUrl = buildWorkflowOpenUrl(data.config?.n8nApiUrl, workflowId, timestamp);\n\nreturn {\n  json: {\n    success: true,\n    message: 'No changes detected',\n    workflowId,\n    workflowName: data.originalWorkflow?.name,\n    version: data.workflowVersion?.current,\n    timestamp,\n    openWorkflowUrl,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2fd48f36",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2fd48f36\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlMjIiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "e22971af-28bf-4db5-b656-9a21c4a3f085",
      "name": "Has Changes?22",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -368,
        -27264
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/MjIiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "5fd320df-1fae-40e8-9a00-f026031e0c9e",
      "name": "Fetch Current Workflow22",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -736,
        -27264
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7ffe44bb",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 7ffe44bb\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzIyIiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJhdXRoZW50aWNhdGlvbiIsImdlbmVyaWNBdXRoVHlwZSIsIm9wdGlvbnMiLCJ1cmwiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "7fb7f1d2-1862-4a19-b5fd-cdfa9e1cea33",
      "name": "Parse Configuration22",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -912,
        -27264
      ],
      "parameters": {
        "jsCode": "// Extract configuration from input\nconst input = $input.first().json;\n\nconst config = {\n  workflowId: input.workflowId || input.body?.workflowId || null,\n  gitEnabled: input.gitEnabled ?? input.body?.gitEnabled ?? false,\n  gitPushEnabled: input.gitPushEnabled ?? input.body?.gitPushEnabled ?? false,\n  gitRepoPath: input.gitRepoPath || input.body?.gitRepoPath || '/files/backups/git-repo',\n  gitRemote: input.gitRemote || input.body?.gitRemote || 'origin',\n  gitBranch: input.gitBranch || input.body?.gitBranch || 'main',\n  localBackupEnabled: input.localBackupEnabled ?? input.body?.localBackupEnabled ?? false,\n  localBackupPath: input.localBackupPath || input.body?.localBackupPath || '/files/backups',\n  localBackupMaxVersions: input.localBackupMaxVersions ?? input.body?.localBackupMaxVersions ?? 20,\n  cleanupOldBackupsEnabled: input.cleanupOldBackupsEnabled ?? input.body?.cleanupOldBackupsEnabled ?? false,\n  n8nApiUrl: input.n8nApiUrl || input.body?.n8nApiUrl || 'http://localhost:5678/api/v1',\n  commitMessage: input.commitMessage || input.body?.commitMessage || null,\n  dryRun: input.dryRun ?? input.body?.dryRun ?? false,\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input or request body.');\n}\n\nif (config.gitEnabled && !config.gitRepoPath) {\n  throw new Error('gitRepoPath is required when gitEnabled=true.');\n}\n\nreturn { json: config };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "b12b830",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: b12b830\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uMjIiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "cc5a8b83-f08c-4416-a540-1304fcdfce2e",
      "name": "Cleanup Old Backups8",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1344,
        -27728
      ],
      "parameters": {
        "jsCode": "// Cleanup Old Backups\n// Keep only newest N backups for the current workflow prefix.\n\nconst data = $input.first().json;\nconst config = data.config || {};\nconst cleanupEnabled = config.cleanupOldBackupsEnabled === true;\n\nif (!cleanupEnabled) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: false,\n      cleanupSkipped: true,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n    }\n  };\n}\n\nlet fs;\nlet path;\n\ntry {\n  fs = require('fs');\n  path = require('path');\n} catch (error) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n      backupCleanupError: 'Cleanup requires NODE_FUNCTION_ALLOW_BUILTIN=fs,path or disable cleanupOldBackupsEnabled.',\n      backupCleanupErrorDetails: error?.message || String(error),\n    }\n  };\n}\n\nconst backupDir = (data.backupDisplayPath || path.dirname(data.backupFullPath || '')).replace(/\\/+$/, '');\nconst currentFile = data.backupFilename || path.basename(data.backupFullPath || '');\nconst backupPrefix = data.backupPrefix || null;\n\nconst maxRaw = Number(config.localBackupMaxVersions ?? 20);\nconst maxVersions = Number.isFinite(maxRaw) ? Math.floor(maxRaw) : 20;\n\nfunction escapeRegex(value) {\n  return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction prefixFromFile(filename) {\n  const semverIndex = filename.indexOf('-v');\n  if (semverIndex > 0) return `${filename.slice(0, semverIndex)}-v`;\n  return null;\n}\n\nfunction getSortEpochMs(filename, fallbackMs) {\n  const match = filename.match(/-(\\d{4})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})\\.json$/);\n  if (!match) return fallbackMs;\n\n  const [, y, mo, d, h, mi, s] = match;\n  const dt = Date.UTC(Number(y), Number(mo) - 1, Number(d), Number(h), Number(mi), Number(s));\n  return Number.isFinite(dt) ? dt : fallbackMs;\n}\n\ntry {\n  if (!backupDir) {\n    return {\n      json: {\n        ...data,\n        cleanupEnabled: true,\n        cleanupSkipped: false,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Backup directory is missing.',\n      }\n    };\n  }\n\n  // Preserve the newest backup by default even if max is misconfigured.\n  const effectiveMax = maxVersions < 1 ? 1 : maxVersions;\n\n  const workflowPrefix = backupPrefix || prefixFromFile(currentFile);\n  if (!workflowPrefix) {\n    return {\n      json: {\n        ...data,\n        cleanupEnabled: true,\n        cleanupSkipped: false,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Unable to determine workflow backup prefix.',\n      }\n    };\n  }\n\n  const filePattern = new RegExp(\n    `^${escapeRegex(workflowPrefix)}\\\\d+\\\\.\\\\d+\\\\.\\\\d+-\\\\d{4}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}\\\\.json$`\n  );\n\n  const matchingFiles = fs\n    .readdirSync(backupDir, { withFileTypes: true })\n    .filter((entry) => entry.isFile())\n    .map((entry) => entry.name)\n    .filter((name) => filePattern.test(name))\n    .map((name) => {\n      const fullPath = path.join(backupDir, name);\n      const stats = fs.statSync(fullPath);\n      return {\n        name,\n        fullPath,\n        mtimeMs: stats.mtimeMs,\n        sortEpochMs: getSortEpochMs(name, stats.mtimeMs),\n      };\n    })\n    .sort((a, b) => {\n      if (a.sortEpochMs !== b.sortEpochMs) return a.sortEpochMs - b.sortEpochMs;\n      return a.mtimeMs - b.mtimeMs;\n    });\n\n  const deleteCount = Math.max(0, matchingFiles.length - effectiveMax);\n  const toDelete = matchingFiles.slice(0, deleteCount);\n\n  for (const file of toDelete) {\n    fs.unlinkSync(file.fullPath);\n  }\n\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: true,\n      cleanupPrefix: workflowPrefix,\n      cleanupMaxVersions: effectiveMax,\n      matchedBackups: matchingFiles.length,\n      deletedBackups: toDelete.length,\n      deletedFiles: toDelete.map((file) => file.name),\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n      backupCleanupError: error?.message || String(error),\n    }\n  };\n}\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "88ad36f",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 88ad36f\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDbGVhbnVwIE9sZCBCYWNrdXBzOCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "6c36994e-370d-4cf7-a768-e97e3582862d",
      "name": "Delete Old Backups Enabled?7",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1216,
        -27488
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "cleanup-old-backups-enabled",
              "leftValue": "={{ $json.config.cleanupOldBackupsEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "47bddea4",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 47bddea4\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRGVsZXRlIE9sZCBCYWNrdXBzIEVuYWJsZWQ/NyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "e9d441e3-1d15-4601-ba69-db38d980b628",
      "name": "Git Enabled?3",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1472,
        -27824
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "git-enabled",
              "leftValue": "={{ $json.config.gitEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "6d2083b6",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 6d2083b6\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiR2l0IEVuYWJsZWQ/MyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "c82d4ee3-e5ad-4ee9-9222-fbe4bcb45302",
      "name": "Prepare Git Data3",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1664,
        -28016
      ],
      "parameters": {
        "jsCode": "// Prepare Git Data with stable filename (workflowId-based)\n\nconst data = $input.first().json;\nconst config = data.config || {};\n\nconst workflowId = config.workflowId || data.workflowId || 'unknown-workflow';\nconst repoPath = String(config.gitRepoPath || '/files/backups/git-repo').replace(/\\/+$/, '');\nconst gitFileName = `workflow-${workflowId}.json`;\nconst gitFilePath = `${repoPath}/${gitFileName}`;\n\nconst currentVersion = data.workflowVersion?.current || '1.0.0';\nconst workflowName = String(data.updatedWorkflow?.name || data.originalWorkflow?.name || 'Unknown Workflow')\n  .replace(/\\s+/g, ' ')\n  .trim();\nconst commitMessage = config.commitMessage\n  || `chore(workflow): ${workflowName} (${workflowId}) -> v${currentVersion}`;\n\nconst rawRemote = String(config.gitRemote || '').trim();\nconst gitTargetRepository = !rawRemote || rawRemote === 'origin' ? '' : rawRemote;\n\nconst gitWorkflowJson = `${JSON.stringify(data.updatedWorkflow, null, 2)}\n`;\n\nreturn {\n  json: {\n    ...data,\n    gitRepoPath: repoPath,\n    gitFileName,\n    gitFilePath,\n    gitWorkflowJson,\n    gitCommitMessage: commitMessage,\n    gitTargetRepository,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "65e96bfe",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 65e96bfe\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcmVwYXJlIEdpdCBEYXRhMyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "e3213597-0293-4f72-a667-577bc6816d61",
      "name": "Convert Git Workflow to Binary3",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1856,
        -28016
      ],
      "parameters": {
        "jsCode": "// Convert Git workflow JSON to binary for Write Binary File node\n\nconst data = $input.first().json;\nconst binaryData = Buffer.from(data.gitWorkflowJson, 'utf-8');\n\nreturn {\n  json: data,\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'application/json',\n      fileName: data.gitFileName,\n      fileExtension: 'json',\n    }\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1e6d3a18",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 1e6d3a18\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDb252ZXJ0IEdpdCBXb3JrZmxvdyB0byBCaW5hcnkzIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "1a17d92b-4594-4f8a-a8b5-505cd5f63dfd",
      "name": "Write Git Workflow File3",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        2048,
        -28016
      ],
      "parameters": {
        "fileName": "={{ $json.gitFilePath }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2307914b",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1\nüîí Hash: 2307914b\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uud3JpdGVCaW5hcnlGaWxlIiwibmFtZSI6IldyaXRlIEdpdCBXb3JrZmxvdyBGaWxlMyIsInR5cGVWZXJzaW9uIjoxLCJwYXJhbWV0ZXJLZXlzIjpbImZpbGVOYW1lIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "39817e5e-1e7f-4ae2-a969-7ee53ae25965",
      "name": "Git Add Workflow File3",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        2256,
        -28016
      ],
      "parameters": {
        "operation": "add",
        "repositoryPath": "={{ $(\"Prepare Git Data3\").first().json.gitRepoPath }}",
        "pathsToAdd": "={{ $(\"Prepare Git Data3\").first().json.gitFileName }}",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7bd5c880",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 7bd5c880\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBBZGQgV29ya2Zsb3cgRmlsZTMiLCJ0eXBlVmVyc2lvbiI6MS4xLCJwYXJhbWV0ZXJLZXlzIjpbIm9wZXJhdGlvbiIsInBhdGhzVG9BZGQiLCJyZXBvc2l0b3J5UGF0aCJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "06be59e7-4ac7-4f97-8861-d36a9895ffb5",
      "name": "Git Commit Workflow File3",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        2448,
        -28016
      ],
      "parameters": {
        "operation": "commit",
        "repositoryPath": "={{ $(\"Prepare Git Data3\").first().json.gitRepoPath }}",
        "message": "={{ $(\"Prepare Git Data3\").first().json.gitCommitMessage }}",
        "options": {
          "branch": "={{ $(\"Prepare Git Data3\").first().json.config.gitBranch }}",
          "pathsToAdd": "={{ $(\"Prepare Git Data3\").first().json.gitFileName }}"
        },
        "_versionControl": {
          "version": "1.0.0",
          "hash": "32a6496f",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 32a6496f\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBDb21taXQgV29ya2Zsb3cgRmlsZTMiLCJ0eXBlVmVyc2lvbiI6MS4xLCJwYXJhbWV0ZXJLZXlzIjpbIm1lc3NhZ2UiLCJvcGVyYXRpb24iLCJvcHRpb25zIiwicmVwb3NpdG9yeVBhdGgiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "29c73cc5-cb68-4ef9-9780-8ec19dbf8ceb",
      "name": "Git Latest Commit3",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        2640,
        -28016
      ],
      "parameters": {
        "repositoryPath": "={{ $(\"Prepare Git Data3\").first().json.gitRepoPath }}",
        "limit": 1,
        "options": {
          "file": "={{ $(\"Prepare Git Data3\").first().json.gitFileName }}"
        },
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1a07b0a8",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 1a07b0a8\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBMYXRlc3QgQ29tbWl0MyIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsibGltaXQiLCJvcHRpb25zIiwicmVwb3NpdG9yeVBhdGgiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "bf62e86b-9a41-4193-8606-7800a0cf8e37",
      "name": "Git Push Enabled?3",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2832,
        -28016
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "git-push-enabled",
              "leftValue": "={{ $(\"Prepare Git Data3\").first().json.config.gitPushEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "c2a6547",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: c2a6547\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiR2l0IFB1c2ggRW5hYmxlZD8zIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsiY29uZGl0aW9ucyIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "a4268d27-e359-4c79-b8ee-4ad8b1485e20",
      "name": "Git Push Remote3",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        3024,
        -28112
      ],
      "parameters": {
        "authentication": "gitPassword",
        "operation": "push",
        "repositoryPath": "={{ $(\"Prepare Git Data3\").first().json.gitRepoPath }}",
        "options": {
          "branch": "={{ $(\"Prepare Git Data3\").first().json.config.gitBranch }}",
          "targetRepository": "={{ $(\"Prepare Git Data3\").first().json.gitTargetRepository }}"
        },
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64e817f4",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64e817f4\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBQdXNoIFJlbW90ZTMiLCJ0eXBlVmVyc2lvbiI6MS4xLCJwYXJhbWV0ZXJLZXlzIjpbImF1dGhlbnRpY2F0aW9uIiwib3BlcmF0aW9uIiwib3B0aW9ucyIsInJlcG9zaXRvcnlQYXRoIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "2ff6cc0a-0915-4487-a7a2-a67e73b0dfcb",
      "name": "Finalize Git Local3",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3024,
        -27840
      ],
      "parameters": {
        "jsCode": "// Finalize Git status for local commit only\n\nconst base = $(\"Prepare Git Data3\").first().json;\nconst commit = $(\"Git Latest Commit3\").first().json;\n\nreturn {\n  json: {\n    ...base,\n    gitCommitted: true,\n    gitPushed: false,\n    gitCommit: commit\n      ? {\n          hash: commit.hash || null,\n          message: commit.message || null,\n          date: commit.date || null,\n          authorName: commit.author_name || null,\n          authorEmail: commit.author_email || null,\n        }\n      : null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "19cfd4b6",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 19cfd4b6\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJGaW5hbGl6ZSBHaXQgTG9jYWwzIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "5ed941f2-3544-4f81-a8b0-86066e0e497a",
      "name": "Finalize Git Push3",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3216,
        -28112
      ],
      "parameters": {
        "jsCode": "// Finalize Git status for local commit + remote push\n\nconst base = $(\"Prepare Git Data3\").first().json;\nconst commit = $(\"Git Latest Commit3\").first().json;\n\nreturn {\n  json: {\n    ...base,\n    gitCommitted: true,\n    gitPushed: true,\n    gitCommit: commit\n      ? {\n          hash: commit.hash || null,\n          message: commit.message || null,\n          date: commit.date || null,\n          authorName: commit.author_name || null,\n          authorEmail: commit.author_email || null,\n        }\n      : null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "63ad48c0",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 63ad48c0\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJGaW5hbGl6ZSBHaXQgUHVzaDMiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "b4cc6c36-5603-4b9a-ad4b-d267109b5932",
      "name": "Set Version Control Config Defaults1",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -3616,
        -29488
      ],
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "1",
              "name": "workflowId",
              "value": "={{ $json.workflowId || $json.body?.workflowId || null }}",
              "type": "string"
            },
            {
              "id": "2",
              "name": "gitEnabled",
              "value": "={{ $json.gitEnabled ?? $json.body?.gitEnabled ?? true }}",
              "type": "boolean"
            },
            {
              "id": "11",
              "name": "gitPushEnabled",
              "value": "={{ $json.gitPushEnabled ?? $json.body?.gitPushEnabled ?? true }}",
              "type": "boolean"
            },
            {
              "id": "12",
              "name": "gitRepoPath",
              "value": "={{ $json.gitRepoPath || $json.body?.gitRepoPath || '/files/backups/git-repo' }}",
              "type": "string"
            },
            {
              "id": "13",
              "name": "gitBranch",
              "value": "={{ $json.gitBranch || $json.body?.gitBranch || 'main' }}",
              "type": "string"
            },
            {
              "id": "14",
              "name": "gitRemote",
              "value": "={{ $json.gitRemote || $json.body?.gitRemote || 'origin' }}",
              "type": "string"
            },
            {
              "id": "7",
              "name": "localBackupEnabled",
              "value": "={{ $json.localBackupEnabled ?? $json.body?.localBackupEnabled ?? true }}",
              "type": "boolean"
            },
            {
              "id": "3",
              "name": "localBackupPath",
              "value": "={{ $json.localBackupPath || $json.body?.localBackupPath || '/files/backups' }}",
              "type": "string"
            },
            {
              "id": "9",
              "name": "localBackupMaxVersions",
              "value": "={{ $json.localBackupMaxVersions ?? $json.body?.localBackupMaxVersions ?? 20 }}",
              "type": "number"
            },
            {
              "id": "10",
              "name": "cleanupOldBackupsEnabled",
              "value": "={{ $json.cleanupOldBackupsEnabled ?? $json.body?.cleanupOldBackupsEnabled ?? true }}",
              "type": "boolean"
            },
            {
              "id": "4",
              "name": "n8nApiUrl",
              "value": "={{ $json.n8nApiUrl || $json.body?.n8nApiUrl || 'http://localhost:5678/api/v1' }}",
              "type": "string"
            },
            {
              "id": "6",
              "name": "dryRun",
              "value": "={{ $json.dryRun ?? $json.body?.dryRun ?? false }}",
              "type": "boolean"
            },
            {
              "id": "15",
              "name": "commitMessage",
              "value": "={{ $json.commitMessage || $json.body?.commitMessage || null }}",
              "type": "string"
            }
          ]
        },
        "options": {},
        "_versionControl": {
          "version": "2.0.0",
          "hash": "4e5418a7",
          "created": "Feb 6, 2026, 05:16 PM",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 2.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v3.4\nüîí Hash: 4e5418a7\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uuc2V0IiwibmFtZSI6IlNldCBWZXJzaW9uIENvbnRyb2wgQ29uZmlnIERlZmF1bHRzMSIsInR5cGVWZXJzaW9uIjozLjQsInBhcmFtZXRlcktleXMiOlsiYXNzaWdubWVudHMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJhc3NpZ25tZW50cyI6eyJhc3NpZ25tZW50Q291bnQiOjEzfX19\nüÜï Created: Feb 6, 2026, 05:16 PM",
      "notesInFlow": true
    },
    {
      "id": "61793866-c5c5-41ea-98fe-fd745a435665",
      "name": "Mark Backup Complete11",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1472,
        -29712
      ],
      "parameters": {
        "jsCode": "// Mark Backup Complete\n\nconst data = $input.first().json;\n\nreturn {\n  json: {\n    ...data,\n    backupSaved: true,\n    backupTimestamp: new Date().toISOString(),\n    backupPath: data.backupFullPath || null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "84b988f",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 84b988f\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJNYXJrIEJhY2t1cCBDb21wbGV0ZTExIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "302d8357-a37d-4eac-9deb-b60e002fa9bf",
      "name": "Write Backup File11",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        -1648,
        -29712
      ],
      "parameters": {
        "fileName": "={{ $json.backupFullPath }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "20c20b9a",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1\nüîí Hash: 20c20b9a\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uud3JpdGVCaW5hcnlGaWxlIiwibmFtZSI6IldyaXRlIEJhY2t1cCBGaWxlMTEiLCJ0eXBlVmVyc2lvbiI6MSwicGFyYW1ldGVyS2V5cyI6WyJmaWxlTmFtZSIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "7a1a8252-a319-4b78-8d23-09b85113ff27",
      "name": "Convert to Binary11",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1824,
        -29712
      ],
      "parameters": {
        "jsCode": "// Convert to Binary Data\n\nconst data = $input.first().json;\n\n// Convert JSON string to binary data\nconst binaryData = Buffer.from(data.workflowJson, 'utf-8');\n\nreturn {\n  json: data,\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'application/json',\n      fileName: data.backupFilename,\n      fileExtension: 'json'\n    }\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "792aa334",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 792aa334\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDb252ZXJ0IHRvIEJpbmFyeTExIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "dad642bd-38b9-4721-a544-0ee38b72196e",
      "name": "Prepare Backup Data11",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2016,
        -29712
      ],
      "parameters": {
        "jsCode": "// Prepare Backup Data - Create filename and data\n\nconst data = $input.first().json;\nconst workflow = data.updatedWorkflow;\nconst version = data.workflowVersion.current;\nconst config = data.config;\n\n// Sanitize workflow name\nconst safeName = workflow.name\n  .replace(/\\s+/g, '_')\n  .replace(/[^a-zA-Z0-9_-]/g, '')\n  .substring(0, 50);\n\n// Generate human-readable timestamp\nconst now = new Date();\nconst year = now.getFullYear();\nconst month = String(now.getMonth() + 1).padStart(2, '0');\nconst day = String(now.getDate()).padStart(2, '0');\nconst hours = String(now.getHours()).padStart(2, '0');\nconst minutes = String(now.getMinutes()).padStart(2, '0');\nconst seconds = String(now.getSeconds()).padStart(2, '0');\n\nconst timestamp = `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;\n\nconst backupPrefix = `${safeName}-v`;\nconst filename = `${backupPrefix}${version}-${timestamp}.json`;\n\nlet backupDir = config.localBackupPath || '/tmp';\nif (backupDir.startsWith('~/')) {\n  const homeDir =\n    (typeof process !== 'undefined' && process.env && process.env.HOME)\n      ? process.env.HOME\n      : '/home/node';\n  backupDir = backupDir.replace(/^~(?=\\/)/, homeDir);\n}\n\nbackupDir = backupDir.replace(/\\/+$/, '') || '/tmp';\n\nreturn {\n  json: {\n    ...data,\n    backupPrefix,\n    backupFilename: filename,\n    backupDisplayPath: backupDir,\n    backupFullPath: `${backupDir}/${filename}`,\n    workflowJson: JSON.stringify(workflow, null, 2),\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "52eca43b",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 52eca43b\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcmVwYXJlIEJhY2t1cCBEYXRhMTEiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "56524a52-7f60-49a9-8817-77977ec25f24",
      "name": "Restore Data After Update13",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2208,
        -30016
      ],
      "parameters": {
        "jsCode": "// Restore Data After HTTP Request\n\n// Get the original data from Process Node Versions\nconst processData = $(\"Process Node Versions23\").first().json;\n\n// Get the HTTP response (current input)\nconst httpResponse = $input.first().json;\n\n// Merge them - keep all original data, add HTTP response\nreturn {\n  json: {\n    ...processData,\n    httpResponse: httpResponse,\n    workflowUpdated: true\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "103deb7d",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 103deb7d\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJSZXN0b3JlIERhdGEgQWZ0ZXIgVXBkYXRlMTMiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "f473bcff-07bf-41f5-a81d-362b3217fca6",
      "name": "Local Backup Enabled?14",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1984,
        -30016
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "local-backup-enabled",
              "leftValue": "={{ $json.config.localBackupEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "277dced1",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 277dced1\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiTG9jYWwgQmFja3VwIEVuYWJsZWQ/MTQiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "a7822096-f6cc-4d11-802d-5cf0237bdf36",
      "name": "Build Success Response23",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -816,
        -30048
      ],
      "parameters": {
        "jsCode": "// Build Success Response\n// Merge original process data with latest branch data so backup/cleanup/git fields are preserved.\n\nconst processData = $(\"Process Node Versions23\").first().json;\nconst latestData = $input.first().json;\nconst data = {\n  ...processData,\n  ...latestData,\n};\n\nconst cleanupEnabled = data.cleanupEnabled ?? (data.config?.cleanupOldBackupsEnabled ?? false);\n\nfunction buildWorkflowOpenUrl(apiUrl, workflowId, timestamp) {\n  if (!workflowId) return null;\n\n  const rawApiUrl = String(apiUrl || '').trim();\n  if (!rawApiUrl) return null;\n\n  const normalizedApiUrl = rawApiUrl.replace(/\\/$/, '');\n  const baseUrl = normalizedApiUrl\n    .replace(/\\/api\\/v\\d+$/, '')\n    .replace(/\\/api$/, '');\n\n  return `${baseUrl}/workflow/${encodeURIComponent(workflowId)}?updated=${encodeURIComponent(timestamp)}`;\n}\n\nconst timestamp = data.timestamp || new Date().toISOString();\nconst workflowId = data.config?.workflowId || 'unknown';\nconst openWorkflowUrl = buildWorkflowOpenUrl(data.config?.n8nApiUrl, workflowId, timestamp);\n\nconst summary = {\n  success: true,\n  message: data.hasChanges\n    ? `‚úÖ Version control updated: ${data.nodeChanges.length} node${data.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId,\n  workflowName: data.updatedWorkflow?.name || data.originalWorkflow?.name || 'Unknown',\n  hasChanges: data.hasChanges || false,\n  nodeChanges: data.nodeChanges || [],\n  originalWorkflow: data.originalWorkflow,\n  updatedWorkflow: data.updatedWorkflow,\n  workflowVersion: data.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp,\n  dryRun: false,\n  openWorkflowUrl,\n};\n\nsummary.git = {\n  enabled: data.config?.gitEnabled ?? false,\n  remotePushEnabled: data.config?.gitPushEnabled ?? false,\n  repoPath: data.gitRepoPath || data.config?.gitRepoPath || null,\n  fileName: data.gitFileName || null,\n  filePath: data.gitFilePath || null,\n  branch: data.config?.gitBranch || null,\n  remote: data.config?.gitRemote || null,\n  commitMessage: data.gitCommitMessage || data.config?.commitMessage || null,\n  committed: data.gitCommitted || false,\n  pushed: data.gitPushed || false,\n  commit: data.gitCommit || null,\n  error: data.gitError || null,\n};\n\nif (data.backupSaved !== undefined) {\n  summary.backup = {\n    saved: data.backupSaved,\n    filename: data.backupFilename || null,\n    path: data.backupPath || null,\n    error: data.backupError || data.backupCleanupError || null,\n    cleanup: {\n      enabled: cleanupEnabled,\n      performed: data.cleanupPerformed || false,\n      skipped: data.cleanupSkipped || false,\n      deleted: data.deletedBackups || 0,\n      files: data.deletedFiles || [],\n      prefix: data.cleanupPrefix || null,\n      matchedBackups: data.matchedBackups || 0,\n      maxVersions: data.cleanupMaxVersions ?? null,\n    },\n  };\n}\n\nreturn { json: summary };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "637b9822",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 637b9822\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlMjMiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "d88e5c0f-c0e5-4015-b392-807420f08cb7",
      "name": "Process Node Versions23",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3056,
        -29600
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\nconst config = $(\"Parse Configuration23\").first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldSnapshot, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldSnapshot) return { type: 'major', reason: 'New node' };\n  \n  // MAJOR: Node type changed\n  if (oldSnapshot.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldSnapshot.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldSnapshot.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldSnapshot.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Compare parameter keys (what we have in snapshot)\n  const oldKeys = (oldSnapshot.parameterKeys || []).sort();\n  const newParams = newNode.parameters || {};\n  const newParamsCopy = { ...newParams };\n  delete newParamsCopy._versionControl;\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // MINOR: Check parameter structure changes (array lengths, etc.)\n  if (oldSnapshot.parameterStructure && newParams) {\n    for (const key in oldSnapshot.parameterStructure) {\n      const oldStruct = oldSnapshot.parameterStructure[key];\n      const newParam = newParams[key];\n      \n      if (!newParam) continue; // Parameter was removed (caught above)\n      \n      // Check assignment count changes\n      if (oldStruct.assignmentCount !== undefined) {\n        const newCount = newParam.assignments?.length || 0;\n        if (oldStruct.assignmentCount !== newCount) {\n          const change = newCount > oldStruct.assignmentCount ? 'Added' : 'Removed';\n          const diff = Math.abs(newCount - oldStruct.assignmentCount);\n          return { \n            type: 'minor', \n            reason: `${change} ${diff} assignment${diff > 1 ? 's' : ''} in '${key}'`\n          };\n        }\n      }\n      \n      // Check array length changes\n      if (oldStruct.arrayLength !== undefined) {\n        const newLength = Array.isArray(newParam) ? newParam.length : 0;\n        if (oldStruct.arrayLength !== newLength) {\n          return { \n            type: 'minor', \n            reason: `Array '${key}' size changed: ${oldStruct.arrayLength} ‚Üí ${newLength}`\n          };\n        }\n      }\n      \n      // Check parameter count changes (like HTTP headers)\n      if (oldStruct.paramCount !== undefined) {\n        const newCount = newParam.parameters?.length || 0;\n        if (oldStruct.paramCount !== newCount) {\n          return { \n            type: 'minor', \n            reason: `Parameter count in '${key}' changed: ${oldStruct.paramCount} ‚Üí ${newCount}`\n          };\n        }\n      }\n    }\n  }\n  \n  // If keys are the same and structure unchanged, it's a PATCH (value change)\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const rawParts = String(version || '1.0.0').split('.').map(part => Number(part));\n  const parts = [\n    Number.isFinite(rawParts[0]) ? rawParts[0] : 1,\n    Number.isFinite(rawParts[1]) ? rawParts[1] : 0,\n    Number.isFinite(rawParts[2]) ? rawParts[2] : 0,\n  ];\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  const snapshot = {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n  \n  // Store array lengths for parameters that are arrays or contain arrays\n  // This helps detect adding/removing items (MINOR change)\n  if (node.parameters) {\n    snapshot.parameterStructure = {};\n    \n    for (const key of snapshot.parameterKeys) {\n      const param = node.parameters[key];\n      \n      if (param && typeof param === 'object') {\n        // Check for common n8n patterns\n        if (param.assignments && Array.isArray(param.assignments)) {\n          // Set/Edit Fields node with assignments\n          snapshot.parameterStructure[key] = {\n            assignmentCount: param.assignments.length\n          };\n        } else if (Array.isArray(param)) {\n          // Direct array parameter\n          snapshot.parameterStructure[key] = {\n            arrayLength: param.length\n          };\n        } else if (param.parameters && Array.isArray(param.parameters)) {\n          // HTTP Request headers/parameters\n          snapshot.parameterStructure[key] = {\n            paramCount: param.parameters.length\n          };\n        }\n      }\n    }\n  }\n  \n  return snapshot;\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const parsedExistingVersion = parseVersionFromNotes(node.notes);\n  const existingVersion = parsedExistingVersion && parsedExistingVersion.version\n    ? parsedExistingVersion\n    : {\n      version: '1.0.0',\n      created: timestamp,\n      lastModified: timestamp\n    };\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hashChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  // Check for name changes (MAJOR change that doesn't affect hash)\n  const nameChanged = storedSnapshot && storedSnapshot.name !== node.name;\n  \n  // Node has changed if hash OR name changed\n  const hasChanged = hashChanged || nameChanged;\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: config,\n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "5636d680",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 5636d680\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnMyMyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "889220e4-e044-48ba-9088-65b52735ef70",
      "name": "Respond to Webhook23",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        -1584,
        -29408
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "64ab2cb3",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 64ab2cb3\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UucmVzcG9uZFRvV2ViaG9vayIsIm5hbWUiOiJSZXNwb25kIHRvIFdlYmhvb2syMyIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsib3B0aW9ucyIsInJlc3BvbmRXaXRoIiwicmVzcG9uc2VCb2R5Il0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "ec22dc52-df3a-4ec2-8a4d-6971fb79607c",
      "name": "Dry Run Response23",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2368,
        -29424
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\n\nfunction buildWorkflowOpenUrl(apiUrl, workflowId, timestamp) {\n  if (!workflowId) return null;\n\n  const rawApiUrl = String(apiUrl || '').trim();\n  if (!rawApiUrl) return null;\n\n  const normalizedApiUrl = rawApiUrl.replace(/\\/$/, '');\n  const baseUrl = normalizedApiUrl\n    .replace(/\\/api\\/v\\d+$/, '')\n    .replace(/\\/api$/, '');\n\n  return `${baseUrl}/workflow/${encodeURIComponent(workflowId)}?updated=${encodeURIComponent(timestamp)}`;\n}\n\nconst timestamp = data.timestamp || new Date().toISOString();\nconst workflowId = data.config?.workflowId || null;\nconst openWorkflowUrl = buildWorkflowOpenUrl(data.config?.n8nApiUrl, workflowId, timestamp);\n\nreturn {\n  json: {\n    success: true,\n    message: 'Dry run completed - no changes applied',\n    workflowId,\n    workflowName: data.originalWorkflow?.name,\n    version: {\n      previous: data.workflowVersion?.previous,\n      wouldBecome: data.workflowVersion?.current,\n    },\n    changes: data.nodeChanges,\n    timestamp,\n    dryRun: true,\n    openWorkflowUrl,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "54cd6021",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 54cd6021\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlMjMiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "0db20605-a6a0-4352-829b-14c5417590d5",
      "name": "Update Workflow with Versions23",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -2480,
        -30016
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1747da31",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 1747da31\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnMyMyIsInR5cGVWZXJzaW9uIjo0LjIsInBhcmFtZXRlcktleXMiOlsiYXV0aGVudGljYXRpb24iLCJnZW5lcmljQXV0aFR5cGUiLCJoZWFkZXJQYXJhbWV0ZXJzIiwianNvbkJvZHkiLCJtZXRob2QiLCJvcHRpb25zIiwic2VuZEJvZHkiLCJzZW5kSGVhZGVycyIsInNwZWNpZnlCb2R5IiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjF9fX0=",
      "notesInFlow": true
    },
    {
      "id": "bc744037-df8d-4dec-8dcd-3b0d1773c06a",
      "name": "Dry Run?23",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -2608,
        -29504
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj8yMyIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "517b798e-32ff-4a62-b366-cadee3aa1e88",
      "name": "No Changes Response23",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2256,
        -29152
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\n\nfunction buildWorkflowOpenUrl(apiUrl, workflowId, timestamp) {\n  if (!workflowId) return null;\n\n  const rawApiUrl = String(apiUrl || '').trim();\n  if (!rawApiUrl) return null;\n\n  const normalizedApiUrl = rawApiUrl.replace(/\\/$/, '');\n  const baseUrl = normalizedApiUrl\n    .replace(/\\/api\\/v\\d+$/, '')\n    .replace(/\\/api$/, '');\n\n  return `${baseUrl}/workflow/${encodeURIComponent(workflowId)}?updated=${encodeURIComponent(timestamp)}`;\n}\n\nconst timestamp = data.timestamp || new Date().toISOString();\nconst workflowId = data.config?.workflowId || null;\nconst openWorkflowUrl = buildWorkflowOpenUrl(data.config?.n8nApiUrl, workflowId, timestamp);\n\nreturn {\n  json: {\n    success: true,\n    message: 'No changes detected',\n    workflowId,\n    workflowName: data.originalWorkflow?.name,\n    version: data.workflowVersion?.current,\n    timestamp,\n    openWorkflowUrl,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2fd48f36",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2fd48f36\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlMjMiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "d8bb8433-dc0d-429d-9cb0-03874f3a2360",
      "name": "Has Changes?23",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -2896,
        -29488
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/MjMiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "206a0df6-be35-4ef7-97b9-463c2ab3f7d2",
      "name": "Fetch Current Workflow23",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -3248,
        -29488
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7ffe44bb",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 7ffe44bb\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzIzIiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJhdXRoZW50aWNhdGlvbiIsImdlbmVyaWNBdXRoVHlwZSIsIm9wdGlvbnMiLCJ1cmwiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "e54d1b24-27e1-49f3-b6ea-fa81f043f647",
      "name": "Parse Configuration23",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3440,
        -29488
      ],
      "parameters": {
        "jsCode": "// Parse and validate normalized configuration (defaults already applied upstream)\nconst input = $input.first().json || {};\n\nconst config = {\n  workflowId: input.workflowId || null,\n  gitEnabled: input.gitEnabled ?? false,\n  gitPushEnabled: input.gitPushEnabled ?? false,\n  gitRepoPath: String(input.gitRepoPath || '/files/backups/git-repo').replace(/\\/+$/, ''),\n  gitRemote: input.gitRemote || 'origin',\n  gitBranch: input.gitBranch || 'main',\n  localBackupEnabled: input.localBackupEnabled ?? false,\n  localBackupPath: String(input.localBackupPath || '/files/backups').replace(/\\/+$/, ''),\n  localBackupMaxVersions: Number(input.localBackupMaxVersions ?? 20),\n  cleanupOldBackupsEnabled: input.cleanupOldBackupsEnabled ?? false,\n  n8nApiUrl: input.n8nApiUrl || 'http://localhost:5678/api/v1',\n  commitMessage: input.commitMessage || null,\n  dryRun: input.dryRun ?? false,\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Pass it in the input, request body, or override node.');\n}\n\nif (config.gitEnabled && !config.gitRepoPath) {\n  throw new Error('gitRepoPath is required when gitEnabled=true.');\n}\n\nif (!Number.isFinite(config.localBackupMaxVersions) || config.localBackupMaxVersions < 1) {\n  config.localBackupMaxVersions = 20;\n}\n\nconfig.localBackupMaxVersions = Math.floor(config.localBackupMaxVersions);\n\nreturn { json: config };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "240f2f07",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 240f2f07\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uMjMiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "d19f562e-9876-4879-82aa-e007721fec33",
      "name": "Cleanup Old Backups9",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1184,
        -29952
      ],
      "parameters": {
        "jsCode": "// Cleanup Old Backups\n// Keep only newest N backups for the current workflow prefix.\n\nconst data = $input.first().json;\nconst config = data.config || {};\nconst cleanupEnabled = config.cleanupOldBackupsEnabled === true;\n\nif (!cleanupEnabled) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: false,\n      cleanupSkipped: true,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n    }\n  };\n}\n\nlet fs;\nlet path;\n\ntry {\n  fs = require('fs');\n  path = require('path');\n} catch (error) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n      backupCleanupError: 'Cleanup requires NODE_FUNCTION_ALLOW_BUILTIN=fs,path or disable cleanupOldBackupsEnabled.',\n      backupCleanupErrorDetails: error?.message || String(error),\n    }\n  };\n}\n\nconst backupDir = (data.backupDisplayPath || path.dirname(data.backupFullPath || '')).replace(/\\/+$/, '');\nconst currentFile = data.backupFilename || path.basename(data.backupFullPath || '');\nconst backupPrefix = data.backupPrefix || null;\n\nconst maxRaw = Number(config.localBackupMaxVersions ?? 20);\nconst maxVersions = Number.isFinite(maxRaw) ? Math.floor(maxRaw) : 20;\n\nfunction escapeRegex(value) {\n  return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction prefixFromFile(filename) {\n  const semverIndex = filename.indexOf('-v');\n  if (semverIndex > 0) return `${filename.slice(0, semverIndex)}-v`;\n  return null;\n}\n\nfunction getSortEpochMs(filename, fallbackMs) {\n  const match = filename.match(/-(\\d{4})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})\\.json$/);\n  if (!match) return fallbackMs;\n\n  const [, y, mo, d, h, mi, s] = match;\n  const dt = Date.UTC(Number(y), Number(mo) - 1, Number(d), Number(h), Number(mi), Number(s));\n  return Number.isFinite(dt) ? dt : fallbackMs;\n}\n\ntry {\n  if (!backupDir) {\n    return {\n      json: {\n        ...data,\n        cleanupEnabled: true,\n        cleanupSkipped: false,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Backup directory is missing.',\n      }\n    };\n  }\n\n  // Preserve the newest backup by default even if max is misconfigured.\n  const effectiveMax = maxVersions < 1 ? 1 : maxVersions;\n\n  const workflowPrefix = backupPrefix || prefixFromFile(currentFile);\n  if (!workflowPrefix) {\n    return {\n      json: {\n        ...data,\n        cleanupEnabled: true,\n        cleanupSkipped: false,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Unable to determine workflow backup prefix.',\n      }\n    };\n  }\n\n  const filePattern = new RegExp(\n    `^${escapeRegex(workflowPrefix)}\\\\d+\\\\.\\\\d+\\\\.\\\\d+-\\\\d{4}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}\\\\.json$`\n  );\n\n  const matchingFiles = fs\n    .readdirSync(backupDir, { withFileTypes: true })\n    .filter((entry) => entry.isFile())\n    .map((entry) => entry.name)\n    .filter((name) => filePattern.test(name))\n    .map((name) => {\n      const fullPath = path.join(backupDir, name);\n      const stats = fs.statSync(fullPath);\n      return {\n        name,\n        fullPath,\n        mtimeMs: stats.mtimeMs,\n        sortEpochMs: getSortEpochMs(name, stats.mtimeMs),\n      };\n    })\n    .sort((a, b) => {\n      if (a.sortEpochMs !== b.sortEpochMs) return a.sortEpochMs - b.sortEpochMs;\n      return a.mtimeMs - b.mtimeMs;\n    });\n\n  const deleteCount = Math.max(0, matchingFiles.length - effectiveMax);\n  const toDelete = matchingFiles.slice(0, deleteCount);\n\n  for (const file of toDelete) {\n    fs.unlinkSync(file.fullPath);\n  }\n\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: true,\n      cleanupPrefix: workflowPrefix,\n      cleanupMaxVersions: effectiveMax,\n      matchedBackups: matchingFiles.length,\n      deletedBackups: toDelete.length,\n      deletedFiles: toDelete.map((file) => file.name),\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n      backupCleanupError: error?.message || String(error),\n    }\n  };\n}\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "88ad36f",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 88ad36f\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDbGVhbnVwIE9sZCBCYWNrdXBzOSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "355eb0f2-9dff-4be3-aac0-fe21b4cd383f",
      "name": "Delete Old Backups Enabled?8",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1312,
        -29712
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "cleanup-old-backups-enabled",
              "leftValue": "={{ $json.config.cleanupOldBackupsEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "47bddea4",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 47bddea4\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRGVsZXRlIE9sZCBCYWNrdXBzIEVuYWJsZWQ/OCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "6313a17b-b97e-4053-92ff-81fbf6c73f2f",
      "name": "Git Enabled?4",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1056,
        -30048
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "git-enabled",
              "leftValue": "={{ $json.config.gitEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "6d2083b6",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 6d2083b6\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiR2l0IEVuYWJsZWQ/NCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "95de6df5-fa32-4fa0-af99-d70fc1509839",
      "name": "Prepare Git Data4",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -864,
        -30240
      ],
      "parameters": {
        "jsCode": "// Prepare Git Data with stable filename (workflowId-based)\n\nconst data = $input.first().json;\nconst config = data.config || {};\n\nconst workflowId = config.workflowId || data.workflowId || 'unknown-workflow';\nconst repoPath = String(config.gitRepoPath || '/files/backups/git-repo').replace(/\\/+$/, '');\nconst gitFileName = `workflow-${workflowId}.json`;\nconst gitFilePath = `${repoPath}/${gitFileName}`;\n\nconst currentVersion = data.workflowVersion?.current || '1.0.0';\nconst workflowName = String(data.updatedWorkflow?.name || data.originalWorkflow?.name || 'Unknown Workflow')\n  .replace(/\\s+/g, ' ')\n  .trim();\nconst commitMessage = config.commitMessage\n  || `chore(workflow): ${workflowName} (${workflowId}) -> v${currentVersion}`;\n\nconst rawRemote = String(config.gitRemote || '').trim();\nconst gitTargetRepository = !rawRemote || rawRemote === 'origin' ? '' : rawRemote;\n\nconst gitWorkflowJson = `${JSON.stringify(data.updatedWorkflow, null, 2)}\n`;\n\nreturn {\n  json: {\n    ...data,\n    gitRepoPath: repoPath,\n    gitFileName,\n    gitFilePath,\n    gitWorkflowJson,\n    gitCommitMessage: commitMessage,\n    gitTargetRepository,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "65e96bfe",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 65e96bfe\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcmVwYXJlIEdpdCBEYXRhNCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "f82ac849-0b22-4c34-b751-a1f948272955",
      "name": "Convert Git Workflow to Binary4",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -672,
        -30240
      ],
      "parameters": {
        "jsCode": "// Convert Git workflow JSON to binary for Write Binary File node\n\nconst data = $input.first().json;\nconst binaryData = Buffer.from(data.gitWorkflowJson, 'utf-8');\n\nreturn {\n  json: data,\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'application/json',\n      fileName: data.gitFileName,\n      fileExtension: 'json',\n    }\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1e6d3a18",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 1e6d3a18\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDb252ZXJ0IEdpdCBXb3JrZmxvdyB0byBCaW5hcnk0IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "b8243cd1-ec72-4971-b7d6-25354f9fb51a",
      "name": "Write Git Workflow File4",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        -480,
        -30240
      ],
      "parameters": {
        "fileName": "={{ $json.gitFilePath }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2307914b",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1\nüîí Hash: 2307914b\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uud3JpdGVCaW5hcnlGaWxlIiwibmFtZSI6IldyaXRlIEdpdCBXb3JrZmxvdyBGaWxlNCIsInR5cGVWZXJzaW9uIjoxLCJwYXJhbWV0ZXJLZXlzIjpbImZpbGVOYW1lIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "d833f10f-5dfe-4d0a-8509-eeeb422ae7e8",
      "name": "Git Add Workflow File4",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        -288,
        -30240
      ],
      "parameters": {
        "operation": "add",
        "repositoryPath": "={{ $(\"Prepare Git Data4\").first().json.gitRepoPath }}",
        "pathsToAdd": "={{ $(\"Prepare Git Data4\").first().json.gitFileName }}",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "8269d02",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 8269d02\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBBZGQgV29ya2Zsb3cgRmlsZTQiLCJ0eXBlVmVyc2lvbiI6MS4xLCJwYXJhbWV0ZXJLZXlzIjpbIm9wZXJhdGlvbiIsInBhdGhzVG9BZGQiLCJyZXBvc2l0b3J5UGF0aCJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "0222d1ad-a4fe-4df2-b4f2-61cbf8dbe91d",
      "name": "Git Commit Workflow File4",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        -96,
        -30240
      ],
      "parameters": {
        "operation": "commit",
        "repositoryPath": "={{ $(\"Prepare Git Data4\").first().json.gitRepoPath }}",
        "message": "={{ $(\"Prepare Git Data4\").first().json.gitCommitMessage }}",
        "options": {
          "branch": "={{ $(\"Prepare Git Data4\").first().json.config.gitBranch }}",
          "pathsToAdd": "={{ $(\"Prepare Git Data4\").first().json.gitFileName }}"
        },
        "_versionControl": {
          "version": "1.0.0",
          "hash": "b3f94d",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: b3f94d\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBDb21taXQgV29ya2Zsb3cgRmlsZTQiLCJ0eXBlVmVyc2lvbiI6MS4xLCJwYXJhbWV0ZXJLZXlzIjpbIm1lc3NhZ2UiLCJvcGVyYXRpb24iLCJvcHRpb25zIiwicmVwb3NpdG9yeVBhdGgiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "431a90ec-01d4-423c-9c96-0d0b51013beb",
      "name": "Git Latest Commit4",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        96,
        -30240
      ],
      "parameters": {
        "repositoryPath": "={{ $(\"Prepare Git Data4\").first().json.gitRepoPath }}",
        "limit": 1,
        "options": {
          "file": "={{ $(\"Prepare Git Data4\").first().json.gitFileName }}"
        },
        "_versionControl": {
          "version": "1.0.0",
          "hash": "f9c79b6",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: f9c79b6\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBMYXRlc3QgQ29tbWl0NCIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsibGltaXQiLCJvcHRpb25zIiwicmVwb3NpdG9yeVBhdGgiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "f5164679-54b7-4eb6-9003-46cc20561f2d",
      "name": "Git Push Enabled?4",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        288,
        -30240
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "git-push-enabled",
              "leftValue": "={{ $(\"Prepare Git Data4\").first().json.config.gitPushEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "20a44106",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 20a44106\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiR2l0IFB1c2ggRW5hYmxlZD80IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsiY29uZGl0aW9ucyIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "bbcb3bc9-046a-4d5d-8cdd-f09edd2304d8",
      "name": "Git Push Remote4",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        480,
        -30336
      ],
      "parameters": {
        "authentication": "gitPassword",
        "operation": "push",
        "repositoryPath": "={{ $(\"Prepare Git Data4\").first().json.gitRepoPath }}",
        "options": {
          "branch": "={{ $(\"Prepare Git Data4\").first().json.config.gitBranch }}",
          "targetRepository": "={{ $(\"Prepare Git Data4\").first().json.gitTargetRepository }}"
        },
        "_versionControl": {
          "version": "1.0.0",
          "hash": "74b47daf",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 74b47daf\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBQdXNoIFJlbW90ZTQiLCJ0eXBlVmVyc2lvbiI6MS4xLCJwYXJhbWV0ZXJLZXlzIjpbImF1dGhlbnRpY2F0aW9uIiwib3BlcmF0aW9uIiwib3B0aW9ucyIsInJlcG9zaXRvcnlQYXRoIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "a9e4bc3a-8c11-4750-b07b-689e4e0c3f8d",
      "name": "Finalize Git Local4",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        480,
        -30064
      ],
      "parameters": {
        "jsCode": "// Finalize Git status for local commit only\n\nconst base = $(\"Prepare Git Data4\").first().json;\nconst commit = $(\"Git Latest Commit4\").first().json;\n\nreturn {\n  json: {\n    ...base,\n    gitCommitted: true,\n    gitPushed: false,\n    gitCommit: commit\n      ? {\n          hash: commit.hash || null,\n          message: commit.message || null,\n          date: commit.date || null,\n          authorName: commit.author_name || null,\n          authorEmail: commit.author_email || null,\n        }\n      : null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2e18eaf8",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2e18eaf8\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJGaW5hbGl6ZSBHaXQgTG9jYWw0IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "e7f4eeb6-5789-4566-abbb-dd6be0a3baef",
      "name": "Finalize Git Push4",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        672,
        -30336
      ],
      "parameters": {
        "jsCode": "// Finalize Git status for local commit + remote push\n\nconst base = $(\"Prepare Git Data4\").first().json;\nconst commit = $(\"Git Latest Commit4\").first().json;\n\nreturn {\n  json: {\n    ...base,\n    gitCommitted: true,\n    gitPushed: true,\n    gitCommit: commit\n      ? {\n          hash: commit.hash || null,\n          message: commit.message || null,\n          date: commit.date || null,\n          authorName: commit.author_name || null,\n          authorEmail: commit.author_email || null,\n        }\n      : null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "17d4613e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 17d4613e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJGaW5hbGl6ZSBHaXQgUHVzaDQiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "cc0683ea-fba3-4c24-8415-77fdb9b1d693",
      "name": "Resolve Config Overrides1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2496,
        -31696
      ],
      "parameters": {
        "jsCode": "// Resolve effective config from defaults + optional overrides\n// Priority: configOverrides > top-level input/body > defaults\n\nconst defaults = $input.first().json || {};\nconst incoming = $(\"When Executed by Another Workflow\").first().json || {};\nconst body = (incoming.body && typeof incoming.body === 'object') ? incoming.body : {};\n\nconst nestedOverrides = (incoming.configOverrides && typeof incoming.configOverrides === 'object')\n  ? incoming.configOverrides\n  : ((body.configOverrides && typeof body.configOverrides === 'object') ? body.configOverrides : {});\n\nfunction pick(key, fallback = undefined) {\n  if (nestedOverrides[key] !== undefined) return nestedOverrides[key];\n  if (incoming[key] !== undefined) return incoming[key];\n  if (body[key] !== undefined) return body[key];\n  if (defaults[key] !== undefined) return defaults[key];\n  return fallback;\n}\n\nconst resolved = {\n  workflowId: pick('workflowId', null),\n  gitEnabled: pick('gitEnabled', true),\n  gitPushEnabled: pick('gitPushEnabled', true),\n  gitRepoPath: pick('gitRepoPath', '/files/backups/git-repo'),\n  gitBranch: pick('gitBranch', 'main'),\n  gitRemote: pick('gitRemote', 'origin'),\n  localBackupEnabled: pick('localBackupEnabled', true),\n  localBackupPath: pick('localBackupPath', '/files/backups'),\n  localBackupMaxVersions: pick('localBackupMaxVersions', 20),\n  cleanupOldBackupsEnabled: pick('cleanupOldBackupsEnabled', true),\n  n8nApiUrl: pick('n8nApiUrl', 'http://localhost:5678/api/v1'),\n  dryRun: pick('dryRun', false),\n  commitMessage: pick('commitMessage', null),\n};\n\nreturn { json: resolved };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73e6e987",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73e6e987\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJSZXNvbHZlIENvbmZpZyBPdmVycmlkZXMxIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "9465f597-7f96-4ee3-858c-529eee308ef2",
      "name": "Set Version Control Config Defaults",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -2672,
        -31696
      ],
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "1",
              "name": "workflowId",
              "value": "={{ $json.workflowId }}",
              "type": "string"
            },
            {
              "id": "2",
              "name": "gitEnabled",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "11",
              "name": "gitPushEnabled",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "12",
              "name": "gitRepoPath",
              "value": "/files/backups/git-repo",
              "type": "string"
            },
            {
              "id": "13",
              "name": "gitBranch",
              "value": "main",
              "type": "string"
            },
            {
              "id": "14",
              "name": "gitRemote",
              "value": "origin",
              "type": "string"
            },
            {
              "id": "7",
              "name": "localBackupEnabled",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "3",
              "name": "localBackupPath",
              "value": "/files/backups",
              "type": "string"
            },
            {
              "id": "9",
              "name": "localBackupMaxVersions",
              "value": 20,
              "type": "number"
            },
            {
              "id": "10",
              "name": "cleanupOldBackupsEnabled",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "4",
              "name": "n8nApiUrl",
              "value": "http://localhost:5678/api/v1",
              "type": "string"
            },
            {
              "id": "6",
              "name": "dryRun",
              "value": false,
              "type": "boolean"
            },
            {
              "id": "15",
              "name": "commitMessage",
              "value": "",
              "type": "string"
            }
          ]
        },
        "options": {},
        "_versionControl": {
          "version": "2.0.0",
          "hash": "1384e6a0",
          "created": "Feb 6, 2026, 05:16 PM",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 2.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v3.4\nüîí Hash: 1384e6a0\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uuc2V0IiwibmFtZSI6IlNldCBWZXJzaW9uIENvbnRyb2wgQ29uZmlnIERlZmF1bHRzIiwidHlwZVZlcnNpb24iOjMuNCwicGFyYW1ldGVyS2V5cyI6WyJhc3NpZ25tZW50cyIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7ImFzc2lnbm1lbnRzIjp7ImFzc2lnbm1lbnRDb3VudCI6MTN9fX0=\nüÜï Created: Feb 6, 2026, 05:16 PM",
      "notesInFlow": true
    },
    {
      "id": "af0b92e2-621b-441b-a948-eda1cecfe90f",
      "name": "Mark Backup Complete12",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -320,
        -31872
      ],
      "parameters": {
        "jsCode": "// Mark Backup Complete\n\nconst data = $input.first().json;\n\nreturn {\n  json: {\n    ...data,\n    backupSaved: true,\n    backupTimestamp: new Date().toISOString(),\n    backupPath: data.backupFullPath || null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "84b988f",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 84b988f\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJNYXJrIEJhY2t1cCBDb21wbGV0ZTEyIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "bd338af7-b5d1-44a0-9249-ea82b65ae5b9",
      "name": "Write Backup File12",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        -496,
        -31872
      ],
      "parameters": {
        "fileName": "={{ $json.backupFullPath }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "20c20b9a",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1\nüîí Hash: 20c20b9a\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uud3JpdGVCaW5hcnlGaWxlIiwibmFtZSI6IldyaXRlIEJhY2t1cCBGaWxlMTIiLCJ0eXBlVmVyc2lvbiI6MSwicGFyYW1ldGVyS2V5cyI6WyJmaWxlTmFtZSIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "132ab478-9241-4db6-85a6-02a79970abfa",
      "name": "Convert to Binary12",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -672,
        -31872
      ],
      "parameters": {
        "jsCode": "// Convert to Binary Data\n\nconst data = $input.first().json;\n\n// Convert JSON string to binary data\nconst binaryData = Buffer.from(data.workflowJson, 'utf-8');\n\nreturn {\n  json: data,\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'application/json',\n      fileName: data.backupFilename,\n      fileExtension: 'json'\n    }\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "792aa334",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 792aa334\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDb252ZXJ0IHRvIEJpbmFyeTEyIiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "9ef48b6f-5c4d-4d28-8c36-339c7987d2c5",
      "name": "Prepare Backup Data12",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -864,
        -31872
      ],
      "parameters": {
        "jsCode": "// Prepare Backup Data - Create filename and data\n\nconst data = $input.first().json;\nconst workflow = data.updatedWorkflow;\nconst version = data.workflowVersion.current;\nconst config = data.config;\n\n// Sanitize workflow name\nconst safeName = workflow.name\n  .replace(/\\s+/g, '_')\n  .replace(/[^a-zA-Z0-9_-]/g, '')\n  .substring(0, 50);\n\n// Generate human-readable timestamp\nconst now = new Date();\nconst year = now.getFullYear();\nconst month = String(now.getMonth() + 1).padStart(2, '0');\nconst day = String(now.getDate()).padStart(2, '0');\nconst hours = String(now.getHours()).padStart(2, '0');\nconst minutes = String(now.getMinutes()).padStart(2, '0');\nconst seconds = String(now.getSeconds()).padStart(2, '0');\n\nconst timestamp = `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;\n\nconst backupPrefix = `${safeName}-v`;\nconst filename = `${backupPrefix}${version}-${timestamp}.json`;\n\nlet backupDir = config.localBackupPath || '/tmp';\nif (backupDir.startsWith('~/')) {\n  const homeDir =\n    (typeof process !== 'undefined' && process.env && process.env.HOME)\n      ? process.env.HOME\n      : '/home/node';\n  backupDir = backupDir.replace(/^~(?=\\/)/, homeDir);\n}\n\nbackupDir = backupDir.replace(/\\/+$/, '') || '/tmp';\n\nreturn {\n  json: {\n    ...data,\n    backupPrefix,\n    backupFilename: filename,\n    backupDisplayPath: backupDir,\n    backupFullPath: `${backupDir}/${filename}`,\n    workflowJson: JSON.stringify(workflow, null, 2),\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "52eca43b",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 52eca43b\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcmVwYXJlIEJhY2t1cCBEYXRhMTIiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "ead0481a-84be-4d31-b512-73279ec5fb4a",
      "name": "Restore Data After Update14",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1216,
        -31856
      ],
      "parameters": {
        "jsCode": "// Restore Data After HTTP Request\n\n// Get the original data from Process Node Versions\nconst processData = $(\"Process Node Versions24\").first().json;\n\n// Get the HTTP response (current input)\nconst httpResponse = $input.first().json;\n\n// Merge them - keep all original data, add HTTP response\nreturn {\n  json: {\n    ...processData,\n    httpResponse: httpResponse,\n    workflowUpdated: true\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7c2c2fc2",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 7c2c2fc2\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJSZXN0b3JlIERhdGEgQWZ0ZXIgVXBkYXRlMTQiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "b0d964c5-f87c-4dee-8bfe-4e0c46aef932",
      "name": "Local Backup Enabled?15",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1040,
        -31856
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "local-backup-enabled",
              "leftValue": "={{ $json.config.localBackupEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "277dced1",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 277dced1\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiTG9jYWwgQmFja3VwIEVuYWJsZWQ/MTUiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "e7420c22-4174-43e3-8468-76a0232df581",
      "name": "Build Success Response24",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -992,
        -31392
      ],
      "parameters": {
        "jsCode": "// Build Success Response\n// Merge original process data with latest branch data so backup/cleanup/git fields are preserved.\n\nconst processData = $(\"Process Node Versions24\").first().json;\nconst latestData = $input.first().json;\nconst data = {\n  ...processData,\n  ...latestData,\n};\n\nconst cleanupEnabled = data.cleanupEnabled ?? (data.config?.cleanupOldBackupsEnabled ?? false);\n\nfunction buildWorkflowOpenUrl(apiUrl, workflowId, timestamp) {\n  if (!workflowId) return null;\n\n  const rawApiUrl = String(apiUrl || '').trim();\n  if (!rawApiUrl) return null;\n\n  const normalizedApiUrl = rawApiUrl.replace(/\\/$/, '');\n  const baseUrl = normalizedApiUrl\n    .replace(/\\/api\\/v\\d+$/, '')\n    .replace(/\\/api$/, '');\n\n  return `${baseUrl}/workflow/${encodeURIComponent(workflowId)}?updated=${encodeURIComponent(timestamp)}`;\n}\n\nconst timestamp = data.timestamp || new Date().toISOString();\nconst workflowId = data.config?.workflowId || 'unknown';\nconst openWorkflowUrl = buildWorkflowOpenUrl(data.config?.n8nApiUrl, workflowId, timestamp);\n\nconst summary = {\n  success: true,\n  message: data.hasChanges\n    ? `‚úÖ Version control updated: ${data.nodeChanges.length} node${data.nodeChanges.length !== 1 ? 's' : ''} changed`\n    : '‚ÑπÔ∏è No changes detected',\n  workflowId,\n  workflowName: data.updatedWorkflow?.name || data.originalWorkflow?.name || 'Unknown',\n  hasChanges: data.hasChanges || false,\n  nodeChanges: data.nodeChanges || [],\n  originalWorkflow: data.originalWorkflow,\n  updatedWorkflow: data.updatedWorkflow,\n  workflowVersion: data.workflowVersion || { previous: '1.0.0', current: '1.0.0' },\n  timestamp,\n  dryRun: false,\n  openWorkflowUrl,\n};\n\nsummary.git = {\n  enabled: data.config?.gitEnabled ?? false,\n  remotePushEnabled: data.config?.gitPushEnabled ?? false,\n  repoPath: data.gitRepoPath || data.config?.gitRepoPath || null,\n  fileName: data.gitFileName || null,\n  filePath: data.gitFilePath || null,\n  branch: data.config?.gitBranch || null,\n  remote: data.config?.gitRemote || null,\n  commitMessage: data.gitCommitMessage || data.config?.commitMessage || null,\n  committed: data.gitCommitted || false,\n  pushed: data.gitPushed || false,\n  commit: data.gitCommit || null,\n  error: data.gitError || null,\n};\n\nif (data.backupSaved !== undefined) {\n  summary.backup = {\n    saved: data.backupSaved,\n    filename: data.backupFilename || null,\n    path: data.backupPath || null,\n    error: data.backupError || data.backupCleanupError || null,\n    cleanup: {\n      enabled: cleanupEnabled,\n      performed: data.cleanupPerformed || false,\n      skipped: data.cleanupSkipped || false,\n      deleted: data.deletedBackups || 0,\n      files: data.deletedFiles || [],\n      prefix: data.cleanupPrefix || null,\n      matchedBackups: data.matchedBackups || 0,\n      maxVersions: data.cleanupMaxVersions ?? null,\n    },\n  };\n}\n\nreturn { json: summary };\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "115d7cc1",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 115d7cc1\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJCdWlsZCBTdWNjZXNzIFJlc3BvbnNlMjQiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "caca6e91-6f2b-4e91-b42e-88e2783196ed",
      "name": "Process Node Versions24",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1936,
        -31696
      ],
      "parameters": {
        "jsCode": "// Enhanced Process Node Versions with MAJOR, MINOR, and PATCH detection\n\nconst workflow = $input.first().json;\nconst config = $(\"Parse Configuration24\").first().json;\n\nfunction simpleHash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nfunction parseVersionFromNotes(notes) {\n  if (!notes) return null;\n  \n  const versionMatch = notes.match(/üìå Version: ([\\d.]+)/);\n  const modifiedMatch = notes.match(/üìÖ Modified: (.+?)(?:\\n|$)/);\n  const createdMatch = notes.match(/üÜï Created: (.+?)(?:\\n|$)/);\n  \n  if (!versionMatch) return null;\n  \n  return {\n    version: versionMatch[1],\n    lastModified: modifiedMatch ? modifiedMatch[1] : null,\n    created: createdMatch ? createdMatch[1] : null\n  };\n}\n\nfunction sortKeys(obj) {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(sortKeys);\n  \n  return Object.keys(obj)\n    .sort()\n    .reduce((result, key) => {\n      result[key] = sortKeys(obj[key]);\n      return result;\n    }, {});\n}\n\nfunction hashNode(node) {\n  // WHITELIST: Only include fields that define node behavior\n  const nodeForHash = {\n    type: node.type,\n    typeVersion: node.typeVersion\n  };\n  \n  // Copy parameters without _versionControl\n  if (node.parameters) {\n    const params = JSON.parse(JSON.stringify(node.parameters));\n    delete params._versionControl;\n    nodeForHash.parameters = params;\n  } else {\n    nodeForHash.parameters = {};\n  }\n  \n  // Only add optional fields if they have meaningful values\n  if (node.credentials && Object.keys(node.credentials).length > 0) {\n    nodeForHash.credentials = node.credentials;\n  }\n  \n  if (node.disabled === true) {\n    nodeForHash.disabled = true;\n  }\n  \n  if (node.webhookId) {\n    nodeForHash.webhookId = node.webhookId;\n  }\n  \n  // Sort keys for consistent hashing\n  const sorted = sortKeys(nodeForHash);\n  \n  return simpleHash(JSON.stringify(sorted));\n}\n\nfunction getHashFromNotes(notes) {\n  if (!notes) return null;\n  const hashMatch = notes.match(/üîí Hash: ([a-f0-9]+)/);\n  return hashMatch ? hashMatch[1] : null;\n}\n\nfunction getStoredNodeData(notes) {\n  if (!notes) return null;\n  \n  // Try to extract stored node snapshot from notes\n  const snapshotMatch = notes.match(/üóÇÔ∏è Snapshot: (.+?)(?:\\n|$)/);\n  if (snapshotMatch) {\n    try {\n      return JSON.parse(Buffer.from(snapshotMatch[1], 'base64').toString());\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction detectChangeType(oldSnapshot, newNode) {\n  // MAJOR: Breaking changes\n  if (!oldSnapshot) return { type: 'major', reason: 'New node' };\n  \n  // MAJOR: Node type changed\n  if (oldSnapshot.type !== newNode.type) {\n    return { type: 'major', reason: 'Node type changed' };\n  }\n  \n  // MAJOR: Node name changed\n  if (oldSnapshot.name !== newNode.name) {\n    return { type: 'major', reason: 'Node name changed' };\n  }\n  \n  // MAJOR: Type version changed significantly (major version bump)\n  if (oldSnapshot.typeVersion !== newNode.typeVersion) {\n    const oldVer = parseFloat(oldSnapshot.typeVersion) || 0;\n    const newVer = parseFloat(newNode.typeVersion) || 0;\n    if (Math.floor(newVer) > Math.floor(oldVer)) {\n      return { type: 'major', reason: `Node type upgraded from v${oldVer} to v${newVer}` };\n    }\n  }\n  \n  // Compare parameter keys (what we have in snapshot)\n  const oldKeys = (oldSnapshot.parameterKeys || []).sort();\n  const newParams = newNode.parameters || {};\n  const newParamsCopy = { ...newParams };\n  delete newParamsCopy._versionControl;\n  const newKeys = Object.keys(newParamsCopy).sort();\n  \n  // MINOR: Parameters added or removed\n  const addedKeys = newKeys.filter(k => !oldKeys.includes(k));\n  const removedKeys = oldKeys.filter(k => !newKeys.includes(k));\n  \n  if (addedKeys.length > 0) {\n    return { type: 'minor', reason: `Added parameter(s): ${addedKeys.join(', ')}` };\n  }\n  \n  if (removedKeys.length > 0) {\n    return { type: 'minor', reason: `Removed parameter(s): ${removedKeys.join(', ')}` };\n  }\n  \n  // MINOR: Check parameter structure changes (array lengths, etc.)\n  if (oldSnapshot.parameterStructure && newParams) {\n    for (const key in oldSnapshot.parameterStructure) {\n      const oldStruct = oldSnapshot.parameterStructure[key];\n      const newParam = newParams[key];\n      \n      if (!newParam) continue; // Parameter was removed (caught above)\n      \n      // Check assignment count changes\n      if (oldStruct.assignmentCount !== undefined) {\n        const newCount = newParam.assignments?.length || 0;\n        if (oldStruct.assignmentCount !== newCount) {\n          const change = newCount > oldStruct.assignmentCount ? 'Added' : 'Removed';\n          const diff = Math.abs(newCount - oldStruct.assignmentCount);\n          return { \n            type: 'minor', \n            reason: `${change} ${diff} assignment${diff > 1 ? 's' : ''} in '${key}'`\n          };\n        }\n      }\n      \n      // Check array length changes\n      if (oldStruct.arrayLength !== undefined) {\n        const newLength = Array.isArray(newParam) ? newParam.length : 0;\n        if (oldStruct.arrayLength !== newLength) {\n          return { \n            type: 'minor', \n            reason: `Array '${key}' size changed: ${oldStruct.arrayLength} ‚Üí ${newLength}`\n          };\n        }\n      }\n      \n      // Check parameter count changes (like HTTP headers)\n      if (oldStruct.paramCount !== undefined) {\n        const newCount = newParam.parameters?.length || 0;\n        if (oldStruct.paramCount !== newCount) {\n          return { \n            type: 'minor', \n            reason: `Parameter count in '${key}' changed: ${oldStruct.paramCount} ‚Üí ${newCount}`\n          };\n        }\n      }\n    }\n  }\n  \n  // If keys are the same and structure unchanged, it's a PATCH (value change)\n  return { type: 'patch', reason: 'Parameter values changed' };\n}\n\nfunction incrementVersion(version, changeType) {\n  const rawParts = String(version || '1.0.0').split('.').map(part => Number(part));\n  const parts = [\n    Number.isFinite(rawParts[0]) ? rawParts[0] : 1,\n    Number.isFinite(rawParts[1]) ? rawParts[1] : 0,\n    Number.isFinite(rawParts[2]) ? rawParts[2] : 0,\n  ];\n  \n  if (changeType === 'major') {\n    return `${parts[0] + 1}.0.0`;\n  }\n  \n  if (changeType === 'minor') {\n    return `${parts[0]}.${parts[1] + 1}.0`;\n  }\n  \n  // patch\n  return `${parts[0]}.${parts[1]}.${parts[2] + 1}`;\n}\n\nfunction formatDate(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('en-US', { \n    month: 'short', \n    day: 'numeric', \n    year: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  });\n}\n\nfunction createNodeSnapshot(node) {\n  // Create minimal snapshot for change detection\n  const snapshot = {\n    type: node.type,\n    name: node.name,\n    typeVersion: node.typeVersion,\n    parameterKeys: Object.keys(node.parameters || {}).filter(k => k !== '_versionControl').sort()\n  };\n  \n  // Store array lengths for parameters that are arrays or contain arrays\n  // This helps detect adding/removing items (MINOR change)\n  if (node.parameters) {\n    snapshot.parameterStructure = {};\n    \n    for (const key of snapshot.parameterKeys) {\n      const param = node.parameters[key];\n      \n      if (param && typeof param === 'object') {\n        // Check for common n8n patterns\n        if (param.assignments && Array.isArray(param.assignments)) {\n          // Set/Edit Fields node with assignments\n          snapshot.parameterStructure[key] = {\n            assignmentCount: param.assignments.length\n          };\n        } else if (Array.isArray(param)) {\n          // Direct array parameter\n          snapshot.parameterStructure[key] = {\n            arrayLength: param.length\n          };\n        } else if (param.parameters && Array.isArray(param.parameters)) {\n          // HTTP Request headers/parameters\n          snapshot.parameterStructure[key] = {\n            paramCount: param.parameters.length\n          };\n        }\n      }\n    }\n  }\n  \n  return snapshot;\n}\n\nfunction buildNodeNotes(versionInfo, typeVer, snapshot) {\n  const lines = [\n    `üìå Version: ${versionInfo.version}`,\n    `üìÖ Modified: ${formatDate(versionInfo.lastModified)}`,\n    `üîß Node Type: v${typeVer || 'N/A'}`,\n    `üîí Hash: ${versionInfo.hash.substring(0, 8)}`\n  ];\n  \n  // Store snapshot as base64 for next comparison\n  if (snapshot) {\n    const snapshotStr = Buffer.from(JSON.stringify(snapshot)).toString('base64');\n    lines.push(`üóÇÔ∏è Snapshot: ${snapshotStr}`);\n  }\n  \n  if (versionInfo.created && versionInfo.created !== versionInfo.lastModified) {\n    lines.push(`üÜï Created: ${formatDate(versionInfo.created)}`);\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction cleanNode(node) {\n  const cleaned = { \n    id: node.id, \n    name: node.name, \n    type: node.type, \n    typeVersion: node.typeVersion, \n    position: node.position, \n    parameters: node.parameters \n  };\n  \n  if (node.credentials) cleaned.credentials = node.credentials;\n  if (node.disabled) cleaned.disabled = node.disabled;\n  if (node.webhookId) cleaned.webhookId = node.webhookId;\n  \n  cleaned.notes = node.notes || '';\n  cleaned.notesInFlow = true;\n  \n  return cleaned;\n}\n\nconst timestamp = new Date().toISOString();\nconst nodeChanges = [];\nconst updatedNodes = [];\n\n// Process each node\nfor (const node of workflow.nodes) {\n  const currentHash = hashNode(node);\n  const parsedExistingVersion = parseVersionFromNotes(node.notes);\n  const existingVersion = parsedExistingVersion && parsedExistingVersion.version\n    ? parsedExistingVersion\n    : {\n      version: '1.0.0',\n      created: timestamp,\n      lastModified: timestamp\n    };\n  const previousHash = getHashFromNotes(node.notes);\n  const storedSnapshot = getStoredNodeData(node.notes);\n  \n  const isNew = !previousHash;\n  const hashChanged = previousHash && previousHash !== currentHash.substring(0, 8);\n  \n  // Check for name changes (MAJOR change that doesn't affect hash)\n  const nameChanged = storedSnapshot && storedSnapshot.name !== node.name;\n  \n  // Node has changed if hash OR name changed\n  const hasChanged = hashChanged || nameChanged;\n  \n  let versionInfo;\n  let changeType = 'patch';\n  let changeReason = null;\n  \n  if (isNew) {\n    // New node\n    versionInfo = {\n      version: '1.0.0',\n      hash: currentHash,\n      created: timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'created',\n      version: '1.0.0',\n      changeType: 'major',\n      reason: 'New node'\n    });\n  } else if (hasChanged) {\n    // Node changed - detect what kind of change\n    const changeDetection = detectChangeType(storedSnapshot, node);\n    changeType = changeDetection.type;\n    changeReason = changeDetection.reason;\n    \n    const newVersion = incrementVersion(existingVersion.version, changeType);\n    \n    versionInfo = {\n      version: newVersion,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: timestamp\n    };\n    \n    nodeChanges.push({\n      nodeName: node.name,\n      nodeId: node.id,\n      action: 'modified',\n      previousVersion: existingVersion.version,\n      version: newVersion,\n      changeType: changeType,\n      reason: changeReason\n    });\n  } else {\n    // No change\n    versionInfo = {\n      version: existingVersion.version,\n      hash: currentHash,\n      created: existingVersion.created || timestamp,\n      lastModified: existingVersion.lastModified || timestamp\n    };\n  }\n  \n  // Create snapshot for next comparison\n  const snapshot = createNodeSnapshot(node);\n  \n  const updatedNode = cleanNode({\n    ...node,\n    notes: buildNodeNotes(versionInfo, node.typeVersion, snapshot),\n    parameters: {\n      ...node.parameters,\n      _versionControl: versionInfo\n    }\n  });\n  \n  updatedNodes.push(updatedNode);\n}\n\n// Calculate workflow version\nlet wfNewVersion = '1.0.0';\nconst allVersions = updatedNodes.map(n => {\n  const parsed = parseVersionFromNotes(n.notes);\n  return parsed ? parsed.version : '1.0.0';\n});\n\nif (allVersions.length > 0) {\n  const maxParts = allVersions.map(v => v.split('.').map(Number)).reduce((max, cur) => {\n    if (cur[0] > max[0]) return cur;\n    if (cur[0] === max[0] && cur[1] > max[1]) return cur;\n    if (cur[0] === max[0] && cur[1] === max[1] && cur[2] > max[2]) return cur;\n    return max;\n  }, [1, 0, 0]);\n  wfNewVersion = maxParts.join('.');\n}\n\n// Build clean settings\nconst cleanSettings = {};\nif (workflow.settings?.errorWorkflow) cleanSettings.errorWorkflow = workflow.settings.errorWorkflow;\nif (workflow.settings?.timezone) cleanSettings.timezone = workflow.settings.timezone;\nif (workflow.settings?.saveManualExecutions !== undefined) cleanSettings.saveManualExecutions = workflow.settings.saveManualExecutions;\nif (workflow.settings?.saveExecutionProgress !== undefined) cleanSettings.saveExecutionProgress = workflow.settings.saveExecutionProgress;\nif (workflow.settings?.saveDataErrorExecution) cleanSettings.saveDataErrorExecution = workflow.settings.saveDataErrorExecution;\nif (workflow.settings?.saveDataSuccessExecution) cleanSettings.saveDataSuccessExecution = workflow.settings.saveDataSuccessExecution;\nif (workflow.settings?.executionTimeout !== undefined) cleanSettings.executionTimeout = workflow.settings.executionTimeout;\nif (workflow.settings?.executionOrder) cleanSettings.executionOrder = workflow.settings.executionOrder;\nif (workflow.settings?.availableInMCP !== undefined) cleanSettings.availableInMCP = workflow.settings.availableInMCP;\nif (workflow.settings?.callerPolicy) cleanSettings.callerPolicy = workflow.settings.callerPolicy;\n\nconst updatedWorkflow = { \n  name: workflow.name, \n  nodes: updatedNodes, \n  connections: workflow.connections, \n  settings: cleanSettings \n};\n\nreturn { \n  json: { \n    config: config,\n    originalWorkflow: workflow, \n    updatedWorkflow, \n    nodeChanges, \n    hasChanges: nodeChanges.length > 0, \n    workflowVersion: { \n      previous: '1.0.0', \n      current: wfNewVersion \n    }, \n    timestamp\n  } \n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "259cc4a1",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 259cc4a1\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcm9jZXNzIE5vZGUgVmVyc2lvbnMyNCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "e0d2b8b9-e59f-4acc-896d-c9c9b2b9949e",
      "name": "Dry Run Response24",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1376,
        -32016
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\n\nfunction buildWorkflowOpenUrl(apiUrl, workflowId, timestamp) {\n  if (!workflowId) return null;\n\n  const rawApiUrl = String(apiUrl || '').trim();\n  if (!rawApiUrl) return null;\n\n  const normalizedApiUrl = rawApiUrl.replace(/\\/$/, '');\n  const baseUrl = normalizedApiUrl\n    .replace(/\\/api\\/v\\d+$/, '')\n    .replace(/\\/api$/, '');\n\n  return `${baseUrl}/workflow/${encodeURIComponent(workflowId)}?updated=${encodeURIComponent(timestamp)}`;\n}\n\nconst timestamp = data.timestamp || new Date().toISOString();\nconst workflowId = data.config?.workflowId || null;\nconst openWorkflowUrl = buildWorkflowOpenUrl(data.config?.n8nApiUrl, workflowId, timestamp);\n\nreturn {\n  json: {\n    success: true,\n    message: 'Dry run completed - no changes applied',\n    workflowId,\n    workflowName: data.originalWorkflow?.name,\n    version: {\n      previous: data.workflowVersion?.previous,\n      wouldBecome: data.workflowVersion?.current,\n    },\n    changes: data.nodeChanges,\n    timestamp,\n    dryRun: true,\n    openWorkflowUrl,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "54cd6021",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 54cd6021\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJEcnkgUnVuIFJlc3BvbnNlMjQiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "c37fab87-f1bc-4b36-adb0-0876964472f7",
      "name": "Update Workflow with Versions24",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1376,
        -31856
      ],
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.config.n8nApiUrl }}/workflows/{{ $json.config.workflowId }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.updatedWorkflow) }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1747da31",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 1747da31\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiVXBkYXRlIFdvcmtmbG93IHdpdGggVmVyc2lvbnMyNCIsInR5cGVWZXJzaW9uIjo0LjIsInBhcmFtZXRlcktleXMiOlsiYXV0aGVudGljYXRpb24iLCJnZW5lcmljQXV0aFR5cGUiLCJoZWFkZXJQYXJhbWV0ZXJzIiwianNvbkJvZHkiLCJtZXRob2QiLCJvcHRpb25zIiwic2VuZEJvZHkiLCJzZW5kSGVhZGVycyIsInNwZWNpZnlCb2R5IiwidXJsIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6eyJoZWFkZXJQYXJhbWV0ZXJzIjp7InBhcmFtQ291bnQiOjF9fX0=",
      "notesInFlow": true
    },
    {
      "id": "2249a455-ef66-4976-9fac-f44ca401749a",
      "name": "Dry Run?24",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1616,
        -31920
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "dry-run",
              "leftValue": "={{ $json.config.dryRun }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2989d4ec",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2989d4ec\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRHJ5IFJ1bj8yNCIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "c90fba3d-8f0b-4c19-b9e9-34e3139559dc",
      "name": "No Changes Response24",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1600,
        -31504
      ],
      "parameters": {
        "jsCode": "const data = $input.first().json;\n\nfunction buildWorkflowOpenUrl(apiUrl, workflowId, timestamp) {\n  if (!workflowId) return null;\n\n  const rawApiUrl = String(apiUrl || '').trim();\n  if (!rawApiUrl) return null;\n\n  const normalizedApiUrl = rawApiUrl.replace(/\\/$/, '');\n  const baseUrl = normalizedApiUrl\n    .replace(/\\/api\\/v\\d+$/, '')\n    .replace(/\\/api$/, '');\n\n  return `${baseUrl}/workflow/${encodeURIComponent(workflowId)}?updated=${encodeURIComponent(timestamp)}`;\n}\n\nconst timestamp = data.timestamp || new Date().toISOString();\nconst workflowId = data.config?.workflowId || null;\nconst openWorkflowUrl = buildWorkflowOpenUrl(data.config?.n8nApiUrl, workflowId, timestamp);\n\nreturn {\n  json: {\n    success: true,\n    message: 'No changes detected',\n    workflowId,\n    workflowName: data.originalWorkflow?.name,\n    version: data.workflowVersion?.current,\n    timestamp,\n    openWorkflowUrl,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2fd48f36",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 2fd48f36\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJObyBDaGFuZ2VzIFJlc3BvbnNlMjQiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "c330843b-7680-448d-994b-d48e7887eaca",
      "name": "Has Changes?24",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1744,
        -31696
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "has-changes",
              "leftValue": "={{ $json.hasChanges }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73d9e12e",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 73d9e12e\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiSGFzIENoYW5nZXM/MjQiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJjb25kaXRpb25zIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "269ef967-bff9-4436-9701-bc73be7d182f",
      "name": "Fetch Current Workflow24",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -2128,
        -31696
      ],
      "parameters": {
        "url": "={{ $json.n8nApiUrl }}/workflows/{{ $json.workflowId }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "7ffe44bb",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v4.2\nüîí Hash: 7ffe44bb\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaHR0cFJlcXVlc3QiLCJuYW1lIjoiRmV0Y2ggQ3VycmVudCBXb3JrZmxvdzI0IiwidHlwZVZlcnNpb24iOjQuMiwicGFyYW1ldGVyS2V5cyI6WyJhdXRoZW50aWNhdGlvbiIsImdlbmVyaWNBdXRoVHlwZSIsIm9wdGlvbnMiLCJ1cmwiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "96440833-6587-4144-a493-dbbd81d402d8",
      "name": "Parse Configuration24",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2320,
        -31696
      ],
      "parameters": {
        "jsCode": "// Parse and validate resolved configuration\nconst input = $input.first().json || {};\n\nconst config = {\n  workflowId: input.workflowId || null,\n  gitEnabled: input.gitEnabled ?? false,\n  gitPushEnabled: input.gitPushEnabled ?? false,\n  gitRepoPath: String(input.gitRepoPath || '/files/backups/git-repo').replace(/\\/+$/, ''),\n  gitRemote: input.gitRemote || 'origin',\n  gitBranch: input.gitBranch || 'main',\n  localBackupEnabled: input.localBackupEnabled ?? false,\n  localBackupPath: String(input.localBackupPath || '/files/backups').replace(/\\/+$/, ''),\n  localBackupMaxVersions: Number(input.localBackupMaxVersions ?? 20),\n  cleanupOldBackupsEnabled: input.cleanupOldBackupsEnabled ?? false,\n  n8nApiUrl: input.n8nApiUrl || 'http://localhost:5678/api/v1',\n  commitMessage: input.commitMessage || null,\n  dryRun: input.dryRun ?? false,\n};\n\nif (!config.workflowId) {\n  throw new Error('workflowId is required. Provide it in the caller payload or configOverrides.');\n}\n\nif (config.gitEnabled && !config.gitRepoPath) {\n  throw new Error('gitRepoPath is required when gitEnabled=true.');\n}\n\nif (!Number.isFinite(config.localBackupMaxVersions) || config.localBackupMaxVersions < 1) {\n  config.localBackupMaxVersions = 20;\n}\n\nconfig.localBackupMaxVersions = Math.floor(config.localBackupMaxVersions);\n\nreturn { json: config };",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "49c382c6",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 49c382c6\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQYXJzZSBDb25maWd1cmF0aW9uMjQiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "ddde8fbc-1daa-4649-9b3b-10371755a9e5",
      "name": "Cleanup Old Backups10",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        96,
        -31856
      ],
      "parameters": {
        "jsCode": "// Cleanup Old Backups\n// Keep only newest N backups for the current workflow prefix.\n\nconst data = $input.first().json;\nconst config = data.config || {};\nconst cleanupEnabled = config.cleanupOldBackupsEnabled === true;\n\nif (!cleanupEnabled) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: false,\n      cleanupSkipped: true,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n    }\n  };\n}\n\nlet fs;\nlet path;\n\ntry {\n  fs = require('fs');\n  path = require('path');\n} catch (error) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n      backupCleanupError: 'Cleanup requires NODE_FUNCTION_ALLOW_BUILTIN=fs,path or disable cleanupOldBackupsEnabled.',\n      backupCleanupErrorDetails: error?.message || String(error),\n    }\n  };\n}\n\nconst backupDir = (data.backupDisplayPath || path.dirname(data.backupFullPath || '')).replace(/\\/+$/, '');\nconst currentFile = data.backupFilename || path.basename(data.backupFullPath || '');\nconst backupPrefix = data.backupPrefix || null;\n\nconst maxRaw = Number(config.localBackupMaxVersions ?? 20);\nconst maxVersions = Number.isFinite(maxRaw) ? Math.floor(maxRaw) : 20;\n\nfunction escapeRegex(value) {\n  return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction prefixFromFile(filename) {\n  const semverIndex = filename.indexOf('-v');\n  if (semverIndex > 0) return `${filename.slice(0, semverIndex)}-v`;\n  return null;\n}\n\nfunction getSortEpochMs(filename, fallbackMs) {\n  const match = filename.match(/-(\\d{4})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})-(\\d{2})\\.json$/);\n  if (!match) return fallbackMs;\n\n  const [, y, mo, d, h, mi, s] = match;\n  const dt = Date.UTC(Number(y), Number(mo) - 1, Number(d), Number(h), Number(mi), Number(s));\n  return Number.isFinite(dt) ? dt : fallbackMs;\n}\n\ntry {\n  if (!backupDir) {\n    return {\n      json: {\n        ...data,\n        cleanupEnabled: true,\n        cleanupSkipped: false,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Backup directory is missing.',\n      }\n    };\n  }\n\n  // Preserve the newest backup by default even if max is misconfigured.\n  const effectiveMax = maxVersions < 1 ? 1 : maxVersions;\n\n  const workflowPrefix = backupPrefix || prefixFromFile(currentFile);\n  if (!workflowPrefix) {\n    return {\n      json: {\n        ...data,\n        cleanupEnabled: true,\n        cleanupSkipped: false,\n        cleanupPerformed: false,\n        deletedBackups: 0,\n        deletedFiles: [],\n        backupCleanupError: 'Unable to determine workflow backup prefix.',\n      }\n    };\n  }\n\n  const filePattern = new RegExp(\n    `^${escapeRegex(workflowPrefix)}\\\\d+\\\\.\\\\d+\\\\.\\\\d+-\\\\d{4}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}-\\\\d{2}\\\\.json$`\n  );\n\n  const matchingFiles = fs\n    .readdirSync(backupDir, { withFileTypes: true })\n    .filter((entry) => entry.isFile())\n    .map((entry) => entry.name)\n    .filter((name) => filePattern.test(name))\n    .map((name) => {\n      const fullPath = path.join(backupDir, name);\n      const stats = fs.statSync(fullPath);\n      return {\n        name,\n        fullPath,\n        mtimeMs: stats.mtimeMs,\n        sortEpochMs: getSortEpochMs(name, stats.mtimeMs),\n      };\n    })\n    .sort((a, b) => {\n      if (a.sortEpochMs !== b.sortEpochMs) return a.sortEpochMs - b.sortEpochMs;\n      return a.mtimeMs - b.mtimeMs;\n    });\n\n  const deleteCount = Math.max(0, matchingFiles.length - effectiveMax);\n  const toDelete = matchingFiles.slice(0, deleteCount);\n\n  for (const file of toDelete) {\n    fs.unlinkSync(file.fullPath);\n  }\n\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: true,\n      cleanupPrefix: workflowPrefix,\n      cleanupMaxVersions: effectiveMax,\n      matchedBackups: matchingFiles.length,\n      deletedBackups: toDelete.length,\n      deletedFiles: toDelete.map((file) => file.name),\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...data,\n      cleanupEnabled: true,\n      cleanupSkipped: false,\n      cleanupPerformed: false,\n      deletedBackups: 0,\n      deletedFiles: [],\n      backupCleanupError: error?.message || String(error),\n    }\n  };\n}\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "88ad36f",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 88ad36f\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDbGVhbnVwIE9sZCBCYWNrdXBzMTAiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "1e167784-643f-4313-895e-e23aea0ab90c",
      "name": "Delete Old Backups Enabled?9",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -160,
        -31920
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "cleanup-old-backups-enabled",
              "leftValue": "={{ $json.config.cleanupOldBackupsEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "47bddea4",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 47bddea4\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiRGVsZXRlIE9sZCBCYWNrdXBzIEVuYWJsZWQ/OSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "babf29c2-0bbd-4678-9890-90409b3c4a2e",
      "name": "Git Enabled?5",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1248,
        -31472
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "git-enabled",
              "leftValue": "={{ $json.config.gitEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "6d2083b6",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 6d2083b6\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiR2l0IEVuYWJsZWQ/NSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImNvbmRpdGlvbnMiLCJvcHRpb25zIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "ddeeae3f-35ec-4bb4-adb5-6ae6d05bb349",
      "name": "Prepare Git Data5",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -992,
        -31584
      ],
      "parameters": {
        "jsCode": "// Prepare Git Data with stable filename (workflowId-based)\n\nconst data = $input.first().json;\nconst config = data.config || {};\n\nconst workflowId = config.workflowId || data.workflowId || 'unknown-workflow';\nconst repoPath = String(config.gitRepoPath || '/files/backups/git-repo').replace(/\\/+$/, '');\nconst gitFileName = `workflow-${workflowId}.json`;\nconst gitFilePath = `${repoPath}/${gitFileName}`;\n\nconst currentVersion = data.workflowVersion?.current || '1.0.0';\nconst workflowName = String(data.updatedWorkflow?.name || data.originalWorkflow?.name || 'Unknown Workflow')\n  .replace(/\\s+/g, ' ')\n  .trim();\nconst commitMessage = config.commitMessage\n  || `chore(workflow): ${workflowName} (${workflowId}) -> v${currentVersion}`;\n\nconst rawRemote = String(config.gitRemote || '').trim();\nconst gitTargetRepository = !rawRemote || rawRemote === 'origin' ? '' : rawRemote;\n\nconst gitWorkflowJson = `${JSON.stringify(data.updatedWorkflow, null, 2)}\n`;\n\nreturn {\n  json: {\n    ...data,\n    gitRepoPath: repoPath,\n    gitFileName,\n    gitFilePath,\n    gitWorkflowJson,\n    gitCommitMessage: commitMessage,\n    gitTargetRepository,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "65e96bfe",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 65e96bfe\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJQcmVwYXJlIEdpdCBEYXRhNSIsInR5cGVWZXJzaW9uIjoyLCJwYXJhbWV0ZXJLZXlzIjpbImpzQ29kZSJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "d985db9e-3186-41bb-8b9f-0286aeb600d7",
      "name": "Convert Git Workflow to Binary5",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -784,
        -31584
      ],
      "parameters": {
        "jsCode": "// Convert Git workflow JSON to binary for Write Binary File node\n\nconst data = $input.first().json;\nconst binaryData = Buffer.from(data.gitWorkflowJson, 'utf-8');\n\nreturn {\n  json: data,\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'application/json',\n      fileName: data.gitFileName,\n      fileExtension: 'json',\n    }\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "1e6d3a18",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 1e6d3a18\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJDb252ZXJ0IEdpdCBXb3JrZmxvdyB0byBCaW5hcnk1IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "2cf72da4-3e0d-4f16-9beb-b642312d1278",
      "name": "Write Git Workflow File5",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        -592,
        -31584
      ],
      "parameters": {
        "fileName": "={{ $json.gitFilePath }}",
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "2307914b",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1\nüîí Hash: 2307914b\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2Uud3JpdGVCaW5hcnlGaWxlIiwibmFtZSI6IldyaXRlIEdpdCBXb3JrZmxvdyBGaWxlNSIsInR5cGVWZXJzaW9uIjoxLCJwYXJhbWV0ZXJLZXlzIjpbImZpbGVOYW1lIiwib3B0aW9ucyJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "91b609f4-6a3b-44d4-9972-7511b409ef13",
      "name": "Git Add Workflow File5",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        -384,
        -31584
      ],
      "parameters": {
        "operation": "add",
        "repositoryPath": "={{ $(\"Prepare Git Data5\").first().json.gitRepoPath }}",
        "pathsToAdd": "={{ $(\"Prepare Git Data5\").first().json.gitFileName }}",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "73dcfd7c",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 73dcfd7c\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBBZGQgV29ya2Zsb3cgRmlsZTUiLCJ0eXBlVmVyc2lvbiI6MS4xLCJwYXJhbWV0ZXJLZXlzIjpbIm9wZXJhdGlvbiIsInBhdGhzVG9BZGQiLCJyZXBvc2l0b3J5UGF0aCJdLCJwYXJhbWV0ZXJTdHJ1Y3R1cmUiOnt9fQ==",
      "notesInFlow": true
    },
    {
      "id": "33d66e32-6552-4d78-810f-608e9d7daab3",
      "name": "Git Commit Workflow File5",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        -192,
        -31584
      ],
      "parameters": {
        "operation": "commit",
        "repositoryPath": "={{ $(\"Prepare Git Data5\").first().json.gitRepoPath }}",
        "message": "={{ $(\"Prepare Git Data5\").first().json.gitCommitMessage }}",
        "options": {
          "branch": "={{ $(\"Prepare Git Data5\").first().json.config.gitBranch }}",
          "pathsToAdd": "={{ $(\"Prepare Git Data5\").first().json.gitFileName }}"
        },
        "_versionControl": {
          "version": "1.0.0",
          "hash": "340e3c09",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 340e3c09\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBDb21taXQgV29ya2Zsb3cgRmlsZTUiLCJ0eXBlVmVyc2lvbiI6MS4xLCJwYXJhbWV0ZXJLZXlzIjpbIm1lc3NhZ2UiLCJvcGVyYXRpb24iLCJvcHRpb25zIiwicmVwb3NpdG9yeVBhdGgiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "1ccc2922-d474-46b3-9f95-3ab3a1738d16",
      "name": "Git Latest Commit5",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        0,
        -31584
      ],
      "parameters": {
        "repositoryPath": "={{ $(\"Prepare Git Data5\").first().json.gitRepoPath }}",
        "limit": 1,
        "options": {
          "file": "={{ $(\"Prepare Git Data5\").first().json.gitFileName }}"
        },
        "_versionControl": {
          "version": "1.0.0",
          "hash": "3940a414",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 3940a414\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBMYXRlc3QgQ29tbWl0NSIsInR5cGVWZXJzaW9uIjoxLjEsInBhcmFtZXRlcktleXMiOlsibGltaXQiLCJvcHRpb25zIiwicmVwb3NpdG9yeVBhdGgiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "f6a9293f-c026-4148-8a8a-11874a05ae64",
      "name": "Git Push Enabled?5",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        192,
        -31584
      ],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "git-push-enabled",
              "leftValue": "={{ $(\"Prepare Git Data5\").first().json.config.gitPushEnabled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {},
        "_versionControl": {
          "version": "1.0.0",
          "hash": "351e1cc5",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 351e1cc5\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuaWYiLCJuYW1lIjoiR2l0IFB1c2ggRW5hYmxlZD81IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsiY29uZGl0aW9ucyIsIm9wdGlvbnMiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    },
    {
      "id": "8c8a3cfb-2739-41f4-87fe-d64dd5764ea0",
      "name": "Git Push Remote5",
      "type": "n8n-nodes-base.git",
      "typeVersion": 1.1,
      "position": [
        432,
        -31680
      ],
      "parameters": {
        "authentication": "gitPassword",
        "operation": "push",
        "repositoryPath": "={{ $(\"Prepare Git Data5\").first().json.gitRepoPath }}",
        "options": {
          "branch": "={{ $(\"Prepare Git Data5\").first().json.config.gitBranch }}",
          "targetRepository": "={{ $(\"Prepare Git Data5\").first().json.gitTargetRepository }}"
        },
        "_versionControl": {
          "version": "1.0.0",
          "hash": "4e511352",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v1.1\nüîí Hash: 4e511352\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuZ2l0IiwibmFtZSI6IkdpdCBQdXNoIFJlbW90ZTUiLCJ0eXBlVmVyc2lvbiI6MS4xLCJwYXJhbWV0ZXJLZXlzIjpbImF1dGhlbnRpY2F0aW9uIiwib3BlcmF0aW9uIiwib3B0aW9ucyIsInJlcG9zaXRvcnlQYXRoIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "d632dbb6-c9a4-4e75-b052-8851b8f34dc7",
      "name": "Finalize Git Local5",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        368,
        -31424
      ],
      "parameters": {
        "jsCode": "// Finalize Git status for local commit only\n\nconst base = $(\"Prepare Git Data5\").first().json;\nconst commit = $(\"Git Latest Commit5\").first().json;\n\nreturn {\n  json: {\n    ...base,\n    gitCommitted: true,\n    gitPushed: false,\n    gitCommit: commit\n      ? {\n          hash: commit.hash || null,\n          message: commit.message || null,\n          date: commit.date || null,\n          authorName: commit.author_name || null,\n          authorEmail: commit.author_email || null,\n        }\n      : null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "4262013a",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 4262013a\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJGaW5hbGl6ZSBHaXQgTG9jYWw1IiwidHlwZVZlcnNpb24iOjIsInBhcmFtZXRlcktleXMiOlsianNDb2RlIl0sInBhcmFtZXRlclN0cnVjdHVyZSI6e319",
      "notesInFlow": true
    },
    {
      "id": "ad8622ba-61b1-44af-84de-083657aba76a",
      "name": "Finalize Git Push5",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        592,
        -31680
      ],
      "parameters": {
        "jsCode": "// Finalize Git status for local commit + remote push\n\nconst base = $(\"Prepare Git Data5\").first().json;\nconst commit = $(\"Git Latest Commit5\").first().json;\n\nreturn {\n  json: {\n    ...base,\n    gitCommitted: true,\n    gitPushed: true,\n    gitCommit: commit\n      ? {\n          hash: commit.hash || null,\n          message: commit.message || null,\n          date: commit.date || null,\n          authorName: commit.author_name || null,\n          authorEmail: commit.author_email || null,\n        }\n      : null,\n  }\n};\n",
        "_versionControl": {
          "version": "1.0.0",
          "hash": "6ca9f4c4",
          "created": "2026-02-08T05:48:16.467Z",
          "lastModified": "2026-02-08T05:48:16.467Z"
        }
      },
      "notes": "üìå Version: 1.0.0\nüìÖ Modified: Feb 8, 2026, 05:48 AM\nüîß Node Type: v2\nüîí Hash: 6ca9f4c4\nüóÇÔ∏è Snapshot: eyJ0eXBlIjoibjhuLW5vZGVzLWJhc2UuY29kZSIsIm5hbWUiOiJGaW5hbGl6ZSBHaXQgUHVzaDUiLCJ0eXBlVmVyc2lvbiI6MiwicGFyYW1ldGVyS2V5cyI6WyJqc0NvZGUiXSwicGFyYW1ldGVyU3RydWN0dXJlIjp7fX0=",
      "notesInFlow": true
    }
  ],
  "connections": {
    "Parse Configuration": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow": {
      "main": [
        [
          {
            "node": "Process Node Versions4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?": {
      "main": [
        [
          {
            "node": "Dry Run?",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Changes Response": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?": {
      "main": [
        [
          {
            "node": "Dry Run Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions": {
      "main": [
        [
          {
            "node": "Build Success Response1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions4": {
      "main": [
        [
          {
            "node": "Has Changes?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "Parse Configuration1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration1": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow1": {
      "main": [
        [
          {
            "node": "Process Node Versions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?1": {
      "main": [
        [
          {
            "node": "Dry Run?1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Changes Response1": {
      "main": [
        [
          {
            "node": "Respond to Webhook1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?1": {
      "main": [
        [
          {
            "node": "Dry Run Response1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions1": {
      "main": [
        [
          {
            "node": "Build Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response1": {
      "main": [
        [
          {
            "node": "Respond to Webhook1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions": {
      "main": [
        [
          {
            "node": "Has Changes?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration2": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow2": {
      "main": [
        [
          {
            "node": "Process Node Versions1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?2": {
      "main": [
        [
          {
            "node": "Dry Run?2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Changes Response2": {
      "main": [
        [
          {
            "node": "Respond to Webhook2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?2": {
      "main": [
        [
          {
            "node": "Dry Run Response2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions2": {
      "main": [
        [
          {
            "node": "Build Success Response2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response2": {
      "main": [
        [
          {
            "node": "Respond to Webhook2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions1": {
      "main": [
        [
          {
            "node": "Has Changes?2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration3": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow3": {
      "main": [
        [
          {
            "node": "Process Node Versions2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?3": {
      "main": [
        [
          {
            "node": "Dry Run?3",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?3": {
      "main": [
        [
          {
            "node": "Dry Run Response3",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response3": {
      "main": [
        [
          {
            "node": "Respond to Webhook3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions2": {
      "main": [
        [
          {
            "node": "Has Changes?3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions3": {
      "main": [
        [
          {
            "node": "Build Success Response3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration4": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow4": {
      "main": [
        [
          {
            "node": "Process Node Versions3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?4": {
      "main": [
        [
          {
            "node": "Dry Run?4",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?4": {
      "main": [
        [
          {
            "node": "Dry Run Response4",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions4": {
      "main": [
        [
          {
            "node": "Build Success Response4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response4": {
      "main": [
        [
          {
            "node": "Respond to Webhook4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions3": {
      "main": [
        [
          {
            "node": "Has Changes?4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration5": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow5": {
      "main": [
        [
          {
            "node": "Process Node Versions5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?5": {
      "main": [
        [
          {
            "node": "Dry Run?5",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?5": {
      "main": [
        [
          {
            "node": "Dry Run Response5",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions5": {
      "main": [
        [
          {
            "node": "Build Success Response5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response5": {
      "main": [
        [
          {
            "node": "Respond to Webhook5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions5": {
      "main": [
        [
          {
            "node": "Has Changes?5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration6": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow6": {
      "main": [
        [
          {
            "node": "Process Node Versions6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?6": {
      "main": [
        [
          {
            "node": "Dry Run?6",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?6": {
      "main": [
        [
          {
            "node": "Dry Run Response6",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions6": {
      "main": [
        [
          {
            "node": "Build Success Response6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response6": {
      "main": [
        [
          {
            "node": "Respond to Webhook6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions6": {
      "main": [
        [
          {
            "node": "Has Changes?6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration7": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow7": {
      "main": [
        [
          {
            "node": "Process Node Versions7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?7": {
      "main": [
        [
          {
            "node": "Dry Run?7",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?7": {
      "main": [
        [
          {
            "node": "Dry Run Response7",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions7": {
      "main": [
        [
          {
            "node": "Build Success Response7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response7": {
      "main": [
        [
          {
            "node": "Respond to Webhook7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions7": {
      "main": [
        [
          {
            "node": "Has Changes?7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration8": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow8",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow8": {
      "main": [
        [
          {
            "node": "Process Node Versions8",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?8": {
      "main": [
        [
          {
            "node": "Dry Run?8",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response8",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?8": {
      "main": [
        [
          {
            "node": "Dry Run Response8",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions8",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions8": {
      "main": [
        [
          {
            "node": "Build Success Response8",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response8": {
      "main": [
        [
          {
            "node": "Respond to Webhook8",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions8": {
      "main": [
        [
          {
            "node": "Has Changes?8",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Local Backup Enabled?": {
      "main": [
        [
          {
            "node": "Save Local Backup",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Success Response9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Local Backup": {
      "main": [
        [
          {
            "node": "Cleanup Old Versions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cleanup Old Versions": {
      "main": [
        [
          {
            "node": "Build Success Response9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration9": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow9": {
      "main": [
        [
          {
            "node": "Process Node Versions9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?9": {
      "main": [
        [
          {
            "node": "Dry Run?9",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?9": {
      "main": [
        [
          {
            "node": "Dry Run Response9",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions9": {
      "main": [
        [
          {
            "node": "Local Backup Enabled?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response9": {
      "main": [
        [
          {
            "node": "Respond to Webhook9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions9": {
      "main": [
        [
          {
            "node": "Has Changes?9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Data After Update": {
      "main": [
        [
          {
            "node": "Local Backup Enabled?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration10": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow10",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow10": {
      "main": [
        [
          {
            "node": "Process Node Versions10",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?10": {
      "main": [
        [
          {
            "node": "Dry Run?10",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response10",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?10": {
      "main": [
        [
          {
            "node": "Dry Run Response10",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions10",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions10": {
      "main": [
        [
          {
            "node": "Restore Data After Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response10": {
      "main": [
        [
          {
            "node": "Respond to Webhook10",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions10": {
      "main": [
        [
          {
            "node": "Has Changes?10",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Local Backup Enabled?1": {
      "main": [
        [
          {
            "node": "Save Local Backup1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Success Response10",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Local Backup1": {
      "main": [
        [
          {
            "node": "Cleanup Old Versions1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cleanup Old Versions1": {
      "main": [
        [
          {
            "node": "Build Success Response10",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration11": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow11",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow11": {
      "main": [
        [
          {
            "node": "Process Node Versions11",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?11": {
      "main": [
        [
          {
            "node": "Dry Run?11",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response11",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?11": {
      "main": [
        [
          {
            "node": "Dry Run Response11",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions11",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions11": {
      "main": [
        [
          {
            "node": "Restore Data After Update1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response11": {
      "main": [
        [
          {
            "node": "Respond to Webhook11",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions11": {
      "main": [
        [
          {
            "node": "Has Changes?11",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Local Backup Enabled?2": {
      "main": [
        [
          {
            "node": "Save Local Backup2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Success Response11",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Local Backup2": {
      "main": [
        [
          {
            "node": "Cleanup Old Versions2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cleanup Old Versions2": {
      "main": [
        [
          {
            "node": "Build Success Response11",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Data After Update1": {
      "main": [
        [
          {
            "node": "Local Backup Enabled?2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Backup Data": {
      "main": [
        [
          {
            "node": "Convert to Binary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to Binary": {
      "main": [
        [
          {
            "node": "Write Backup File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Backup File": {
      "main": [
        [
          {
            "node": "Mark Backup Complete",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Backup Complete": {
      "main": [
        [
          {
            "node": "Build Success Response12",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration12": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow12",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow12": {
      "main": [
        [
          {
            "node": "Process Node Versions12",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?12": {
      "main": [
        [
          {
            "node": "Dry Run?12",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response12",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?12": {
      "main": [
        [
          {
            "node": "Dry Run Response12",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions12",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions12": {
      "main": [
        [
          {
            "node": "Restore Data After Update2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response12": {
      "main": [
        [
          {
            "node": "Respond to Webhook12",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions12": {
      "main": [
        [
          {
            "node": "Has Changes?12",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Local Backup Enabled?3": {
      "main": [
        [
          {
            "node": "Prepare Backup Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Success Response12",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Data After Update2": {
      "main": [
        [
          {
            "node": "Local Backup Enabled?3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Backup Complete1": {
      "main": [
        [
          {
            "node": "Build Success Response13",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Backup File1": {
      "main": [
        [
          {
            "node": "Mark Backup Complete1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to Binary1": {
      "main": [
        [
          {
            "node": "Write Backup File1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Backup Data1": {
      "main": [
        [
          {
            "node": "Convert to Binary1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Data After Update3": {
      "main": [
        [
          {
            "node": "Local Backup Enabled?4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Local Backup Enabled?4": {
      "main": [
        [
          {
            "node": "Prepare Backup Data1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Success Response13",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions13": {
      "main": [
        [
          {
            "node": "Has Changes?13",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response13": {
      "main": [
        [
          {
            "node": "Respond to Webhook13",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions13": {
      "main": [
        [
          {
            "node": "Restore Data After Update3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?13": {
      "main": [
        [
          {
            "node": "Dry Run Response13",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions13",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?13": {
      "main": [
        [
          {
            "node": "Dry Run?13",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response13",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow13": {
      "main": [
        [
          {
            "node": "Process Node Versions13",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration13": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow13",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cleanup Old Backups": {
      "main": [
        [
          {
            "node": "Build Success Response14",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Backup Complete2": {
      "main": [
        [
          {
            "node": "Cleanup Old Backups",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Backup File2": {
      "main": [
        [
          {
            "node": "Mark Backup Complete2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to Binary2": {
      "main": [
        [
          {
            "node": "Write Backup File2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Backup Data2": {
      "main": [
        [
          {
            "node": "Convert to Binary2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Data After Update4": {
      "main": [
        [
          {
            "node": "Local Backup Enabled?5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Local Backup Enabled?5": {
      "main": [
        [
          {
            "node": "Prepare Backup Data2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Success Response14",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions14": {
      "main": [
        [
          {
            "node": "Has Changes?14",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response14": {
      "main": [
        [
          {
            "node": "Respond to Webhook14",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions14": {
      "main": [
        [
          {
            "node": "Restore Data After Update4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?14": {
      "main": [
        [
          {
            "node": "Dry Run Response14",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions14",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?14": {
      "main": [
        [
          {
            "node": "Dry Run?14",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response14",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow14": {
      "main": [
        [
          {
            "node": "Process Node Versions14",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration14": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow14",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Backups Enabled?": {
      "main": [
        [
          {
            "node": "Cleanup Old Backups1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Success Response15",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Backup Complete3": {
      "main": [
        [
          {
            "node": "Delete Old Backups Enabled?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Backup File3": {
      "main": [
        [
          {
            "node": "Mark Backup Complete3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to Binary3": {
      "main": [
        [
          {
            "node": "Write Backup File3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Backup Data3": {
      "main": [
        [
          {
            "node": "Convert to Binary3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Data After Update5": {
      "main": [
        [
          {
            "node": "Local Backup Enabled?6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Local Backup Enabled?6": {
      "main": [
        [
          {
            "node": "Prepare Backup Data3",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Success Response15",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions15": {
      "main": [
        [
          {
            "node": "Has Changes?15",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response15": {
      "main": [
        [
          {
            "node": "Respond to Webhook15",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions15": {
      "main": [
        [
          {
            "node": "Restore Data After Update5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?15": {
      "main": [
        [
          {
            "node": "Dry Run Response15",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions15",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?15": {
      "main": [
        [
          {
            "node": "Dry Run?15",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response15",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow15": {
      "main": [
        [
          {
            "node": "Process Node Versions15",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration15": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow15",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cleanup Old Backups1": {
      "main": [
        [
          {
            "node": "Build Success Response15",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Backup Complete4": {
      "main": [
        [
          {
            "node": "Delete Old Backups Enabled?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Backup File4": {
      "main": [
        [
          {
            "node": "Mark Backup Complete4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to Binary4": {
      "main": [
        [
          {
            "node": "Write Backup File4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Backup Data4": {
      "main": [
        [
          {
            "node": "Convert to Binary4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Data After Update6": {
      "main": [
        [
          {
            "node": "Local Backup Enabled?7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Local Backup Enabled?7": {
      "main": [
        [
          {
            "node": "Prepare Backup Data4",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Success Response16",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions16": {
      "main": [
        [
          {
            "node": "Has Changes?16",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response16": {
      "main": [
        [
          {
            "node": "Respond to Webhook16",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions16": {
      "main": [
        [
          {
            "node": "Restore Data After Update6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?16": {
      "main": [
        [
          {
            "node": "Dry Run Response16",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions16",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?16": {
      "main": [
        [
          {
            "node": "Dry Run?16",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response16",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow16": {
      "main": [
        [
          {
            "node": "Process Node Versions16",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration16": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow16",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cleanup Old Backups2": {
      "main": [
        [
          {
            "node": "Build Success Response16",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Backups Enabled?1": {
      "main": [
        [
          {
            "node": "Cleanup Old Backups2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Success Response16",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Backup Complete5": {
      "main": [
        [
          {
            "node": "Delete Old Backups Enabled?2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Backup File5": {
      "main": [
        [
          {
            "node": "Mark Backup Complete5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to Binary5": {
      "main": [
        [
          {
            "node": "Write Backup File5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Backup Data5": {
      "main": [
        [
          {
            "node": "Convert to Binary5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Data After Update7": {
      "main": [
        [
          {
            "node": "Local Backup Enabled?8",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Local Backup Enabled?8": {
      "main": [
        [
          {
            "node": "Prepare Backup Data5",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Success Response17",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions17": {
      "main": [
        [
          {
            "node": "Has Changes?17",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response17": {
      "main": [
        [
          {
            "node": "Respond to Webhook17",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions17": {
      "main": [
        [
          {
            "node": "Restore Data After Update7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?17": {
      "main": [
        [
          {
            "node": "Dry Run Response17",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions17",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?17": {
      "main": [
        [
          {
            "node": "Dry Run?17",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response17",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow17": {
      "main": [
        [
          {
            "node": "Process Node Versions17",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration17": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow17",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cleanup Old Backups3": {
      "main": [
        [
          {
            "node": "Build Success Response17",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Backups Enabled?2": {
      "main": [
        [
          {
            "node": "Cleanup Old Backups3",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Success Response17",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Backup Complete6": {
      "main": [
        [
          {
            "node": "Delete Old Backups Enabled?3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Backup File6": {
      "main": [
        [
          {
            "node": "Mark Backup Complete6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to Binary6": {
      "main": [
        [
          {
            "node": "Write Backup File6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Backup Data6": {
      "main": [
        [
          {
            "node": "Convert to Binary6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Data After Update8": {
      "main": [
        [
          {
            "node": "Local Backup Enabled?9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Local Backup Enabled?9": {
      "main": [
        [
          {
            "node": "Prepare Backup Data6",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Success Response18",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions18": {
      "main": [
        [
          {
            "node": "Has Changes?18",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response18": {
      "main": [
        [
          {
            "node": "Respond to Webhook18",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions18": {
      "main": [
        [
          {
            "node": "Restore Data After Update8",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?18": {
      "main": [
        [
          {
            "node": "Dry Run Response18",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions18",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?18": {
      "main": [
        [
          {
            "node": "Dry Run?18",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response18",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow18": {
      "main": [
        [
          {
            "node": "Process Node Versions18",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration18": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow18",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cleanup Old Backups4": {
      "main": [
        [
          {
            "node": "Build Success Response18",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Backups Enabled?3": {
      "main": [
        [
          {
            "node": "Cleanup Old Backups4",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Success Response18",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Enabled?": {
      "main": [
        [
          {
            "node": "Prepare Git Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Success Response19",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Git Data": {
      "main": [
        [
          {
            "node": "Convert Git Workflow to Binary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert Git Workflow to Binary": {
      "main": [
        [
          {
            "node": "Write Git Workflow File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Git Workflow File": {
      "main": [
        [
          {
            "node": "Git Add Workflow File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Add Workflow File": {
      "main": [
        [
          {
            "node": "Git Commit Workflow File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Commit Workflow File": {
      "main": [
        [
          {
            "node": "Git Latest Commit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Latest Commit": {
      "main": [
        [
          {
            "node": "Git Push Enabled?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Push Enabled?": {
      "main": [
        [
          {
            "node": "Git Push Remote",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Finalize Git Local",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Push Remote": {
      "main": [
        [
          {
            "node": "Finalize Git Push",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Finalize Git Local": {
      "main": [
        [
          {
            "node": "Build Success Response19",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Finalize Git Push": {
      "main": [
        [
          {
            "node": "Build Success Response19",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Backup Complete7": {
      "main": [
        [
          {
            "node": "Delete Old Backups Enabled?4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Backup File7": {
      "main": [
        [
          {
            "node": "Mark Backup Complete7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to Binary7": {
      "main": [
        [
          {
            "node": "Write Backup File7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Backup Data7": {
      "main": [
        [
          {
            "node": "Convert to Binary7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Data After Update9": {
      "main": [
        [
          {
            "node": "Local Backup Enabled?10",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Local Backup Enabled?10": {
      "main": [
        [
          {
            "node": "Prepare Backup Data7",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Git Enabled?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions19": {
      "main": [
        [
          {
            "node": "Has Changes?19",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response19": {
      "main": [
        [
          {
            "node": "Respond to Webhook19",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions19": {
      "main": [
        [
          {
            "node": "Restore Data After Update9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?19": {
      "main": [
        [
          {
            "node": "Dry Run Response19",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions19",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?19": {
      "main": [
        [
          {
            "node": "Dry Run?19",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response19",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow19": {
      "main": [
        [
          {
            "node": "Process Node Versions19",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration19": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow19",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cleanup Old Backups5": {
      "main": [
        [
          {
            "node": "Git Enabled?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Backups Enabled?4": {
      "main": [
        [
          {
            "node": "Cleanup Old Backups5",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Git Enabled?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Backup Complete8": {
      "main": [
        [
          {
            "node": "Delete Old Backups Enabled?5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Backup File8": {
      "main": [
        [
          {
            "node": "Mark Backup Complete8",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to Binary8": {
      "main": [
        [
          {
            "node": "Write Backup File8",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Backup Data8": {
      "main": [
        [
          {
            "node": "Convert to Binary8",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Data After Update10": {
      "main": [
        [
          {
            "node": "Local Backup Enabled?11",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Local Backup Enabled?11": {
      "main": [
        [
          {
            "node": "Prepare Backup Data8",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Git Enabled?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions20": {
      "main": [
        [
          {
            "node": "Has Changes?20",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response20": {
      "main": [
        [
          {
            "node": "Respond to Webhook20",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions20": {
      "main": [
        [
          {
            "node": "Restore Data After Update10",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?20": {
      "main": [
        [
          {
            "node": "Dry Run Response20",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions20",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?20": {
      "main": [
        [
          {
            "node": "Dry Run?20",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response20",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow20": {
      "main": [
        [
          {
            "node": "Process Node Versions20",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration20": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow20",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cleanup Old Backups6": {
      "main": [
        [
          {
            "node": "Git Enabled?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Backups Enabled?5": {
      "main": [
        [
          {
            "node": "Cleanup Old Backups6",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Git Enabled?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Enabled?1": {
      "main": [
        [
          {
            "node": "Prepare Git Data1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Success Response20",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Git Data1": {
      "main": [
        [
          {
            "node": "Convert Git Workflow to Binary1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert Git Workflow to Binary1": {
      "main": [
        [
          {
            "node": "Write Git Workflow File1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Git Workflow File1": {
      "main": [
        [
          {
            "node": "Git Add Workflow File1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Add Workflow File1": {
      "main": [
        [
          {
            "node": "Git Commit Workflow File1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Commit Workflow File1": {
      "main": [
        [
          {
            "node": "Git Latest Commit1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Latest Commit1": {
      "main": [
        [
          {
            "node": "Git Push Enabled?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Push Enabled?1": {
      "main": [
        [
          {
            "node": "Git Push Remote1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Finalize Git Local1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Push Remote1": {
      "main": [
        [
          {
            "node": "Finalize Git Push1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Finalize Git Local1": {
      "main": [
        [
          {
            "node": "Build Success Response20",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Finalize Git Push1": {
      "main": [
        [
          {
            "node": "Build Success Response20",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Backup Complete9": {
      "main": [
        [
          {
            "node": "Delete Old Backups Enabled?6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Backup File9": {
      "main": [
        [
          {
            "node": "Mark Backup Complete9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to Binary9": {
      "main": [
        [
          {
            "node": "Write Backup File9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Backup Data9": {
      "main": [
        [
          {
            "node": "Convert to Binary9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Data After Update11": {
      "main": [
        [
          {
            "node": "Local Backup Enabled?12",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Local Backup Enabled?12": {
      "main": [
        [
          {
            "node": "Prepare Backup Data9",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Git Enabled?2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions21": {
      "main": [
        [
          {
            "node": "Has Changes?21",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response21": {
      "main": [
        [
          {
            "node": "Respond to Webhook21",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions21": {
      "main": [
        [
          {
            "node": "Restore Data After Update11",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?21": {
      "main": [
        [
          {
            "node": "Dry Run Response21",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions21",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?21": {
      "main": [
        [
          {
            "node": "Dry Run?21",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response21",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow21": {
      "main": [
        [
          {
            "node": "Process Node Versions21",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration21": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow21",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cleanup Old Backups7": {
      "main": [
        [
          {
            "node": "Git Enabled?2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Backups Enabled?6": {
      "main": [
        [
          {
            "node": "Cleanup Old Backups7",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Git Enabled?2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Enabled?2": {
      "main": [
        [
          {
            "node": "Prepare Git Data2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Success Response21",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Git Data2": {
      "main": [
        [
          {
            "node": "Convert Git Workflow to Binary2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert Git Workflow to Binary2": {
      "main": [
        [
          {
            "node": "Write Git Workflow File2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Git Workflow File2": {
      "main": [
        [
          {
            "node": "Git Add Workflow File2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Add Workflow File2": {
      "main": [
        [
          {
            "node": "Git Commit Workflow File2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Commit Workflow File2": {
      "main": [
        [
          {
            "node": "Git Latest Commit2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Latest Commit2": {
      "main": [
        [
          {
            "node": "Git Push Enabled?2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Push Enabled?2": {
      "main": [
        [
          {
            "node": "Git Push Remote2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Finalize Git Local2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Push Remote2": {
      "main": [
        [
          {
            "node": "Finalize Git Push2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Finalize Git Local2": {
      "main": [
        [
          {
            "node": "Build Success Response21",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Finalize Git Push2": {
      "main": [
        [
          {
            "node": "Build Success Response21",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Manual Save Trigger": {
      "main": [
        [
          {
            "node": "Set Version Control Config1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Version Control Config1": {
      "main": [
        [
          {
            "node": "Call Sub-workflow (update value)1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Sub-workflow (update value)1": {
      "main": [
        [
          {
            "node": "Show Completion Message1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Backup Complete10": {
      "main": [
        [
          {
            "node": "Delete Old Backups Enabled?7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Backup File10": {
      "main": [
        [
          {
            "node": "Mark Backup Complete10",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to Binary10": {
      "main": [
        [
          {
            "node": "Write Backup File10",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Backup Data10": {
      "main": [
        [
          {
            "node": "Convert to Binary10",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Data After Update12": {
      "main": [
        [
          {
            "node": "Local Backup Enabled?13",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Local Backup Enabled?13": {
      "main": [
        [
          {
            "node": "Prepare Backup Data10",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Git Enabled?3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions22": {
      "main": [
        [
          {
            "node": "Has Changes?22",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response22": {
      "main": [
        [
          {
            "node": "Respond to Webhook22",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions22": {
      "main": [
        [
          {
            "node": "Restore Data After Update12",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?22": {
      "main": [
        [
          {
            "node": "Dry Run Response22",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions22",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?22": {
      "main": [
        [
          {
            "node": "Dry Run?22",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response22",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow22": {
      "main": [
        [
          {
            "node": "Process Node Versions22",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration22": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow22",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cleanup Old Backups8": {
      "main": [
        [
          {
            "node": "Git Enabled?3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Backups Enabled?7": {
      "main": [
        [
          {
            "node": "Cleanup Old Backups8",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Git Enabled?3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Enabled?3": {
      "main": [
        [
          {
            "node": "Prepare Git Data3",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Success Response22",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Git Data3": {
      "main": [
        [
          {
            "node": "Convert Git Workflow to Binary3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert Git Workflow to Binary3": {
      "main": [
        [
          {
            "node": "Write Git Workflow File3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Git Workflow File3": {
      "main": [
        [
          {
            "node": "Git Add Workflow File3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Add Workflow File3": {
      "main": [
        [
          {
            "node": "Git Commit Workflow File3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Commit Workflow File3": {
      "main": [
        [
          {
            "node": "Git Latest Commit3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Latest Commit3": {
      "main": [
        [
          {
            "node": "Git Push Enabled?3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Push Enabled?3": {
      "main": [
        [
          {
            "node": "Git Push Remote3",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Finalize Git Local3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Push Remote3": {
      "main": [
        [
          {
            "node": "Finalize Git Push3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Finalize Git Local3": {
      "main": [
        [
          {
            "node": "Build Success Response22",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Finalize Git Push3": {
      "main": [
        [
          {
            "node": "Build Success Response22",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Version Control Config Defaults1": {
      "main": [
        [
          {
            "node": "Parse Configuration23",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Backup Complete11": {
      "main": [
        [
          {
            "node": "Delete Old Backups Enabled?8",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Backup File11": {
      "main": [
        [
          {
            "node": "Mark Backup Complete11",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to Binary11": {
      "main": [
        [
          {
            "node": "Write Backup File11",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Backup Data11": {
      "main": [
        [
          {
            "node": "Convert to Binary11",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Data After Update13": {
      "main": [
        [
          {
            "node": "Local Backup Enabled?14",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Local Backup Enabled?14": {
      "main": [
        [
          {
            "node": "Prepare Backup Data11",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Git Enabled?4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions23": {
      "main": [
        [
          {
            "node": "Has Changes?23",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run Response23": {
      "main": [
        [
          {
            "node": "Respond to Webhook23",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions23": {
      "main": [
        [
          {
            "node": "Restore Data After Update13",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?23": {
      "main": [
        [
          {
            "node": "Dry Run Response23",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions23",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?23": {
      "main": [
        [
          {
            "node": "Dry Run?23",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response23",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow23": {
      "main": [
        [
          {
            "node": "Process Node Versions23",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration23": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow23",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cleanup Old Backups9": {
      "main": [
        [
          {
            "node": "Git Enabled?4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Backups Enabled?8": {
      "main": [
        [
          {
            "node": "Cleanup Old Backups9",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Git Enabled?4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Enabled?4": {
      "main": [
        [
          {
            "node": "Prepare Git Data4",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Success Response23",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Git Data4": {
      "main": [
        [
          {
            "node": "Convert Git Workflow to Binary4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert Git Workflow to Binary4": {
      "main": [
        [
          {
            "node": "Write Git Workflow File4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Git Workflow File4": {
      "main": [
        [
          {
            "node": "Git Add Workflow File4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Add Workflow File4": {
      "main": [
        [
          {
            "node": "Git Commit Workflow File4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Commit Workflow File4": {
      "main": [
        [
          {
            "node": "Git Latest Commit4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Latest Commit4": {
      "main": [
        [
          {
            "node": "Git Push Enabled?4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Push Enabled?4": {
      "main": [
        [
          {
            "node": "Git Push Remote4",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Finalize Git Local4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Push Remote4": {
      "main": [
        [
          {
            "node": "Finalize Git Push4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Finalize Git Local4": {
      "main": [
        [
          {
            "node": "Build Success Response23",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Finalize Git Push4": {
      "main": [
        [
          {
            "node": "Build Success Response23",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Resolve Config Overrides1": {
      "main": [
        [
          {
            "node": "Parse Configuration24",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Version Control Config Defaults": {
      "main": [
        [
          {
            "node": "Resolve Config Overrides1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Backup Complete12": {
      "main": [
        [
          {
            "node": "Delete Old Backups Enabled?9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Backup File12": {
      "main": [
        [
          {
            "node": "Mark Backup Complete12",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to Binary12": {
      "main": [
        [
          {
            "node": "Write Backup File12",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Backup Data12": {
      "main": [
        [
          {
            "node": "Convert to Binary12",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Data After Update14": {
      "main": [
        [
          {
            "node": "Local Backup Enabled?15",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Local Backup Enabled?15": {
      "main": [
        [
          {
            "node": "Prepare Backup Data12",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Git Enabled?5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Node Versions24": {
      "main": [
        [
          {
            "node": "Has Changes?24",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Workflow with Versions24": {
      "main": [
        [
          {
            "node": "Restore Data After Update14",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dry Run?24": {
      "main": [
        [
          {
            "node": "Dry Run Response24",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Workflow with Versions24",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Changes?24": {
      "main": [
        [
          {
            "node": "Dry Run?24",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Changes Response24",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Current Workflow24": {
      "main": [
        [
          {
            "node": "Process Node Versions24",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Configuration24": {
      "main": [
        [
          {
            "node": "Fetch Current Workflow24",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cleanup Old Backups10": {
      "main": [
        [
          {
            "node": "Git Enabled?5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Backups Enabled?9": {
      "main": [
        [
          {
            "node": "Cleanup Old Backups10",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Git Enabled?5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Enabled?5": {
      "main": [
        [
          {
            "node": "Prepare Git Data5",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Success Response24",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Git Data5": {
      "main": [
        [
          {
            "node": "Convert Git Workflow to Binary5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert Git Workflow to Binary5": {
      "main": [
        [
          {
            "node": "Write Git Workflow File5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Git Workflow File5": {
      "main": [
        [
          {
            "node": "Git Add Workflow File5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Add Workflow File5": {
      "main": [
        [
          {
            "node": "Git Commit Workflow File5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Commit Workflow File5": {
      "main": [
        [
          {
            "node": "Git Latest Commit5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Latest Commit5": {
      "main": [
        [
          {
            "node": "Git Push Enabled?5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Push Enabled?5": {
      "main": [
        [
          {
            "node": "Git Push Remote5",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Finalize Git Local5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Git Push Remote5": {
      "main": [
        [
          {
            "node": "Finalize Git Push5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Finalize Git Local5": {
      "main": [
        [
          {
            "node": "Build Success Response24",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Finalize Git Push5": {
      "main": [
        [
          {
            "node": "Build Success Response24",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false
  }
}
